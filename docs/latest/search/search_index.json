{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is cdk8s? \u00b6 cdk8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s generates pure Kubernetes YAML - you can use cdk8s to define applications for any Kubernetes cluster running anywhere. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide . Read our blog or watch our CNCF webinar to learn more and see a live demo of cdk8s in action. How does it work? \u00b6 cdk8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. cdk8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . cdk8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"What is cdk8s?"},{"location":"#what-is-cdk8s","text":"cdk8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s generates pure Kubernetes YAML - you can use cdk8s to define applications for any Kubernetes cluster running anywhere. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide . Read our blog or watch our CNCF webinar to learn more and see a live demo of cdk8s in action.","title":"What is cdk8s?"},{"location":"#how-does-it-work","text":"cdk8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. cdk8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . cdk8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"How does it work?"},{"location":"CHANGELOG/","text":"Changelog \u00b6 cdk8s is maintained via 3 repostories, each publishing their own modules. You can see each individual module changelog by visiting the releases page of each repository: cdk8s (Note that the cdk8s package is maintained in the cdk8s-team/cdk8s-core repository) cdk8s-cli cdk8s-plus","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"cdk8s is maintained via 3 repostories, each publishing their own modules. You can see each individual module changelog by visiting the releases page of each repository: cdk8s (Note that the cdk8s package is maintained in the cdk8s-team/cdk8s-core repository) cdk8s-cli cdk8s-plus","title":"Changelog"},{"location":"CONTRIBUTING/","text":"Contribution Guide \u00b6 cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs We follows the CNCF Community Code of Conduct Reporting Issues \u00b6 If any part of the project has bugs or documentation mistakes, please let us know by raising an issue. We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. In addition, make sure you are submitting the issue to the correct repository. If you know your issue petains to a specific cdk8s package, it better belongs in the respective repository. For a list of the repositories, see Repositories An issue can either be a bug report or a feature-request . If you wish to ask a question or seek guidance, please consider one of the other support channels . Bug reports \u00b6 To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here . Feature Requests \u00b6 We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here Code Contributions \u00b6 The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged Tracking issue \u00b6 All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers. Repositories \u00b6 This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus : high-level constructs for Kubernetes core. Development environment \u00b6 Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules. Unit tests \u00b6 Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u Integration Tests \u00b6 Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update Running Integration Tests \u00b6 The test directory contains integration tests for the cdk8s project. Each subdirectory represents a single test, with an entrypoint of test.sh . Tests are written as simple shell scripts and can simulate user activity. You can either run individual tests by executing their entrypoint directly (e.g. test-python-app/test.sh ) or run all tests by executing the script ./test-all.sh . Writing Integration Tests \u00b6 Create a new subdirectory with a test- prefix. Create a file named test.sh , make it executable. Test Environment: The script test.sh is executed within a temporary working directory under /tmp/xxxx/test (where xxxx is some random tmp file). See existing tests as examples on how to bring in auxiliary files to the test. Test MUST NOT install any dependencies or the cdk8s CLI. They can expect it to be available in the environment. To install dependencies from package managers, use yarn , npm , pipenv , mvn and nuget . Those programs will be shimmed to allow consuming local dependencies. Snapshot Testing \u00b6 Some integration tests utilize a simple snapshot testing mechanism. To update snapshots, run tests with: UPDATE_SNAPSHOTS=1 Or, run this from the root of the repo: yarn integ:update Docker environment for integration tests \u00b6 Due to the polyglot nature of the jsii tools used by cdk8s, the toolchain requirements are somewhat more complicated than for most projects. To help with this, you can use the jsii/superchain docker image that includes all the required tools. In order to get an interactive shell within a superchain container you can use the following command. docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain Then once in the docker shell, you can package and execute the tests as normal. $ pip install pipenv # Currently not included in jsii docker image $ yarn build $ yarn run package $ yarn integ:update Note: this may leave some files owned as the docker root user id. These will need to be cleaned up manually. Pull Requests \u00b6 We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx . Developer Certificate Of Origin (DCO) \u00b6 Every commit should be signed-off in compliance with the Developer Certificate Of Origin . You can sign your commits by using the git commit -s command. To configure automatic signoff, see git-hooks . Documentation \u00b6 Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: pip3 install -r docs/requirements.txt And then: mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website. Examples \u00b6 Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch). RFCs \u00b6 An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an [issue][https://github.com/cdk8s-team/cdk8s/issues/new?assignees=&labels=enhancement&template=rfc.md&title=%5BRFC%5D+describe+your+RFC] which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation. Community Meeting \u00b6 Note: Community meetings are currently on hold. We will be back soon. Keep an eye out for announcements on the #cdk8s channel in cdk.dev workspace. Join us for the cdk8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Contribution guide"},{"location":"CONTRIBUTING/#contribution-guide","text":"cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs We follows the CNCF Community Code of Conduct","title":"Contribution Guide"},{"location":"CONTRIBUTING/#reporting-issues","text":"If any part of the project has bugs or documentation mistakes, please let us know by raising an issue. We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. In addition, make sure you are submitting the issue to the correct repository. If you know your issue petains to a specific cdk8s package, it better belongs in the respective repository. For a list of the repositories, see Repositories An issue can either be a bug report or a feature-request . If you wish to ask a question or seek guidance, please consider one of the other support channels .","title":"Reporting Issues"},{"location":"CONTRIBUTING/#bug-reports","text":"To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here .","title":"Bug reports"},{"location":"CONTRIBUTING/#feature-requests","text":"We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here","title":"Feature Requests"},{"location":"CONTRIBUTING/#code-contributions","text":"The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged","title":"Code Contributions"},{"location":"CONTRIBUTING/#tracking-issue","text":"All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers.","title":"Tracking issue"},{"location":"CONTRIBUTING/#repositories","text":"This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus : high-level constructs for Kubernetes core.","title":"Repositories"},{"location":"CONTRIBUTING/#development-environment","text":"Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules.","title":"Development environment"},{"location":"CONTRIBUTING/#unit-tests","text":"Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u","title":"Unit tests"},{"location":"CONTRIBUTING/#integration-tests","text":"Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update","title":"Integration Tests"},{"location":"CONTRIBUTING/#pull-requests","text":"We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx .","title":"Pull Requests"},{"location":"CONTRIBUTING/#documentation","text":"Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: pip3 install -r docs/requirements.txt And then: mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website.","title":"Documentation"},{"location":"CONTRIBUTING/#examples","text":"Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch).","title":"Examples"},{"location":"CONTRIBUTING/#rfcs","text":"An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an [issue][https://github.com/cdk8s-team/cdk8s/issues/new?assignees=&labels=enhancement&template=rfc.md&title=%5BRFC%5D+describe+your+RFC] which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation.","title":"RFCs"},{"location":"CONTRIBUTING/#community-meeting","text":"Note: Community meetings are currently on hold. We will be back soon. Keep an eye out for announcements on the #cdk8s channel in cdk.dev workspace. Join us for the cdk8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Community Meeting"},{"location":"ROADMAP/","text":"Roadmap \u00b6 To see items we are working on, visit our RoadMap GitHub project . You can submit an idea here .","title":"Roadmap"},{"location":"ROADMAP/#roadmap","text":"To see items we are working on, visit our RoadMap GitHub project . You can submit an idea here .","title":"Roadmap"},{"location":"ecosystem-interoperability/","text":"Ecosystem Interoperability \u00b6 As we know, there are many CDK based libraries out there, and you might want to incorporate cdk8s along side other libraries in the same application. Example For example, you can use cdk8s to define charts in an AWS CDK application, and apply them using the EKS construct library . This ability, or interoperability, is based on the constructs programming model , which is the underlying technology on which all CDK libraries are built upon. All CDK libraries participating in the same application, must use the same major version of constructs , which currently has both a 3.x and a 10.x major version lines. In order to incorporate cdk8s in applications that use either version line, we need to maintain two major versions of cdk8s , one for each version of constructs . Version 1.x can be used along side libraries that depend on constructs version 3.x. For example: AWS CDK v1 . Version 2.x can be used along side libraries that depend on constructs version 10.x. For example: AWS CDK v2 .","title":"Ecosystem Interoperability"},{"location":"ecosystem-interoperability/#ecosystem-interoperability","text":"As we know, there are many CDK based libraries out there, and you might want to incorporate cdk8s along side other libraries in the same application. Example For example, you can use cdk8s to define charts in an AWS CDK application, and apply them using the EKS construct library . This ability, or interoperability, is based on the constructs programming model , which is the underlying technology on which all CDK libraries are built upon. All CDK libraries participating in the same application, must use the same major version of constructs , which currently has both a 3.x and a 10.x major version lines. In order to incorporate cdk8s in applications that use either version line, we need to maintain two major versions of cdk8s , one for each version of constructs . Version 1.x can be used along side libraries that depend on constructs version 3.x. For example: AWS CDK v1 . Version 2.x can be used along side libraries that depend on constructs version 10.x. For example: AWS CDK v2 .","title":"Ecosystem Interoperability"},{"location":"getting-started/","text":"Getting started \u00b6 This guide will walk you through the following steps: Installing the cdk8s CLI. Creating a new cdk8s project in one of the supported programming languages. Define & deploy your first cdk8s application. Define a custom cdk8s construct. Install the CLI \u00b6 cdk8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the cdk8s CLI globally. We have three options for this. Homebrew npm yarn brew install cdk8s npm install -g cdk8s-cli yarn global add cdk8s-cli Prerequisites \u00b6 Set up pre-requisites based on the language you wish to write your cdk8s code in. TypeScript Python Java Go Node.js >= 12.13.0 Your favorite editor/IDE yarn (optional) Python >= 3.7.7 pipenv version 2018.11.26 or above. Your favorite editor/IDE Maven >= 3.6.3 Your favorite editor/IDE Go >= 1.16 Your favorite editor/IDE Info This Getting Started guide will help you create a Kubernetes manifest using your preferred programming language. You do not need access to a Kubernetes cluster in order to produce a manifests using cdk8s. New Project \u00b6 Now, we\u2019ll use the cdk8s init command to create a new cdk8s app: TypeScript Python Java Go $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install cdk8s as a dependency Import all Kubernetes API objects Apps & Charts \u00b6 Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you synthesize the app, a Kubernetes manifest YAML will be produced for each Chart in your app and will write it to the dist directory. At this point, the YAML file should be empty since we haven\u2019t defined any resources yet. Let have a look at the code: TypeScript Python Java Go main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); To produce and inspect the generated manifest, you can run: npm run compile && cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Note that since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our cdk8s app. To avoid explicitly compiling every time, you can run a watch process in the background by running: npm run watch main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> main.go package main import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Importing Constructs for the Kubernetes API \u00b6 OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in cdk8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript Python Java Go import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; // notice that there is no assignment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // attributes of the resource in other parts of the code. new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Now, to synthesize the app, run: npm run compile && cdk8s synth #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } # notice that there is no assignment necessary when creating resources. # simply instantiating the resource is enough because it adds it to the construct tree via # the first argument, which is always the parent construct. # its a little confusing at first glance, but this is an inherent aspect of the constructs # programming model, and you will encounter it many times. # you can still perform an assignment of course, if you need to access # attributes of the resource in other parts of the code. k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Now, to synthesize the app, run: cdk8s synth package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); // notice that there is no assignment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // attributes of the resource in other parts of the code. new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, to synthesize the app, run: cdk8s synth package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) // notice that there is no assignment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // attributes of the resource in other parts of the code. k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, to synthesize the app, run: cdk8s synth This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml Abstraction through Constructs \u00b6 Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript Python Java Go new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Python Java Go Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Getting started"},{"location":"getting-started/#getting-started","text":"This guide will walk you through the following steps: Installing the cdk8s CLI. Creating a new cdk8s project in one of the supported programming languages. Define & deploy your first cdk8s application. Define a custom cdk8s construct.","title":"Getting started"},{"location":"getting-started/#install-the-cli","text":"cdk8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the cdk8s CLI globally. We have three options for this. Homebrew npm yarn brew install cdk8s npm install -g cdk8s-cli yarn global add cdk8s-cli","title":"Install the CLI"},{"location":"getting-started/#prerequisites","text":"Set up pre-requisites based on the language you wish to write your cdk8s code in. TypeScript Python Java Go Node.js >= 12.13.0 Your favorite editor/IDE yarn (optional) Python >= 3.7.7 pipenv version 2018.11.26 or above. Your favorite editor/IDE Maven >= 3.6.3 Your favorite editor/IDE Go >= 1.16 Your favorite editor/IDE Info This Getting Started guide will help you create a Kubernetes manifest using your preferred programming language. You do not need access to a Kubernetes cluster in order to produce a manifests using cdk8s.","title":"Prerequisites"},{"location":"getting-started/#new-project","text":"Now, we\u2019ll use the cdk8s init command to create a new cdk8s app: TypeScript Python Java Go $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install cdk8s as a dependency Import all Kubernetes API objects","title":"New Project"},{"location":"getting-started/#apps-charts","text":"Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you synthesize the app, a Kubernetes manifest YAML will be produced for each Chart in your app and will write it to the dist directory. At this point, the YAML file should be empty since we haven\u2019t defined any resources yet. Let have a look at the code: TypeScript Python Java Go main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); To produce and inspect the generated manifest, you can run: npm run compile && cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Note that since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our cdk8s app. To avoid explicitly compiling every time, you can run a watch process in the background by running: npm run watch main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> main.go package main import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY>","title":"Apps &amp; Charts"},{"location":"getting-started/#importing-constructs-for-the-kubernetes-api","text":"OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in cdk8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript Python Java Go import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; // notice that there is no assignment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // attributes of the resource in other parts of the code. new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Now, to synthesize the app, run: npm run compile && cdk8s synth #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } # notice that there is no assignment necessary when creating resources. # simply instantiating the resource is enough because it adds it to the construct tree via # the first argument, which is always the parent construct. # its a little confusing at first glance, but this is an inherent aspect of the constructs # programming model, and you will encounter it many times. # you can still perform an assignment of course, if you need to access # attributes of the resource in other parts of the code. k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Now, to synthesize the app, run: cdk8s synth package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); // notice that there is no assignment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // attributes of the resource in other parts of the code. new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, to synthesize the app, run: cdk8s synth package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) // notice that there is no assignment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // attributes of the resource in other parts of the code. k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, to synthesize the app, run: cdk8s synth This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml","title":"Importing Constructs for the Kubernetes API"},{"location":"getting-started/#abstraction-through-constructs","text":"Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript Python Java Go new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Python Java Go Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Abstraction through Constructs"},{"location":"media/","text":"Media \u00b6 Logos \u00b6 Horizontal \u00b6 PNG SVG color black white Stacked \u00b6 PNG SVG color black white Icon \u00b6 PNG SVG color black white","title":"Media"},{"location":"media/#media","text":"","title":"Media"},{"location":"media/#logos","text":"","title":"Logos"},{"location":"media/#horizontal","text":"PNG SVG color black white","title":"Horizontal"},{"location":"media/#stacked","text":"PNG SVG color black white","title":"Stacked"},{"location":"media/#icon","text":"PNG SVG color black white","title":"Icon"},{"location":"migrating-from-1.x/","text":"Migrating from 1.x \u00b6 This page describes the difference between versions 1.x and 2.x of the cdk8s toolchain, as well as instructions on how to migrate from one to the other. Deprecation Timeline \u00b6 Version 1.x of the cdk8s toolchain will be deprecated on 01/01/2023. After which, it will only receive critical bug fixes and security patches, but there will be no active development on it. We strongly recommend migrating to 2.x using the instructions stated below. Core Library \u00b6 Version 2.x of the core cdk8s library is identical to version 1.x from an API perspective. The only difference is in the dependency they declare on the constructs library. This also means that the documentation and code snippets presented throughout the site is compatible with 1.x as well, in case you\u2019d still like to use it. Info See Ecosystem Interoperability for reasoning behind this change. Following are instructions on what changes should be performed to use version 2.x : TypeScript Java Python Go In package.json , define: \"dependencies\" : { \"cdk8s\" : \"^2.2.87\" , \"constructs\" : \"^10.1.12\" } In pom.xml , define: <dependencies> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> [2.2.86,3.0] </version> </dependency> <dependency> <groupId> software.constructs </groupId> <artifactId> constructs </artifactId> <version> [10.1.12,11.0.0] </version> </dependency> </dependencies> In Pipfile , define: [packages] constructs = \"~=10.1.12\" cdk8s = \"~=2.2.87\" In go.mod , define: require ( github . com / aws / constructs - go / constructs / v10 v10 .1.12 github . com / cdk8s - team / cdk8s - core - go / cdk8s / v2 v2 .2.87 ) Since major versions are encoded in go import statements, in your source code, change to: import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) CLI \u00b6 Version 2.x of the cdk8s-cli is identical to version 1.x from an API perspective. The only difference is in the project templates cdk8s init generates. CLI version 1.x / 2.x will initiate projects utilizing version 1.x / 2.x of the core library, accordingly. If you\u2019d like to continue using version 1.x of the CLI: Homebrew npm yarn Locate the latest 1.x version you\u2019d like to install, and: brew install cdk8s@1.<minor>.<patch> npm install -g cdk8s-cli@^1 yarn global add cdk8s-cli@^1","title":"Migrating from 1.x"},{"location":"migrating-from-1.x/#migrating-from-1x","text":"This page describes the difference between versions 1.x and 2.x of the cdk8s toolchain, as well as instructions on how to migrate from one to the other.","title":"Migrating from 1.x"},{"location":"migrating-from-1.x/#deprecation-timeline","text":"Version 1.x of the cdk8s toolchain will be deprecated on 01/01/2023. After which, it will only receive critical bug fixes and security patches, but there will be no active development on it. We strongly recommend migrating to 2.x using the instructions stated below.","title":"Deprecation Timeline"},{"location":"migrating-from-1.x/#core-library","text":"Version 2.x of the core cdk8s library is identical to version 1.x from an API perspective. The only difference is in the dependency they declare on the constructs library. This also means that the documentation and code snippets presented throughout the site is compatible with 1.x as well, in case you\u2019d still like to use it. Info See Ecosystem Interoperability for reasoning behind this change. Following are instructions on what changes should be performed to use version 2.x : TypeScript Java Python Go In package.json , define: \"dependencies\" : { \"cdk8s\" : \"^2.2.87\" , \"constructs\" : \"^10.1.12\" } In pom.xml , define: <dependencies> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> [2.2.86,3.0] </version> </dependency> <dependency> <groupId> software.constructs </groupId> <artifactId> constructs </artifactId> <version> [10.1.12,11.0.0] </version> </dependency> </dependencies> In Pipfile , define: [packages] constructs = \"~=10.1.12\" cdk8s = \"~=2.2.87\" In go.mod , define: require ( github . com / aws / constructs - go / constructs / v10 v10 .1.12 github . com / cdk8s - team / cdk8s - core - go / cdk8s / v2 v2 .2.87 ) Since major versions are encoded in go import statements, in your source code, change to: import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" )","title":"Core Library"},{"location":"migrating-from-1.x/#cli","text":"Version 2.x of the cdk8s-cli is identical to version 1.x from an API perspective. The only difference is in the project templates cdk8s init generates. CLI version 1.x / 2.x will initiate projects utilizing version 1.x / 2.x of the core library, accordingly. If you\u2019d like to continue using version 1.x of the CLI: Homebrew npm yarn Locate the latest 1.x version you\u2019d like to install, and: brew install cdk8s@1.<minor>.<patch> npm install -g cdk8s-cli@^1 yarn global add cdk8s-cli@^1","title":"CLI"},{"location":"basics/","text":"Basic concepts of cdk8s \u00b6 This section discusses core concepts in cdk8s. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide .","title":"Basic concepts of cdk8s"},{"location":"basics/#basic-concepts-of-cdk8s","text":"This section discusses core concepts in cdk8s. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide .","title":"Basic concepts of cdk8s"},{"location":"basics/api-object/","text":"ApiObject \u00b6 An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in cdk8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"basics/api-object/#apiobject","text":"An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in cdk8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"basics/chart/","text":"Chart \u00b6 The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"basics/chart/#chart","text":"The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"basics/constructs/","text":"Constructs \u00b6 Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"basics/constructs/#constructs","text":"Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"basics/deps/","text":"Dependencies \u00b6 You can declare dependencies between any two cdk8s constructs using the addDependency() method. ApiObjects \u00b6 For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47 Charts \u00b6 You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second. Custom Constructs \u00b6 The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object. Things just got cool \u00b6 If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Dependencies"},{"location":"basics/deps/#dependencies","text":"You can declare dependencies between any two cdk8s constructs using the addDependency() method.","title":"Dependencies"},{"location":"basics/deps/#apiobjects","text":"For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47","title":"ApiObjects"},{"location":"basics/deps/#charts","text":"You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second.","title":"Charts"},{"location":"basics/deps/#custom-constructs","text":"The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object.","title":"Custom Constructs"},{"location":"basics/deps/#things-just-got-cool","text":"If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Things just got cool"},{"location":"basics/escape-hatches/","text":"Escape Hatches \u00b6 An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. cdk8s+) which does not expose some functionality which exists in the lower-level resources. Patching API objects directly \u00b6 The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method. Patching API objects behind higher-level APIs \u00b6 The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from cdk8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the cdk8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-24' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Escape Hatches"},{"location":"basics/escape-hatches/#escape-hatches","text":"An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. cdk8s+) which does not expose some functionality which exists in the lower-level resources.","title":"Escape Hatches"},{"location":"basics/escape-hatches/#patching-api-objects-directly","text":"The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method.","title":"Patching API objects directly"},{"location":"basics/escape-hatches/#patching-api-objects-behind-higher-level-apis","text":"The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from cdk8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the cdk8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-24' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Patching API objects behind higher-level APIs"},{"location":"basics/helm/","text":"Helm Support \u00b6 You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"basics/helm/#helm-support","text":"You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"basics/include/","text":"Include \u00b6 The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"basics/include/#include","text":"The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"basics/testing/","text":"Testing \u00b6 cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"basics/testing/#testing","text":"cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"cli/","text":"Command Line Interface (CLI) \u00b6 cdk8s is shipped with a command-line interface called cdk8s which can be used to work with cdk8s apps. The CLI is not required to use cdk8s but it includes some useful utilities. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide .","title":"Command Line Interface (CLI)"},{"location":"cli/#command-line-interface-cli","text":"cdk8s is shipped with a command-line interface called cdk8s which can be used to work with cdk8s apps. The CLI is not required to use cdk8s but it includes some useful utilities. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide .","title":"Command Line Interface (CLI)"},{"location":"cli/import/","text":"import \u00b6 The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs). General Options \u00b6 Target programming language ( --language ) \u00b6 You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript Output directory ( --output ) \u00b6 The --output (or -o ) option can be used to specify the output directory for your imports. Class name prefix ( --class-prefix ) \u00b6 For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports. Module name \u00b6 You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript Python import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; not yet supported Import Types \u00b6 The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import. Kubernetes APIs \u00b6 To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Tip It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ). Kubernetes Versions \u00b6 Use the @version notation to import a specific Kubernetes version: cdk8s import k8s@1.16.0 Alternatively, you can specify your k8s import in the cdk8s.yaml config file: imports : - k8s@1.17.0 API Object Versions \u00b6 When importing the core Kubernetes API objects, cdk8s import will generate constructs both for stable APIs (e.g. v1 ) and pre-stable APIs ( v1beta1 ). To ensure compatibility across Kubernetes versions, construct classes generated for non-stable resources will include a postfix with the API level. For example, the import for k8s@1.18 includes KubeIngressV1Beta1 as the only Ingress resource. This is because Ingress has not been stabilized yet. The import for k8s@1.19 will also include an Ingress construct which represents the v1 resource. CRDs \u00b6 You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io Importing CRDs from a cluster \u00b6 If the imported YAML is a List of CRDs, all these CRDs will be imported. This is useful, for example, to import all the CRDs from a running cluster: kubectl get crds -o json | cdk8s import /dev/stdin Yes, this works!","title":"import"},{"location":"cli/import/#import","text":"The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs).","title":"import"},{"location":"cli/import/#general-options","text":"","title":"General Options"},{"location":"cli/import/#target-programming-language-language","text":"You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript","title":"Target programming language (--language)"},{"location":"cli/import/#output-directory-output","text":"The --output (or -o ) option can be used to specify the output directory for your imports.","title":"Output directory (--output)"},{"location":"cli/import/#class-name-prefix-class-prefix","text":"For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports.","title":"Class name prefix (--class-prefix)"},{"location":"cli/import/#module-name","text":"You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript Python import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; not yet supported","title":"Module name"},{"location":"cli/import/#import-types","text":"The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import.","title":"Import Types"},{"location":"cli/import/#kubernetes-apis","text":"To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Tip It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ).","title":"Kubernetes APIs"},{"location":"cli/import/#crds","text":"You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io","title":"CRDs"},{"location":"cli/init/","text":"init \u00b6 This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/init/#init","text":"This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/installation/","text":"Installation \u00b6 To install the CLI use one of the following methods: npm yarn Homebrew npm i -g cdk8s-cli yarn global add cdk8s-cli brew install cdk8s","title":"Installation"},{"location":"cli/installation/#installation","text":"To install the CLI use one of the following methods: npm yarn Homebrew npm i -g cdk8s-cli yarn global add cdk8s-cli brew install cdk8s","title":"Installation"},{"location":"cli/synth/","text":"synth \u00b6 The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js . Configuring synth output \u00b6 The properties of the synthesized YAML from cdk8s synth can be modified by the properties of the App construct. Things like file extensions, how API objects are distributed between files, and the output directory can all be configured in your AppProps For example: const app = new App ({ // Instead of the default \"dist\" outdir : \"output\" , // Instead of \".k8s.yaml\" outputFileExtension : \".generated.yaml\" , // Divide every resource into its own file, instead of grouping by Chart yamlOutputType : YamlOutputType.FILE_PER_RESOURCE , });","title":"synth"},{"location":"cli/synth/#synth","text":"The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"cli/synth/#configuring-synth-output","text":"The properties of the synthesized YAML from cdk8s synth can be modified by the properties of the App construct. Things like file extensions, how API objects are distributed between files, and the output directory can all be configured in your AppProps For example: const app = new App ({ // Instead of the default \"dist\" outdir : \"output\" , // Instead of \".k8s.yaml\" outputFileExtension : \".generated.yaml\" , // Divide every resource into its own file, instead of grouping by Chart yamlOutputType : YamlOutputType.FILE_PER_RESOURCE , });","title":"Configuring synth output"},{"location":"examples/","text":"Examples \u00b6 This section includes references for cdk8s and cdk8s+ examples that we have in our GitHub repository. TypeScript Python Java Go Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions Elasticsearch (cdk8s+) - Creating a query service on top of Elasticsearch with cdk8s+ Ingress (cdk8s+) - Example of using cdk8s+ Ingress resource. Podinfo - Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Info We try to maintain the same set of examples in all supported languages. Help us!","title":"Examples"},{"location":"examples/#examples","text":"This section includes references for cdk8s and cdk8s+ examples that we have in our GitHub repository. TypeScript Python Java Go Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions Elasticsearch (cdk8s+) - Creating a query service on top of Elasticsearch with cdk8s+ Ingress (cdk8s+) - Example of using cdk8s+ Ingress resource. Podinfo - Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Hello, Kubernetes! - Deploys hello-kubernetes as a Service behind a LoadBalancer. CRDs - Shows how to import and use Custom Resource Definitions WebService Abstraction - Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. Info We try to maintain the same set of examples in all supported languages. Help us!","title":"Examples"},{"location":"plus/","text":"cdk8s+ \u00b6 cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by cdk8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide . Here is an example of how we would deploy a simple nginx container, once with the low-level API (on the left), and once with the high level abstraction (on the right). cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.24.0 and is vended as the cdk8s-plus-24 library. Naming conventions \u00b6 Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct . Spec compatibility \u00b6 Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.24.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Warning If you are deploying manifests produced by cdk8s-plus-24 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests. FAQ \u00b6 What\u2019s the difference between cdk8s-plus-20 , cdk8s-plus-21 , and cdk8s-plus-22 ? \u00b6 These are separately vended libraries that each target a different kubernetes version, marked by the -XX suffix. For example, cdk8s-plus-22 targets kubernetes version 1.22.0 . We offer a dedicated package per Kubernetes version to allow users to match their manifests to the Kubernetes version they are operating. This way, users are only exposed to a set of capabilities offered by their specific cluster, preventing deployment errors caused by version mismatches. For example, imagine we had published a single library for all Kubernetes versions (call it cdk8s-plus ). This library would have had support for the namespaceSelector property when configuring pod affinity rules. This property was only added in Kubernetes 1.21.0. Now imagine you operate Kubernetes 1.20.0. In such a case, you would have access to the namespaceSelector property, even though it is unsupported, and will result in a deployment failure if you use it. With a dedicated package, this property would not be available for you to (mis)use. I operate Kubernetes version 1.XX - which cdk8s+ library should I be using? \u00b6 If there is a cdk8s-plus-XX library that matches your target Kubernetes version, we recommend using it since all Kubernetes manifests generated using it will be compatible. If there is not a matching cdk8s-plus-XX library, we recommend using the closest matching version. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests. I\u2019m using cdk8s-plus-XX - which kubernetes versions will my manifest work on? \u00b6 If you are using stable APIs (those that are not in alpha or beta), manifests generated in cdk8s-plus-XX will work in Kubernetes versions 1.XX.0 and above. Unstable APIs (which are always labeled in cdk8s+ using a suffix, e.g. IngressV1Beta1 ) may work in newer versions of Kubernetes, but it is also possible they have been removed. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests. At a glance \u00b6 import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . exposeViaService ({ serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer Getting Started \u00b6 TypeScript JavaScript Python Java Go \u276f npm install cdk8s-plus-24 cdk8s constructs import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); \u276f npm install cdk8s-plus-24 cdk8s constructs const kplus = require ( 'cdk8s-plus-24' ); const cdk8s = require ( 'cdk8s' ); const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); \u276f pip install --pre cdk8s-plus-24 cdk8s import cdk8s_plus_22 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . ContainerProps ( image = 'ubuntu' )] ) app . synth () <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> 1.0.0-beta.46 </version> </dependency> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s-plus-24 </artifactId> <version> 2.0.0-beta.3 </version> </dependency> import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.plus22.Deployment ; import org.cdk8s.plus22.ContainerProps ; App app = new App (); Chart chart = new Chart ( app , \"Chart\" ); Deployment . Builder . create ( this , \"Deployment\" ) . replicas ( 3 ) . containers ( Arrays . asList ( ContainerProps . builder () . image ( \"ubuntu\" ) . build ())) . build (); app . synth (); import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" \"github.com/cdk8s-team/cdk8s-plus-go/cdk8splus24\" ) app := cdk8s . NewApp ( nil ) chart := cdk8s . NewChart ( app , jsii . String ( \"ubuntu\" ), nil ) cdk8splus24 . NewDeployment ( chart , jsii . String ( \"Deployment\" ), & cdk8splus24 . DeploymentProps { Replicas : jsii . Number ( 3 ), Containers : & [] * cdk8splus24 . ContainerProps {{ Image : jsii . String ( \"ubuntu\" ), }}, }) app . Synth () Overcoming Coverage Gaps \u00b6 As mentioned, the APIs offered by cdk8s+ are hand-written by the team as well as the community. As such, you might encounter coverage gaps from time to time; that is, you are trying to configure something but the API doesn\u2019t expose it. There are two kinds of gaps: Missing Resource \u00b6 When an entire resource is missing, you can supplement it by dropping to the L1 layer of constructs, which are available from within cdk8s+ , so you don\u2019t need to install an additional library, or import any resources. For example: import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); // a Deployment exists as a higher level objects, // so we use it. new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); // a StorageClass doesn't, so we use the low level objects. // notice the '.k8s.' addition. new kplus . k8s . KubeStorageClass ( chart , 'StorageClass' , { provisioner : 'kubernetes.io/aws-ebs' }); app . synth (); Missing Property \u00b6 See https://cdk8s.io/docs/latest/basics/escape-hatches/#patching-api-objects-behind-higher-level-apis","title":"cdk8s+"},{"location":"plus/#cdk8s","text":"cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by cdk8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. Info The documentation here relates to version 2.x of the cdk8s toolchain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide . Here is an example of how we would deploy a simple nginx container, once with the low-level API (on the left), and once with the high level abstraction (on the right). cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.24.0 and is vended as the cdk8s-plus-24 library.","title":"cdk8s+"},{"location":"plus/#naming-conventions","text":"Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct .","title":"Naming conventions"},{"location":"plus/#spec-compatibility","text":"Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.24.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Warning If you are deploying manifests produced by cdk8s-plus-24 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests.","title":"Spec compatibility"},{"location":"plus/#faq","text":"","title":"FAQ"},{"location":"plus/#whats-the-difference-between-cdk8s-plus-20-cdk8s-plus-21-and-cdk8s-plus-22","text":"These are separately vended libraries that each target a different kubernetes version, marked by the -XX suffix. For example, cdk8s-plus-22 targets kubernetes version 1.22.0 . We offer a dedicated package per Kubernetes version to allow users to match their manifests to the Kubernetes version they are operating. This way, users are only exposed to a set of capabilities offered by their specific cluster, preventing deployment errors caused by version mismatches. For example, imagine we had published a single library for all Kubernetes versions (call it cdk8s-plus ). This library would have had support for the namespaceSelector property when configuring pod affinity rules. This property was only added in Kubernetes 1.21.0. Now imagine you operate Kubernetes 1.20.0. In such a case, you would have access to the namespaceSelector property, even though it is unsupported, and will result in a deployment failure if you use it. With a dedicated package, this property would not be available for you to (mis)use.","title":"What's the difference between cdk8s-plus-20, cdk8s-plus-21, and cdk8s-plus-22?"},{"location":"plus/#i-operate-kubernetes-version-1xx-which-cdk8s-library-should-i-be-using","text":"If there is a cdk8s-plus-XX library that matches your target Kubernetes version, we recommend using it since all Kubernetes manifests generated using it will be compatible. If there is not a matching cdk8s-plus-XX library, we recommend using the closest matching version. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests.","title":"I operate Kubernetes version 1.XX - which cdk8s+ library should I be using?"},{"location":"plus/#im-using-cdk8s-plus-xx-which-kubernetes-versions-will-my-manifest-work-on","text":"If you are using stable APIs (those that are not in alpha or beta), manifests generated in cdk8s-plus-XX will work in Kubernetes versions 1.XX.0 and above. Unstable APIs (which are always labeled in cdk8s+ using a suffix, e.g. IngressV1Beta1 ) may work in newer versions of Kubernetes, but it is also possible they have been removed. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests.","title":"I'm using cdk8s-plus-XX - which kubernetes versions will my manifest work on?"},{"location":"plus/#at-a-glance","text":"import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . exposeViaService ({ serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer","title":"At a glance"},{"location":"plus/#getting-started","text":"TypeScript JavaScript Python Java Go \u276f npm install cdk8s-plus-24 cdk8s constructs import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); \u276f npm install cdk8s-plus-24 cdk8s constructs const kplus = require ( 'cdk8s-plus-24' ); const cdk8s = require ( 'cdk8s' ); const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); \u276f pip install --pre cdk8s-plus-24 cdk8s import cdk8s_plus_22 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . ContainerProps ( image = 'ubuntu' )] ) app . synth () <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> 1.0.0-beta.46 </version> </dependency> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s-plus-24 </artifactId> <version> 2.0.0-beta.3 </version> </dependency> import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.plus22.Deployment ; import org.cdk8s.plus22.ContainerProps ; App app = new App (); Chart chart = new Chart ( app , \"Chart\" ); Deployment . Builder . create ( this , \"Deployment\" ) . replicas ( 3 ) . containers ( Arrays . asList ( ContainerProps . builder () . image ( \"ubuntu\" ) . build ())) . build (); app . synth (); import ( \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" \"github.com/cdk8s-team/cdk8s-plus-go/cdk8splus24\" ) app := cdk8s . NewApp ( nil ) chart := cdk8s . NewChart ( app , jsii . String ( \"ubuntu\" ), nil ) cdk8splus24 . NewDeployment ( chart , jsii . String ( \"Deployment\" ), & cdk8splus24 . DeploymentProps { Replicas : jsii . Number ( 3 ), Containers : & [] * cdk8splus24 . ContainerProps {{ Image : jsii . String ( \"ubuntu\" ), }}, }) app . Synth ()","title":"Getting Started"},{"location":"plus/#overcoming-coverage-gaps","text":"As mentioned, the APIs offered by cdk8s+ are hand-written by the team as well as the community. As such, you might encounter coverage gaps from time to time; that is, you are trying to configure something but the API doesn\u2019t expose it. There are two kinds of gaps:","title":"Overcoming Coverage Gaps"},{"location":"plus/#missing-resource","text":"When an entire resource is missing, you can supplement it by dropping to the L1 layer of constructs, which are available from within cdk8s+ , so you don\u2019t need to install an additional library, or import any resources. For example: import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); // a Deployment exists as a higher level objects, // so we use it. new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); // a StorageClass doesn't, so we use the low level objects. // notice the '.k8s.' addition. new kplus . k8s . KubeStorageClass ( chart , 'StorageClass' , { provisioner : 'kubernetes.io/aws-ebs' }); app . synth ();","title":"Missing Resource"},{"location":"plus/#missing-property","text":"See https://cdk8s.io/docs/latest/basics/escape-hatches/#patching-api-objects-behind-higher-level-apis","title":"Missing Property"},{"location":"plus/config-map/","text":"ConfigMap \u00b6 ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference Use an existing ConfigMap \u00b6 You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-24' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config ); Adding data \u00b6 You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' ); Creating a volume from a directory \u00b6 Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"ConfigMap"},{"location":"plus/config-map/#configmap","text":"ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference","title":"ConfigMap"},{"location":"plus/config-map/#use-an-existing-configmap","text":"You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-24' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config );","title":"Use an existing ConfigMap"},{"location":"plus/config-map/#adding-data","text":"You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' );","title":"Adding data"},{"location":"plus/config-map/#creating-a-volume-from-a-directory","text":"Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"Creating a volume from a directory"},{"location":"plus/container/","text":"Container \u00b6 Define containers that run in a pod using the Container class. API Reference Environment \u00b6 A container\u2019s environment can be populated by various methods. Variables \u00b6 Environment variables can be added to containers by specifying the variable name and value. The value can come from different sources, either dynamic or static. import * as kplus from 'cdk8s-plus-24' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // use a static value. container . env . addVariable ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . env . addVariable ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . env . addVariable ( 'password' , kplus . EnvValue . fromSecretValue ({ secret : credentials , key : 'password' })); You can pass env variables at instantiation time as well by specifying the envVariables property. Sources \u00b6 Environment variables can also be populated by referencing other objects as an environment source. With this method, all the key-value data of the source is added as environment variables, where the key is the env name and the value is the env value. import * as kplus from 'cdk8s-plus-24' const pod = new kplus . Pod ( this , 'Pod' ); const cm = new kplus . ConfigMap ( this , 'ConfigMap' , { data : { key : 'value' , } }); const container = pod . addContainer ({ image : 'my-app' }); // this will add 'key=value' env variable at runtime. container . env . copyFrom ( kplus . Env . fromConfigMap ( cm )); Volume Mounts \u00b6 A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-24' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume ); Probes \u00b6 A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Container"},{"location":"plus/container/#container","text":"Define containers that run in a pod using the Container class. API Reference","title":"Container"},{"location":"plus/container/#environment","text":"A container\u2019s environment can be populated by various methods.","title":"Environment"},{"location":"plus/container/#variables","text":"Environment variables can be added to containers by specifying the variable name and value. The value can come from different sources, either dynamic or static. import * as kplus from 'cdk8s-plus-24' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // use a static value. container . env . addVariable ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . env . addVariable ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . env . addVariable ( 'password' , kplus . EnvValue . fromSecretValue ({ secret : credentials , key : 'password' })); You can pass env variables at instantiation time as well by specifying the envVariables property.","title":"Variables"},{"location":"plus/container/#sources","text":"Environment variables can also be populated by referencing other objects as an environment source. With this method, all the key-value data of the source is added as environment variables, where the key is the env name and the value is the env value. import * as kplus from 'cdk8s-plus-24' const pod = new kplus . Pod ( this , 'Pod' ); const cm = new kplus . ConfigMap ( this , 'ConfigMap' , { data : { key : 'value' , } }); const container = pod . addContainer ({ image : 'my-app' }); // this will add 'key=value' env variable at runtime. container . env . copyFrom ( kplus . Env . fromConfigMap ( cm ));","title":"Sources"},{"location":"plus/container/#volume-mounts","text":"A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-24' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume );","title":"Volume Mounts"},{"location":"plus/container/#probes","text":"A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Probes"},{"location":"plus/cronjob/","text":"CronJob \u00b6 CronJob resource is responsible for creating recurring Jobs . The job recurrence is determined by a Cron expression. CronJob is similar to a job but it is suitable when there is a need to run a job indefinitely following a schedule. These repetitive jobs can be utilized for recurring tasks such as backing up a database, pinging a server for health checks, creating snapshots of systems and much more. API Reference Creating a CronJob \u00b6 import * as kplus from 'cdk8s-plus-24' ; import { Construct } from 'constructs' ; import { App , Chart , ChartProps , Cron } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new kplus . CronJob ( this , 'CronJob' , { containers : [{ image : 'databack/mysql-backup' , }], // You can pass a custom cron schedule using our Cron class schedule : Cron.schedule ({ minute : '*' , hour : '*' , day : '*' , month : '*' , weekDay : '*' , }), }); } } const app = new App (); new MyChart ( app , 'cronjob-readme' ); app . synth (); Defaults \u00b6 The above would create a cronjob resource which would schedule databack/mysql-backup to run every minute. With this resource, we also set some meaningful defaults. For instance, this cronjob would not run jobs concurrently by default. It will also retain 3 instance of successful job runs and 1 instance of a failed run for debugging later if needed. To customize the properties, see API Reference . Helper Functions \u00b6 As we see in the previous example, we can pass custom cron expression for scheduling our jobs. But, we have also have added helper functions that would make it easy to mention some of the commonly used schedules. These include scheduling jobs to run every minute, hour, day, week, month or year. For instance, the same example mentioned before could be written as, new kplus . CronJob ( this , 'CronJob' , { containers : [{ image : 'databack/mysql-backup' , }], // This would schedule jobs to be scheduled to run every minute schedule : Cron.everyMinute (), }); Validations \u00b6 The cronjob construct also validates some of the properties so that the manifest created works as expected. You cannot pass startingDeadline property value less that 10 seconds. This is because the Kubernetes CronJobController checks things every 10 seconds and if the value passed is less than that then the jobs would not be scheduled. ttlAfterFinished job property limits the lifetime of a job that has finished execution. You cannot pass the ttlAfterFinished property with any/both of the successfulJobsRetained and failedJobsRetained property since this would not let retention of jobs work in an expected manner.","title":"CronJob"},{"location":"plus/cronjob/#cronjob","text":"CronJob resource is responsible for creating recurring Jobs . The job recurrence is determined by a Cron expression. CronJob is similar to a job but it is suitable when there is a need to run a job indefinitely following a schedule. These repetitive jobs can be utilized for recurring tasks such as backing up a database, pinging a server for health checks, creating snapshots of systems and much more. API Reference","title":"CronJob"},{"location":"plus/cronjob/#creating-a-cronjob","text":"import * as kplus from 'cdk8s-plus-24' ; import { Construct } from 'constructs' ; import { App , Chart , ChartProps , Cron } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new kplus . CronJob ( this , 'CronJob' , { containers : [{ image : 'databack/mysql-backup' , }], // You can pass a custom cron schedule using our Cron class schedule : Cron.schedule ({ minute : '*' , hour : '*' , day : '*' , month : '*' , weekDay : '*' , }), }); } } const app = new App (); new MyChart ( app , 'cronjob-readme' ); app . synth ();","title":"Creating a CronJob"},{"location":"plus/cronjob/#defaults","text":"The above would create a cronjob resource which would schedule databack/mysql-backup to run every minute. With this resource, we also set some meaningful defaults. For instance, this cronjob would not run jobs concurrently by default. It will also retain 3 instance of successful job runs and 1 instance of a failed run for debugging later if needed. To customize the properties, see API Reference .","title":"Defaults"},{"location":"plus/cronjob/#helper-functions","text":"As we see in the previous example, we can pass custom cron expression for scheduling our jobs. But, we have also have added helper functions that would make it easy to mention some of the commonly used schedules. These include scheduling jobs to run every minute, hour, day, week, month or year. For instance, the same example mentioned before could be written as, new kplus . CronJob ( this , 'CronJob' , { containers : [{ image : 'databack/mysql-backup' , }], // This would schedule jobs to be scheduled to run every minute schedule : Cron.everyMinute (), });","title":"Helper Functions"},{"location":"plus/cronjob/#validations","text":"The cronjob construct also validates some of the properties so that the manifest created works as expected. You cannot pass startingDeadline property value less that 10 seconds. This is because the Kubernetes CronJobController checks things every 10 seconds and if the value passed is less than that then the jobs would not be scheduled. ttlAfterFinished job property limits the lifetime of a job that has finished execution. You cannot pass the ttlAfterFinished property with any/both of the successfulJobsRetained and failedJobsRetained property since this would not let retention of jobs work in an expected manner.","title":"Validations"},{"location":"plus/deployment/","text":"Deployment \u00b6 Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference Automatic pod selection \u00b6 When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE Exposing via a service \u00b6 Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP Scheduling \u00b6 In addition to the scheduling capabilities provided by pod scheduling , a Deployment offers the following: Spreading \u00b6 A spread is a separation of pods from themselves. It can be used to ensure replicas of the same workload are scheduled on different topologies. The same API is also available on all workload resources (i.e Deployment , StatefulSet , Job , DaemonSet ). import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Deployment ( chart , 'Redis' , { containers : [{ image : 'redis' }], replicas : 3 , }); deployment . scheduling . spread ( kplus . Topology . HOSTNAME ); This example ensures that each replica of the Redis deployment will be scheduled on a different node. Take, for example , a three-node cluster running a web application with an in-memory cache like redis. You\u2019d like to co-locate the web servers with the cache as much as possible, while still maintaining node failure resistance. (i.e not all pods are on the same node). Here is how you can accomplish that: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Deployment ( chart , 'Redis' , { containers : [{ image : 'redis' }], replicas : 3 , }); const web = new kplus . Deployment ( chart , 'Web' , { containers : [{ image : 'web' }], replicas : 3 , }); // ensure redis is spread across all nodes redis . scheduling . spread ( kplus . Topology . HOSTNAME ); // ensure web app is spread across all nodes web . scheduling . spread ( kplus . Topology . HOSTNAME ); // ensure a web app pod always runs along side a cache instance web . scheduling . colocate ( redis ); Connections \u00b6 See Pod connections .","title":"Deployment"},{"location":"plus/deployment/#deployment","text":"Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference","title":"Deployment"},{"location":"plus/deployment/#automatic-pod-selection","text":"When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE","title":"Automatic pod selection"},{"location":"plus/deployment/#exposing-via-a-service","text":"Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Exposing via a service"},{"location":"plus/deployment/#scheduling","text":"In addition to the scheduling capabilities provided by pod scheduling , a Deployment offers the following:","title":"Scheduling"},{"location":"plus/deployment/#spreading","text":"A spread is a separation of pods from themselves. It can be used to ensure replicas of the same workload are scheduled on different topologies. The same API is also available on all workload resources (i.e Deployment , StatefulSet , Job , DaemonSet ). import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Deployment ( chart , 'Redis' , { containers : [{ image : 'redis' }], replicas : 3 , }); deployment . scheduling . spread ( kplus . Topology . HOSTNAME ); This example ensures that each replica of the Redis deployment will be scheduled on a different node. Take, for example , a three-node cluster running a web application with an in-memory cache like redis. You\u2019d like to co-locate the web servers with the cache as much as possible, while still maintaining node failure resistance. (i.e not all pods are on the same node). Here is how you can accomplish that: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Deployment ( chart , 'Redis' , { containers : [{ image : 'redis' }], replicas : 3 , }); const web = new kplus . Deployment ( chart , 'Web' , { containers : [{ image : 'web' }], replicas : 3 , }); // ensure redis is spread across all nodes redis . scheduling . spread ( kplus . Topology . HOSTNAME ); // ensure web app is spread across all nodes web . scheduling . spread ( kplus . Topology . HOSTNAME ); // ensure a web app pod always runs along side a cache instance web . scheduling . colocate ( redis );","title":"Spreading"},{"location":"plus/deployment/#connections","text":"See Pod connections .","title":"Connections"},{"location":"plus/ingress/","text":"Ingress \u00b6 Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new Ingress ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressBackend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port }) .","title":"Ingress"},{"location":"plus/ingress/#ingress","text":"Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new Ingress ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressBackend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port }) .","title":"Ingress"},{"location":"plus/job/","text":"Job \u00b6 Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference Delete a Job after its finished \u00b6 You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' }); Scheduling \u00b6 See Deployment scheduling . Connections \u00b6 See Pod connections .","title":"Job"},{"location":"plus/job/#job","text":"Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference","title":"Job"},{"location":"plus/job/#delete-a-job-after-its-finished","text":"You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Delete a Job after its finished"},{"location":"plus/job/#scheduling","text":"See Deployment scheduling .","title":"Scheduling"},{"location":"plus/job/#connections","text":"See Pod connections .","title":"Connections"},{"location":"plus/namespace/","text":"Namespace \u00b6 Namespaces provides a mechanism for isolating groups of resources within a single cluster. API Reference Create a Namespace \u00b6 To create a new namespace in the cluster: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const namespace = new kplus . Namespace ( chart , 'BackOfficeNamespace' ); Like any other resource, if you don\u2019t specify a name, cdk8s will auto-generate one, which you can access by namespace.name . Select namespaces \u00b6 Namespaces can also be selected by various mechanisms. These selections are often used in other cdk8s+ API\u2019s, such as pod selection during scheduling. Select namespaces by name \u00b6 Select a namespace called backoffice . import * as kplus from 'cdk8s-plus-24' ; const backoffice = kplus . Namespaces . select ( this , 'Backoffice' , { names : [ 'backoffice' ] }); Select namespace by labels \u00b6 Select all namespaces that have the processing=batch label. import * as kplus from 'cdk8s-plus-24' ; const batch = kplus . Namespaces . select ( this , 'Batch' , { labels : { processing : 'batch' } }); Select all namespaces \u00b6 Select all namespaces in the cluster. import * as kplus from 'cdk8s-plus-24' ; const all = kplus . Namespaces . all ();","title":"Namespace"},{"location":"plus/namespace/#namespace","text":"Namespaces provides a mechanism for isolating groups of resources within a single cluster. API Reference","title":"Namespace"},{"location":"plus/namespace/#create-a-namespace","text":"To create a new namespace in the cluster: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const namespace = new kplus . Namespace ( chart , 'BackOfficeNamespace' ); Like any other resource, if you don\u2019t specify a name, cdk8s will auto-generate one, which you can access by namespace.name .","title":"Create a Namespace"},{"location":"plus/namespace/#select-namespaces","text":"Namespaces can also be selected by various mechanisms. These selections are often used in other cdk8s+ API\u2019s, such as pod selection during scheduling.","title":"Select namespaces"},{"location":"plus/namespace/#select-namespaces-by-name","text":"Select a namespace called backoffice . import * as kplus from 'cdk8s-plus-24' ; const backoffice = kplus . Namespaces . select ( this , 'Backoffice' , { names : [ 'backoffice' ] });","title":"Select namespaces by name"},{"location":"plus/namespace/#select-namespace-by-labels","text":"Select all namespaces that have the processing=batch label. import * as kplus from 'cdk8s-plus-24' ; const batch = kplus . Namespaces . select ( this , 'Batch' , { labels : { processing : 'batch' } });","title":"Select namespace by labels"},{"location":"plus/namespace/#select-all-namespaces","text":"Select all namespaces in the cluster. import * as kplus from 'cdk8s-plus-24' ; const all = kplus . Namespaces . all ();","title":"Select all namespaces"},{"location":"plus/network-policy/","text":"Network Policy \u00b6 Network policies control inter-pod traffic flow at the IP address or port level (OSI layer 3 or 4). By default, a pod is opened in the network (or non-isolated ). That is, it can initiate any outgoing traffic, and accept any incoming traffic. When network policies are applied to pods, they loose this default behavior and become restricted, or isolated . This means that as soon as a policy in a specific direction applies to a pod, that pods stops being open in that direction. We refer to such pods as isolated . There are two sorts of isolation for a pod: isolation for egress, and isolation for ingress. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. Create a NetworkPolicy \u00b6 A network policy is a namespaced resource that applies to specific pods in that namespace. The pods are specified using the selector property, and can accept a few different objects: Managed Pod \u00b6 A managed pod is a pod that is created by the current cdk8s application. That is, its simply an instance of a Pod . You can pass that instance to be used as the selector. The policy will be applied only to that specific pod. Under the hood, this uses a magic cdk8s.io/metadata.address label that uniquely identifies pods, and is added automatically by cdk8s. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], }); new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web }); Managed Workload \u00b6 Exactly as for a managed Pod , you can pass an instance of any workload resource (e.g Deployment , StatefulSet , \u2026) import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Deployment ( chart , 'Web' , { containers : [{ image : 'web' }], }); new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web }); Selected Pods \u00b6 If you\u2019d like to create a policy for pods that aren\u2019t managed by the current cdk8s application, you use selected pods . import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = kplus . Pods . select ( chart , 'Web' , { labels : { app : 'web' }}); new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web }); This policy will apply to all pods with label app=web . Ip Block \u00b6 An Ip Block defines a range of IP addresses using CIDR notation. You can define both ipv4 and ipv6 ranges: import * as kplus from 'cdk8s-plus-24' ; // define a specific ipv4 range kplus . NetworkPolicyIpBlock . ipv4 ( '172.17.0.0/16' ); // define a specific ipv6 range kplus . NetworkPolicyIpBlock . ipv6 ( '2002::1234:abcd:ffff:c0a8:101/64' ); // define all ipv4 addresses kplus . NetworkPolicyIpBlock . anyIpv4 (); // define all ipv6 addresses kplus . NetworkPolicyIpBlock . anyIpv6 (); Ip blocks can later be used as network policy peers . Peers \u00b6 The selector of a policy is defined at construction time and there can only be one per policy. The peers constitute the second half of the connection \u2013 they are the resources or endpoints that the selected resources can communicate with. A policy can define rules for multiple peers, and a peer can be any one of: Ip Block : Will allow a connection with a CIDR range. Managed Pod : Will establish a connection with specific pod. Managed Workload : Will establish a connection with the pods of the workload. Selected Pods : Will establish a connection with the selected pods. Managed Namespace : Will establish a connection with all pods in a specific namespace. Selected Namespaces : Will establish a connection with all pods in the selected namespaces. You can also create a custom peer by implementing the kplus.INetworkPolicyPeer interface. Egress Rule \u00b6 Isolating pods for egress traffic egress can be done either at, or post construction: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], }); const cache = new kplus . Pod ( chart , 'Cache' , { containers : [{ image : 'cache' , portNumber : 6379 }], }); const db = new kplus . Pod ( chart , 'DB' , { containers : [{ image : 'db' , portNumber : 6378 }], }); // create a policy with an egress rule at instantiation const webPolicy = new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web , egress : { rules : [{ peer : cache , ports : [ kplus . NetworkPolicyPort . tcp ( 6379 )]}] }, }); // add an egress rule post instantiation webPolicy . addEgressRule ( db , [ kplus . NetworkPolicyPort . tcp ( 6378 )]); Ingress Rule \u00b6 Isolating pods for ingress traffic ingress can be done either at, or post construction: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], }); const cache = new kplus . Pod ( chart , 'Cache' , { containers : [{ image : 'cache' , portNumber : 6379 }], }); const db = new kplus . Pod ( chart , 'DB' , { containers : [{ image : 'db' , portNumber : 6378 }], }); // create a policy with an ingress rule at instantiation const dbPolicy = new kplus . NetworkPolicy ( chart , 'Policy' , { selector : db , ingress : { rule : [{ peer : web , ports : [ kplus . NetworkPolicyPort . tcp ( 6379 )]}] }, }); // add an ingress rule post instantiation redis . addIngressRule ( cache , [ kplus . NetworkPolicyPort . tcp ( 6379 )]); Bi-directional Rule \u00b6 As mentioned earlier, for a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. Using network policies, this could be tricky, especially if the pods are in different namespace: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], metadata : { namespace : 'n1' }, }); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }], metadata : { namespace : 'n2' }, }); const webPolicy = new kplus . NetworkPolicy ( chart , 'WebPolicy' , { selector : web , // must be created in the 'web' namespace so it can select it. metadata : { namespace : web.metadata.namespace } }); const redisPolicy = new kplus . NetworkPolicy ( chart , 'RedisPolicy' , { selector : redis , // must be created in the 'redis' namespace so it can select it. metadata : { namespace : redis.metadata.namespace } }); // allow the 'web' pod to initiate a connection to the 'redis' pod on port 6379 webPolicy . addEgressRule ( redis , [ kplus . NetworkPolicyPort . tcp ( 6379 )]); // allow the 'redis' pod to accept a connection from the 'web' pod on port 6379 redis . addIngressRule ( web , [ kplus . NetworkPolicyPort . tcp ( 6379 )]); If the source pod of your connection is a managed pod (or managed workload ), the same thing can be achieved much easier: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], metadata : { namespace : 'n1' }, }); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }], metadata : { namespace : 'n2' }, }); web . connections . allowTo ( redis ); // or redis . connections . allowFrom ( web ); See pod connections for more details. Default Policies \u00b6 Every policy can specify what behavior should apply when no rules are specified in a given direction. You can use that to create default policies that either deny or allow all traffic. Deny All Ingress \u00b6 See default-deny-all-ingress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { ingress : { default : kplus.NetworkPolicyTrafficDefault.DENY }, }); This ensures that even pods that aren\u2019t selected by any other network policy will still be isolated for ingress. This policy does not affect isolation for egress from any pod. Allow All Ingress \u00b6 See allow-all-ingress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { ingress : { default : kplus.NetworkPolicyTrafficDefault.ALLOW }, }); With this policy in place, no additional policy or policies can cause any incoming connection to those pods to be denied. This policy has no effect on isolation for egress from any pod. Tip This differs from the default DENY isolation behavior, which is effectively disabled when other policies are applied. Deny All Egress \u00b6 See default-deny-all-egress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { egress : { default : kplus.NetworkPolicyTrafficDefault.DENY }, }); This ensures that even pods that aren\u2019t selected by any other NetworkPolicy will not be allowed egress traffic. This policy does not change the ingress isolation behavior of any pod. Allow All Egress \u00b6 See allow-all-egress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { egress : { default : kplus.NetworkPolicyTrafficDefault.ALLOW }, }); With this policy in place, no additional policy or policies can cause any outgoing connection from those pods to be denied. This policy has no effect on isolation for ingress to any pod. Tip This differs from the default DENY isolation behavior, which is effectively disabled when other policies are applied.","title":"Network Policy"},{"location":"plus/network-policy/#network-policy","text":"Network policies control inter-pod traffic flow at the IP address or port level (OSI layer 3 or 4). By default, a pod is opened in the network (or non-isolated ). That is, it can initiate any outgoing traffic, and accept any incoming traffic. When network policies are applied to pods, they loose this default behavior and become restricted, or isolated . This means that as soon as a policy in a specific direction applies to a pod, that pods stops being open in that direction. We refer to such pods as isolated . There are two sorts of isolation for a pod: isolation for egress, and isolation for ingress. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen.","title":"Network Policy"},{"location":"plus/network-policy/#create-a-networkpolicy","text":"A network policy is a namespaced resource that applies to specific pods in that namespace. The pods are specified using the selector property, and can accept a few different objects:","title":"Create a NetworkPolicy"},{"location":"plus/network-policy/#managed-pod","text":"A managed pod is a pod that is created by the current cdk8s application. That is, its simply an instance of a Pod . You can pass that instance to be used as the selector. The policy will be applied only to that specific pod. Under the hood, this uses a magic cdk8s.io/metadata.address label that uniquely identifies pods, and is added automatically by cdk8s. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], }); new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web });","title":"Managed Pod"},{"location":"plus/network-policy/#managed-workload","text":"Exactly as for a managed Pod , you can pass an instance of any workload resource (e.g Deployment , StatefulSet , \u2026) import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Deployment ( chart , 'Web' , { containers : [{ image : 'web' }], }); new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web });","title":"Managed Workload"},{"location":"plus/network-policy/#selected-pods","text":"If you\u2019d like to create a policy for pods that aren\u2019t managed by the current cdk8s application, you use selected pods . import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = kplus . Pods . select ( chart , 'Web' , { labels : { app : 'web' }}); new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web }); This policy will apply to all pods with label app=web .","title":"Selected Pods"},{"location":"plus/network-policy/#ip-block","text":"An Ip Block defines a range of IP addresses using CIDR notation. You can define both ipv4 and ipv6 ranges: import * as kplus from 'cdk8s-plus-24' ; // define a specific ipv4 range kplus . NetworkPolicyIpBlock . ipv4 ( '172.17.0.0/16' ); // define a specific ipv6 range kplus . NetworkPolicyIpBlock . ipv6 ( '2002::1234:abcd:ffff:c0a8:101/64' ); // define all ipv4 addresses kplus . NetworkPolicyIpBlock . anyIpv4 (); // define all ipv6 addresses kplus . NetworkPolicyIpBlock . anyIpv6 (); Ip blocks can later be used as network policy peers .","title":"Ip Block"},{"location":"plus/network-policy/#peers","text":"The selector of a policy is defined at construction time and there can only be one per policy. The peers constitute the second half of the connection \u2013 they are the resources or endpoints that the selected resources can communicate with. A policy can define rules for multiple peers, and a peer can be any one of: Ip Block : Will allow a connection with a CIDR range. Managed Pod : Will establish a connection with specific pod. Managed Workload : Will establish a connection with the pods of the workload. Selected Pods : Will establish a connection with the selected pods. Managed Namespace : Will establish a connection with all pods in a specific namespace. Selected Namespaces : Will establish a connection with all pods in the selected namespaces. You can also create a custom peer by implementing the kplus.INetworkPolicyPeer interface.","title":"Peers"},{"location":"plus/network-policy/#egress-rule","text":"Isolating pods for egress traffic egress can be done either at, or post construction: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], }); const cache = new kplus . Pod ( chart , 'Cache' , { containers : [{ image : 'cache' , portNumber : 6379 }], }); const db = new kplus . Pod ( chart , 'DB' , { containers : [{ image : 'db' , portNumber : 6378 }], }); // create a policy with an egress rule at instantiation const webPolicy = new kplus . NetworkPolicy ( chart , 'Policy' , { selector : web , egress : { rules : [{ peer : cache , ports : [ kplus . NetworkPolicyPort . tcp ( 6379 )]}] }, }); // add an egress rule post instantiation webPolicy . addEgressRule ( db , [ kplus . NetworkPolicyPort . tcp ( 6378 )]);","title":"Egress Rule"},{"location":"plus/network-policy/#ingress-rule","text":"Isolating pods for ingress traffic ingress can be done either at, or post construction: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], }); const cache = new kplus . Pod ( chart , 'Cache' , { containers : [{ image : 'cache' , portNumber : 6379 }], }); const db = new kplus . Pod ( chart , 'DB' , { containers : [{ image : 'db' , portNumber : 6378 }], }); // create a policy with an ingress rule at instantiation const dbPolicy = new kplus . NetworkPolicy ( chart , 'Policy' , { selector : db , ingress : { rule : [{ peer : web , ports : [ kplus . NetworkPolicyPort . tcp ( 6379 )]}] }, }); // add an ingress rule post instantiation redis . addIngressRule ( cache , [ kplus . NetworkPolicyPort . tcp ( 6379 )]);","title":"Ingress Rule"},{"location":"plus/network-policy/#bi-directional-rule","text":"As mentioned earlier, for a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. Using network policies, this could be tricky, especially if the pods are in different namespace: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], metadata : { namespace : 'n1' }, }); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }], metadata : { namespace : 'n2' }, }); const webPolicy = new kplus . NetworkPolicy ( chart , 'WebPolicy' , { selector : web , // must be created in the 'web' namespace so it can select it. metadata : { namespace : web.metadata.namespace } }); const redisPolicy = new kplus . NetworkPolicy ( chart , 'RedisPolicy' , { selector : redis , // must be created in the 'redis' namespace so it can select it. metadata : { namespace : redis.metadata.namespace } }); // allow the 'web' pod to initiate a connection to the 'redis' pod on port 6379 webPolicy . addEgressRule ( redis , [ kplus . NetworkPolicyPort . tcp ( 6379 )]); // allow the 'redis' pod to accept a connection from the 'web' pod on port 6379 redis . addIngressRule ( web , [ kplus . NetworkPolicyPort . tcp ( 6379 )]); If the source pod of your connection is a managed pod (or managed workload ), the same thing can be achieved much easier: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }], metadata : { namespace : 'n1' }, }); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }], metadata : { namespace : 'n2' }, }); web . connections . allowTo ( redis ); // or redis . connections . allowFrom ( web ); See pod connections for more details.","title":"Bi-directional Rule"},{"location":"plus/network-policy/#default-policies","text":"Every policy can specify what behavior should apply when no rules are specified in a given direction. You can use that to create default policies that either deny or allow all traffic.","title":"Default Policies"},{"location":"plus/network-policy/#deny-all-ingress","text":"See default-deny-all-ingress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { ingress : { default : kplus.NetworkPolicyTrafficDefault.DENY }, }); This ensures that even pods that aren\u2019t selected by any other network policy will still be isolated for ingress. This policy does not affect isolation for egress from any pod.","title":"Deny All Ingress"},{"location":"plus/network-policy/#allow-all-ingress","text":"See allow-all-ingress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { ingress : { default : kplus.NetworkPolicyTrafficDefault.ALLOW }, }); With this policy in place, no additional policy or policies can cause any incoming connection to those pods to be denied. This policy has no effect on isolation for egress from any pod. Tip This differs from the default DENY isolation behavior, which is effectively disabled when other policies are applied.","title":"Allow All Ingress"},{"location":"plus/network-policy/#deny-all-egress","text":"See default-deny-all-egress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { egress : { default : kplus.NetworkPolicyTrafficDefault.DENY }, }); This ensures that even pods that aren\u2019t selected by any other NetworkPolicy will not be allowed egress traffic. This policy does not change the ingress isolation behavior of any pod.","title":"Deny All Egress"},{"location":"plus/network-policy/#allow-all-egress","text":"See allow-all-egress-traffic import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . NetworkPolicy ( chart , 'Policy' , { egress : { default : kplus.NetworkPolicyTrafficDefault.ALLOW }, }); With this policy in place, no additional policy or policies can cause any outgoing connection from those pods to be denied. This policy has no effect on isolation for ingress to any pod. Tip This differs from the default DENY isolation behavior, which is effectively disabled when other policies are applied.","title":"Allow All Egress"},{"location":"plus/pod/","text":"Pod \u00b6 A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference Create a Pod \u00b6 To create a new pod in the cluster: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' ); Adding Containers \u00b6 Every Pod must have at least one container before you synthesize the application. You can add containers either during, or post instantiation: const pod = new kplus . Pod ( chart , 'Pod' , { containers : [{ image : 'image' }], }); pod . addContainer ({ image : 'another-image' }); Adding Volumes \u00b6 Volumes can be added to pod definition either during, or post instantiation: import * as kplus from 'cdk8s-plus-24' ; const data1 = kplus . Volume . fromEmptyDir ( 'data1' ); const data2 = kplus . Volume . fromEmptyDir ( 'data2' ); const pod = new kplus . Pod ( chart , 'Pod' , { volumes : [ data1 ], }); pod . addVolume ( data2 ); Note that adding a volume to a pod doesn\u2019t actually make the volume available to its containers. For that, you also need to mount the volume onto a container. import * as kplus from 'cdk8s-plus-24' ; const data = kplus . Volume . fromEmptyDir ( 'data' ); const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'image' }); // mount the volume onto the container. this is actually enough, and you // don't need to explicitly add the volume to the pod -- cdk8s+ will do that for you. container . mount ( '/data' , data ); Applying a restart policy \u00b6 A restart policy can only be specified at instantiation time: import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , }); Assigning a ServiceAccount \u00b6 A service account can only be specified at instantiation time: import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), }); Select pods \u00b6 Pods can also be selected by various mechanisms. These selections are often used in other cdk8s+ API\u2019s, such as pod selection during scheduling. Select pods with labels \u00b6 Selects all pods that have the app=store label. import * as kplus from 'cdk8s-plus-24' ; const pods = kplus . Pods . select ( this , 'Store' , { labels : { app : 'store' }}); Select pods with expressions \u00b6 Selects all pods that have the app label, regardless of the value. import * as kplus from 'cdk8s-plus-24' ; const pods = kplus . Pods . select ( this , 'App' , { expressions : [ kplus . LabelExpression . exists ( 'app' )] }); Select pods with labels in a particular namespace \u00b6 Pod selection can also be scoped to specific namespaces. This is done using the namespaces property, which can accept any namespace selector . For example, select all pods that have the app=store label in the backoffice namespace: import * as kplus from 'cdk8s-plus-24' ; const pods = kplus . Pods . select ( this , 'Pods' , { labels : { app : 'store' }, namespaces : kplus.Namespaces.select ( this , 'Backoffice' , { names : [ 'backoffice' ] }), }); Scheduling \u00b6 Kubernetes offers a few properties for controlling how pods are scheduled onto nodes. nodeName nodeSelector nodeAffinity podAffinity podAntiAffinity tolearations CDK8s+ collapses all these different features and exposes them under one unified API we refer to as Scheduling . This API is available on a Pod via the scheduling property. The same API is also available on all workload resources (i.e Deployment , StatefulSet , Job , DaemonSet ). Scheduling is comprised of two different types: Node Selection Pod Selection Node Selection \u00b6 Node selection is the process of directly selecting which nodes should pods be scheduled on, by selecting node attributes. Node Assignment \u00b6 You can statically assign a pod to a specific node, by using the node\u2019s name. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' }] }); redis . scheduling . assign ( kplus . Node . named ( 'node1' )); This example will cause the Redis pod to be scheduled on a node with name node1 . Node Attraction \u00b6 Pods can attract themselves to nodes. As opposed to an assignment, an attraction can be made to a set of nodes, specified by node labels. An attraction can be either required, or preferred. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' }] }); const highMemoryNodes = kplus . Node . labeled ( kplus . NodeLabelQuery . is ( 'memory' , 'high' )); redis . scheduling . attract ( highMemoryNodes ); This example will require the Redis pod be scheduled on a node that has the memory=high label. To request a preference , specify the weight property: redis . scheduling . attract ( highMemoryNodes , { weight : 50 }); Node Toleration \u00b6 While attractions is a property of Pods that attracts them to a set of nodes, taints are the opposite \u2013 they allow a node to repel a set of pods. Tolerations are applied to pods, and allow (but do not require) the pods to schedule onto nodes with matching taints. Taints and tolerations work together to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node; this marks that the node should not accept any pods that do not tolerate the taints. A toleration can be made to a set of nodes, specified by node taints. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' }] }); const node = kplus . Node . tainted ( kplus . NodeTaintQuery . is ( 'key1' , 'value1' , { effect : kplus.TainEffect.NO_SCHEDULE })); redis . scheduling . tolerate ( node ); This example says the the Redis pod is able to tolerate nodes tainted with key1=value1:NoSchedule . Pod Selection \u00b6 Pod selection is the process of selecting which nodes should pods be scheduled on, by looking at which other pods are already scheduled on those nodes. The API\u2019s presented here interact either with specific pods, i.e instances of Pod or Workload (e.g Deployment , StatefulSet , Job , \u2026), or with a group of pods, i.e ones that are identified by a set of selectors . Pod Co-location \u00b6 Pod co-location is a way to tell the scheduler to place a pod in a topology that already hosts other pods that meet some criteria. A topology is expressed via the topology property, and represents a failure domain that Kubernetes is aware of. It can be one of: kplus.Topology.HOSTNAME : A single node. This is the default value. kplus.Topology.ZONE : Multiple nodes in a single availability zone. kplus.Topology.REGION : Multiple nodes in a single region. kplus.Topology.custom : Any other configurable value. Similarly to node attractions, co-location can also be either required, or preferred. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' }] }); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }] }); web . scheduling . colocate ( redis ); This example will require the Web pod to be scheduled on the same node as the Redis pod. To request a preference , specify the weight property: web . scheduling . colocate ( redis , { weight : 50 }); To use a different topology, specify the topology property: web . scheduling . colocate ( redis , { weight : 50 , topology : kplus.Topology.ZONE }); This scenario configures co-location between two pods that are defined and managed in the same cdk8s application. You can also co-locate with an externally managed pod, by specifying a pod selector: const redis = kplus . Pods . select ( this , 'Cache' , { labels : { app : 'cache' }, }); web . scheduling . colocate ( redis ); This will co-locate the Web pod with pods that have the app=cache label, regardless of whether they are defined in the cdk8s app or not. Under the hood : Co-location with managed pods will automatically extract its labels and form the appropriate pod selector. Pod Separation \u00b6 Pod separation (e.g anti co-location) is a way to tell the scheduler not to place a pod in a topology that already hosts other pods that meet some criteria. Similarly to co-location, separation can also be either required, or preferred. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' }] }); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }] }); web . scheduling . separate ( redis ); This example will require the Web pod to not be scheduled on the same node (because the default value of the topology is HOSTNAME ) as the Redis pod. To request a preference , specify the weight property: web . scheduling . separate ( redis , { weight : 50 }); To use a different topology, specify the topology property: web . scheduling . separate ( redis , { weight : 50 , topology : kplus.Topology.ZONE }); This scenario configures separation between two pods that are defined and managed in the same cdk8s application. You can also separate with an externally managed pod, by specifying a pod selector: const redis = kplus . Pods . select ( this , 'Cache' , { labels : { app : 'cache' }, }); web . scheduling . separate ( redis ); This will separate the Web pod from pods that have the app=cache label, regardless of whether they are defined in the cdk8s app or not. Under the hood : Co-location with managed pods will automatically extract its labels and form the appropriate pod selector. Connections \u00b6 Pod connections offer a simplified API to automatically create network policies on both ends of a connection. Accessing this API is done via the connections property of a specific Pod , which serves as one end of the connection. The other end is a network policy peer . Allow To \u00b6 To allow connections from a Pod to a peer : import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }] }); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }] }); web . connections . allowTo ( redis ); This will allow the web pod to connect to the redis port on port 6379, and will allow the redis pod to accept connections from the web pod on port 6379. Note that the port is not specified in the allowTo invocation, it is automatically extracted from the redis pod definition. You can also pass ports explicitly, overriding this extraction: web . connections . allowTo ( redis , { ports : [ kplus . NetworkPolicyPort . tcp ( 4444 )] }); Allow From \u00b6 To allow connections from a peer to a Pod : import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }] }); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }] }); redis . connections . allowFrom ( web ); This will allow the redis pod to accept connection from the web pod on port 6379, and will allow the web pod to connect to the redis pod on port 6379. Note that the port is not specified in the allowFrom invocation, it is automatically extracted from the redis pod definition. Isolation \u00b6 By default, the allowXXX methods will create both an egress policy on the initiating end, as well as an ingress policy on the accepting end of the connection. This means that, if no other policies apply, both sides of the connection will be isolated , each in the corresponding direction. In the above example , if the redis pod needs to be accessed from any pod other than web , an explicit policy needs to be applied, because the default non-isolated behavior is now disabled. To control the isolation this API incurs, you can use the isolation option. It accepts two possible values: PodConnectionsIsolation.POD : Only isolate the pod that offers the connections API. PodConnectionsIsolation.PEER : Only isolate the peer the pod needs to communicate with. // this will only create an egress policy on the 'web' pod. web . connections . allowTo ( redis , { isolation : PodConnectionsIsolation.POD }); // this will only create an ingress policy on the 'redis' pod. web . connections . allowTo ( redis , { isolation : PodConnectionsIsolation.PEER });","title":"Pod"},{"location":"plus/pod/#pod","text":"A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference","title":"Pod"},{"location":"plus/pod/#create-a-pod","text":"To create a new pod in the cluster: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' );","title":"Create a Pod"},{"location":"plus/pod/#adding-containers","text":"Every Pod must have at least one container before you synthesize the application. You can add containers either during, or post instantiation: const pod = new kplus . Pod ( chart , 'Pod' , { containers : [{ image : 'image' }], }); pod . addContainer ({ image : 'another-image' });","title":"Adding Containers"},{"location":"plus/pod/#adding-volumes","text":"Volumes can be added to pod definition either during, or post instantiation: import * as kplus from 'cdk8s-plus-24' ; const data1 = kplus . Volume . fromEmptyDir ( 'data1' ); const data2 = kplus . Volume . fromEmptyDir ( 'data2' ); const pod = new kplus . Pod ( chart , 'Pod' , { volumes : [ data1 ], }); pod . addVolume ( data2 ); Note that adding a volume to a pod doesn\u2019t actually make the volume available to its containers. For that, you also need to mount the volume onto a container. import * as kplus from 'cdk8s-plus-24' ; const data = kplus . Volume . fromEmptyDir ( 'data' ); const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'image' }); // mount the volume onto the container. this is actually enough, and you // don't need to explicitly add the volume to the pod -- cdk8s+ will do that for you. container . mount ( '/data' , data );","title":"Adding Volumes"},{"location":"plus/pod/#applying-a-restart-policy","text":"A restart policy can only be specified at instantiation time: import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , });","title":"Applying a restart policy"},{"location":"plus/pod/#assigning-a-serviceaccount","text":"A service account can only be specified at instantiation time: import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Assigning a ServiceAccount"},{"location":"plus/pod/#select-pods","text":"Pods can also be selected by various mechanisms. These selections are often used in other cdk8s+ API\u2019s, such as pod selection during scheduling.","title":"Select pods"},{"location":"plus/pod/#select-pods-with-labels","text":"Selects all pods that have the app=store label. import * as kplus from 'cdk8s-plus-24' ; const pods = kplus . Pods . select ( this , 'Store' , { labels : { app : 'store' }});","title":"Select pods with labels"},{"location":"plus/pod/#select-pods-with-expressions","text":"Selects all pods that have the app label, regardless of the value. import * as kplus from 'cdk8s-plus-24' ; const pods = kplus . Pods . select ( this , 'App' , { expressions : [ kplus . LabelExpression . exists ( 'app' )] });","title":"Select pods with expressions"},{"location":"plus/pod/#select-pods-with-labels-in-a-particular-namespace","text":"Pod selection can also be scoped to specific namespaces. This is done using the namespaces property, which can accept any namespace selector . For example, select all pods that have the app=store label in the backoffice namespace: import * as kplus from 'cdk8s-plus-24' ; const pods = kplus . Pods . select ( this , 'Pods' , { labels : { app : 'store' }, namespaces : kplus.Namespaces.select ( this , 'Backoffice' , { names : [ 'backoffice' ] }), });","title":"Select pods with labels in a particular namespace"},{"location":"plus/pod/#scheduling","text":"Kubernetes offers a few properties for controlling how pods are scheduled onto nodes. nodeName nodeSelector nodeAffinity podAffinity podAntiAffinity tolearations CDK8s+ collapses all these different features and exposes them under one unified API we refer to as Scheduling . This API is available on a Pod via the scheduling property. The same API is also available on all workload resources (i.e Deployment , StatefulSet , Job , DaemonSet ). Scheduling is comprised of two different types: Node Selection Pod Selection","title":"Scheduling"},{"location":"plus/pod/#node-selection","text":"Node selection is the process of directly selecting which nodes should pods be scheduled on, by selecting node attributes.","title":"Node Selection"},{"location":"plus/pod/#pod-selection","text":"Pod selection is the process of selecting which nodes should pods be scheduled on, by looking at which other pods are already scheduled on those nodes. The API\u2019s presented here interact either with specific pods, i.e instances of Pod or Workload (e.g Deployment , StatefulSet , Job , \u2026), or with a group of pods, i.e ones that are identified by a set of selectors .","title":"Pod Selection"},{"location":"plus/pod/#connections","text":"Pod connections offer a simplified API to automatically create network policies on both ends of a connection. Accessing this API is done via the connections property of a specific Pod , which serves as one end of the connection. The other end is a network policy peer .","title":"Connections"},{"location":"plus/pod/#allow-to","text":"To allow connections from a Pod to a peer : import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }] }); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }] }); web . connections . allowTo ( redis ); This will allow the web pod to connect to the redis port on port 6379, and will allow the redis pod to accept connections from the web pod on port 6379. Note that the port is not specified in the allowTo invocation, it is automatically extracted from the redis pod definition. You can also pass ports explicitly, overriding this extraction: web . connections . allowTo ( redis , { ports : [ kplus . NetworkPolicyPort . tcp ( 4444 )] });","title":"Allow To"},{"location":"plus/pod/#allow-from","text":"To allow connections from a peer to a Pod : import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const redis = new kplus . Pod ( chart , 'Redis' , { containers : [{ image : 'redis' , portNumber : 6379 }] }); const web = new kplus . Pod ( chart , 'Web' , { containers : [{ image : 'web' }] }); redis . connections . allowFrom ( web ); This will allow the redis pod to accept connection from the web pod on port 6379, and will allow the web pod to connect to the redis pod on port 6379. Note that the port is not specified in the allowFrom invocation, it is automatically extracted from the redis pod definition.","title":"Allow From"},{"location":"plus/pod/#isolation","text":"By default, the allowXXX methods will create both an egress policy on the initiating end, as well as an ingress policy on the accepting end of the connection. This means that, if no other policies apply, both sides of the connection will be isolated , each in the corresponding direction. In the above example , if the redis pod needs to be accessed from any pod other than web , an explicit policy needs to be applied, because the default non-isolated behavior is now disabled. To control the isolation this API incurs, you can use the isolation option. It accepts two possible values: PodConnectionsIsolation.POD : Only isolate the pod that offers the connections API. PodConnectionsIsolation.PEER : Only isolate the peer the pod needs to communicate with. // this will only create an egress policy on the 'web' pod. web . connections . allowTo ( redis , { isolation : PodConnectionsIsolation.POD }); // this will only create an ingress policy on the 'redis' pod. web . connections . allowTo ( redis , { isolation : PodConnectionsIsolation.PEER });","title":"Isolation"},{"location":"plus/pv/","text":"PersistentVolume \u00b6 A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. API Reference PV\u2019s are used by pods via the pod\u2019s volumes spec, just like regular volumes . They are not intended to be interchangable with volumes, you can think of a PersistentVolume as a specific type of volume, that is detached from a pod\u2019s lifecycle, and exist even if the pod is shutdown. The PersistentVolume construct represents a pre-existing volume in the cluster. Types \u00b6 Each type is implmented as its own construct, exposing both common properties as well as type specific ones. Currently the supported types are: AwsElasticBlockStorePersistentVolume AzureDiskPersistentVolume GCEPersistentDiskPersistentVolume For example, to create a PV from an existing AWS EBS volume: import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { // must exist in aws volumeId : 'vol1234' , // assign the volume to small-ebs storage class storageClassName : 'small-ebs' , // what is the volume storage storage : cdk8s.Size.gibibytes ( 50 ), }); Note that this does not actually create a new volume, it merely manifests an existing volume in AWS as a Kubernetes resource. Reserve \u00b6 See https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume Once the PV is defined, you can reserve it: const claim = vol . reserve (); This method creates a new PersistentVolumeClaim and performs a bi-directional binding that reserves the volume for usage. You can use the claim to mount a volume onto a container like usual: container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim )); You can also directly mount a persistent volume, which will implicitly reserve it and create a volume from the created claim: const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { volumeId : 'vol1234' }); container . mount ( '/data' , vol ); Bind \u00b6 Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PV to an existing PVC. Note however that if the PVC is not bound to the PV, there\u2019s no guarantee this volume will indeed be given that specific claim. const claim = kplus . PersistentVolumeClaim . fromClaimName ( 'claim' ); // will modify the vol resource to refer to the claim. // but no the other way around. vol . bind ( claim );","title":"PersistentVolume"},{"location":"plus/pv/#persistentvolume","text":"A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. API Reference PV\u2019s are used by pods via the pod\u2019s volumes spec, just like regular volumes . They are not intended to be interchangable with volumes, you can think of a PersistentVolume as a specific type of volume, that is detached from a pod\u2019s lifecycle, and exist even if the pod is shutdown. The PersistentVolume construct represents a pre-existing volume in the cluster.","title":"PersistentVolume"},{"location":"plus/pv/#types","text":"Each type is implmented as its own construct, exposing both common properties as well as type specific ones. Currently the supported types are: AwsElasticBlockStorePersistentVolume AzureDiskPersistentVolume GCEPersistentDiskPersistentVolume For example, to create a PV from an existing AWS EBS volume: import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { // must exist in aws volumeId : 'vol1234' , // assign the volume to small-ebs storage class storageClassName : 'small-ebs' , // what is the volume storage storage : cdk8s.Size.gibibytes ( 50 ), }); Note that this does not actually create a new volume, it merely manifests an existing volume in AWS as a Kubernetes resource.","title":"Types"},{"location":"plus/pv/#reserve","text":"See https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume Once the PV is defined, you can reserve it: const claim = vol . reserve (); This method creates a new PersistentVolumeClaim and performs a bi-directional binding that reserves the volume for usage. You can use the claim to mount a volume onto a container like usual: container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim )); You can also directly mount a persistent volume, which will implicitly reserve it and create a volume from the created claim: const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { volumeId : 'vol1234' }); container . mount ( '/data' , vol );","title":"Reserve"},{"location":"plus/pv/#bind","text":"Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PV to an existing PVC. Note however that if the PVC is not bound to the PV, there\u2019s no guarantee this volume will indeed be given that specific claim. const claim = kplus . PersistentVolumeClaim . fromClaimName ( 'claim' ); // will modify the vol resource to refer to the claim. // but no the other way around. vol . bind ( claim );","title":"Bind"},{"location":"plus/pvc/","text":"PersistentVolumeClaim \u00b6 A PersistentVolumeClaim (PVC) is a request for storage by a pod. API Reference A PersistentVolumeClaim contains the requirements of the request, and the Kubernetes control plane is responsible providing a physical volume that satisfies the claim\u2019s requirements. import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' }); // create the storage request const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); // mount a volume based on the request to the container // this will also add the volume itself to the pod spec. container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim )); Storage Class \u00b6 By default, the storageClassName property of a claim is not set. This means that the backing volume can be provided by one of two methods: Dynamically provision a volume with the default storage class. If a default storage class is not configured in the cluster, the backing volume must pre-exist and not be assigned to any storage class. See Provisioning for more details. You can also provide an explicit storage class name, const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), storageClassName : 'large-ebs' , }); In this case, Kubernetes control plane will either locate an existing volume with the larg-ebs storage class, or dynamically provision a new using the appropriate provisioner. You can also pass in a special \"\" value, this means the volume must not be assigned to any storage class. Since all dynamically provisioend volumes belong to a storage class, setting this value effectively disables dynamic provisioning for this claim. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), // disable dynamic provisioning storageClassName : \"\" , }); Bind \u00b6 Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PVC to an existing PV. Note however that if the PV is not bound to the PVC, there\u2019s no guarantee this claim will indeed be given to that specific volume. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); const vol = kplus . PersistentVolume . fromPersistentVolumeName ( 'vol' ); // will modify the claim resource to refer to the volume. // but no the other way around. claim . bind ( vol );","title":"PersistentVolumeClaim"},{"location":"plus/pvc/#persistentvolumeclaim","text":"A PersistentVolumeClaim (PVC) is a request for storage by a pod. API Reference A PersistentVolumeClaim contains the requirements of the request, and the Kubernetes control plane is responsible providing a physical volume that satisfies the claim\u2019s requirements. import * as kplus from 'cdk8s-plus-24' ; import * as cdk8s from 'cdk8s' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' }); // create the storage request const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); // mount a volume based on the request to the container // this will also add the volume itself to the pod spec. container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim ));","title":"PersistentVolumeClaim"},{"location":"plus/pvc/#storage-class","text":"By default, the storageClassName property of a claim is not set. This means that the backing volume can be provided by one of two methods: Dynamically provision a volume with the default storage class. If a default storage class is not configured in the cluster, the backing volume must pre-exist and not be assigned to any storage class. See Provisioning for more details. You can also provide an explicit storage class name, const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), storageClassName : 'large-ebs' , }); In this case, Kubernetes control plane will either locate an existing volume with the larg-ebs storage class, or dynamically provision a new using the appropriate provisioner. You can also pass in a special \"\" value, this means the volume must not be assigned to any storage class. Since all dynamically provisioend volumes belong to a storage class, setting this value effectively disables dynamic provisioning for this claim. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), // disable dynamic provisioning storageClassName : \"\" , });","title":"Storage Class"},{"location":"plus/pvc/#bind","text":"Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PVC to an existing PV. Note however that if the PV is not bound to the PVC, there\u2019s no guarantee this claim will indeed be given to that specific volume. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); const vol = kplus . PersistentVolume . fromPersistentVolumeName ( 'vol' ); // will modify the claim resource to refer to the volume. // but no the other way around. claim . bind ( vol );","title":"Bind"},{"location":"plus/secret/","text":"Secret \u00b6 Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference Use an existing Secret \u00b6 To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-24' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' ); Adding data \u00b6 To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Secret"},{"location":"plus/secret/#secret","text":"Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference","title":"Secret"},{"location":"plus/secret/#use-an-existing-secret","text":"To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-24' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' );","title":"Use an existing Secret"},{"location":"plus/secret/#adding-data","text":"To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Adding data"},{"location":"plus/service-account/","text":"ServiceAccount \u00b6 Use service accounts to provide an identity for pods. API Reference Use an existing ServiceAccount \u00b6 To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-24' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' ); Allowing access to secrets \u00b6 To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"ServiceAccount"},{"location":"plus/service-account/#serviceaccount","text":"Use service accounts to provide an identity for pods. API Reference","title":"ServiceAccount"},{"location":"plus/service-account/#use-an-existing-serviceaccount","text":"To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-24' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' );","title":"Use an existing ServiceAccount"},{"location":"plus/service-account/#allowing-access-to-secrets","text":"To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-24' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"Allowing access to secrets"},{"location":"plus/service/","text":"Service \u00b6 Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference Selectors \u00b6 Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' ) Ports \u00b6 Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Service"},{"location":"plus/service/#service","text":"Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference","title":"Service"},{"location":"plus/service/#selectors","text":"Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' )","title":"Selectors"},{"location":"plus/service/#ports","text":"Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-24' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Ports"},{"location":"plus/volume/","text":"Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference Create from a ConfigMap \u00b6 A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-24' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap ); Create from an EmptyDir \u00b6 The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-24' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Volume"},{"location":"plus/volume/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference","title":"Volume"},{"location":"plus/volume/#create-from-a-configmap","text":"A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-24' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap );","title":"Create from a ConfigMap"},{"location":"plus/volume/#create-from-an-emptydir","text":"The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-24' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Create from an EmptyDir"},{"location":"reference/","text":"API reference \u00b6 This section includes API reference for the various components of cdk8s. TypeScript Python Java Go cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 Info The documentation here relates to version 2.x of the cdk8s tool-chain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide","title":"API reference"},{"location":"reference/#api-reference","text":"This section includes API reference for the various components of cdk8s. TypeScript Python Java Go cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 cdk8s cdk8s-plus-22 \u00b7 Kubernetes v1.22.0 cdk8s-plus-23 \u00b7 Kubernetes v1.23.0 cdk8s-plus-24 \u00b7 Kubernetes v1.24.0 Info The documentation here relates to version 2.x of the cdk8s tool-chain, which is the latest. If you are still using version 1.x , please refer to the Migrating from 1.x Guide","title":"API reference"},{"location":"reference/cdk8s/go/","text":"cdk8s (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 .","title":"Go"},{"location":"reference/cdk8s/go/#cdk8s-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 .","title":"cdk8s (Go) "},{"location":"reference/cdk8s/java/","text":"cdk8s (Java) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import org.cdk8s.ApiObject ; ApiObject . Builder . create ( Construct scope , java . lang . String id ) . apiVersion ( java . lang . String ) . kind ( java . lang . String ) // .metadata(ApiObjectMetadata) . build (); scope Required \u00b6 Type: software.constructs.Construct the construct scope. id Required \u00b6 Type: java.lang.String namespace. apiVersion Required \u00b6 Type: java.lang.String API version. kind Required \u00b6 Type: java.lang.String Resource kind. metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 addDependency \u00b6 public addDependency ( IConstruct dependencies ) dependencies Required \u00b6 Type: software.constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( JsonPatch ops ) ops Required \u00b6 Type: org.cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import org.cdk8s.ApiObject ; ApiObject . of ( IConstruct c ) c Required \u00b6 Type: software.constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 public Chart getChart (); Type: org.cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind. metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import org.cdk8s.App ; App . Builder . create () // .outdir(java.lang.String) // .outputFileExtension(java.lang.String) // .recordConstructMetadata(java.lang.Boolean) // .yamlOutputType(YamlOutputType) . build (); outdir Optional \u00b6 Type: java.lang.String Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. outputFileExtension Optional \u00b6 Type: java.lang.String Default: .k8s.yaml The file extension to use for rendered YAML files. recordConstructMetadata Optional \u00b6 Type: java.lang.Boolean Default: false When set to true, the output directory will contain a construct-metadata.json file that holds construct related metadata on every resource in the app. yamlOutputType Optional \u00b6 Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 public synth () synthYaml \u00b6 public synthYaml () Properties \u00b6 charts Required \u00b6 public java . util . List < Chart > getCharts (); Type: java.util.List< org.cdk8s.Chart > Returns all the charts in this app, sorted topologically. outdir Required \u00b6 public java . lang . String getOutdir (); Type: java.lang.String The output directory into which manifests will be synthesized. outputFileExtension Required \u00b6 public java . lang . String getOutputFileExtension (); Type: java.lang.String Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Required \u00b6 public YamlOutputType getYamlOutputType (); Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import org.cdk8s.Chart ; Chart . Builder . create ( Construct scope , java . lang . String id ) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespace(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String labels Optional \u00b6 Type: java.util.Map java.lang.String > Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: java.lang.String Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 addDependency \u00b6 public addDependency ( IConstruct dependencies ) dependencies Required \u00b6 Type: software.constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( ApiObject apiObject ) apiObject Required \u00b6 Type: org.cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 isChart \u00b6 import org.cdk8s.Chart ; Chart . isChart ( java . lang . Object x ) x Required \u00b6 Type: java.lang.Object of \u00b6 import org.cdk8s.Chart ; Chart . of ( IConstruct c ) c Required \u00b6 Type: software.constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import org.cdk8s.Helm ; Helm . Builder . create ( Construct scope , java . lang . String id ) . chart ( java . lang . String ) // .helmExecutable(java.lang.String) // .helmFlags(java.util.List<java.lang.String>) // .releaseName(java.lang.String) // .values(java.util.Map<java.lang.String, java.lang.Object>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String chart Required \u00b6 Type: java.lang.String The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 Type: java.lang.String Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 Type: java.lang.String Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: java.util.Map java.lang.Object > Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 releaseName Required \u00b6 public java . lang . String getReleaseName (); Type: java.lang.String The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import org.cdk8s.Include ; Include . Builder . create ( Construct scope , java . lang . String id ) . url ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String url Required \u00b6 Type: java.lang.String Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 apiObjects Required \u00b6 public java . util . List < ApiObject > getApiObjects (); Type: java.util.List< org.cdk8s.ApiObject > Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import org.cdk8s.ApiObjectMetadata ; ApiObjectMetadata . builder () // .annotations(java.util.Map<java.lang.String, java.lang.String>) // .finalizers(java.util.List<java.lang.String>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .name(java.lang.String) // .namespace(java.lang.String) // .ownerReferences(java.util.List<OwnerReference>) . build (); annotations Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAnnotations (); Type: java.util.Map java.lang.String > Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 public java . util . List < java . lang . String > getFinalizers (); Type: java.util.List< java.lang.String > Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 public java . util . List < OwnerReference > getOwnerReferences (); Type: java.util.List< org.cdk8s.OwnerReference > Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import org.cdk8s.ApiObjectProps ; ApiObjectProps . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) // .metadata(ApiObjectMetadata) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String API version. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Resource kind. metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import org.cdk8s.AppProps ; AppProps . builder () // .outdir(java.lang.String) // .outputFileExtension(java.lang.String) // .recordConstructMetadata(java.lang.Boolean) // .yamlOutputType(YamlOutputType) . build (); outdir Optional \u00b6 public java . lang . String getOutdir (); Type: java.lang.String Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. outputFileExtension Optional \u00b6 public java . lang . String getOutputFileExtension (); Type: java.lang.String Default: .k8s.yaml The file extension to use for rendered YAML files. recordConstructMetadata Optional \u00b6 public java . lang . Boolean getRecordConstructMetadata (); Type: java.lang.Boolean Default: false When set to true, the output directory will contain a construct-metadata.json file that holds construct related metadata on every resource in the app. yamlOutputType Optional \u00b6 public YamlOutputType getYamlOutputType (); Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import org.cdk8s.ChartProps ; ChartProps . builder () // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespace(java.lang.String) . build (); labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. CronOptions \u00b6 Options to configure a cron expression. All fields are strings so you can use complex expressions. Absence of a field implies \u2018*\u2019 Initializer \u00b6 import org.cdk8s.CronOptions ; CronOptions . builder () // .day(java.lang.String) // .hour(java.lang.String) // .minute(java.lang.String) // .month(java.lang.String) // .weekDay(java.lang.String) . build (); day Optional \u00b6 public java . lang . String getDay (); Type: java.lang.String Default: Every day of the month The day of the month to run this rule at. hour Optional \u00b6 public java . lang . String getHour (); Type: java.lang.String Default: Every hour The hour to run this rule at. minute Optional \u00b6 public java . lang . String getMinute (); Type: java.lang.String Default: Every minute The minute to run this rule at. month Optional \u00b6 public java . lang . String getMonth (); Type: java.lang.String Default: Every month The month to run this rule at. weekDay Optional \u00b6 public java . lang . String getWeekDay (); Type: java.lang.String Default: Any day of the week The day of the week to run this rule at. GroupVersionKind \u00b6 Initializer \u00b6 import org.cdk8s.GroupVersionKind ; GroupVersionKind . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import org.cdk8s.HelmProps ; HelmProps . builder () . chart ( java . lang . String ) // .helmExecutable(java.lang.String) // .helmFlags(java.util.List<java.lang.String>) // .releaseName(java.lang.String) // .values(java.util.Map<java.lang.String, java.lang.Object>) . build (); chart Required \u00b6 public java . lang . String getChart (); Type: java.lang.String The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 public java . lang . String getHelmExecutable (); Type: java.lang.String Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 public java . util . List < java . lang . String > getHelmFlags (); Type: java.util.List< java.lang.String > Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 public java . lang . String getReleaseName (); Type: java.lang.String Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getValues (); Type: java.util.Map java.lang.Object > Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import org.cdk8s.IncludeProps ; IncludeProps . builder () . url ( java . lang . String ) . build (); url Required \u00b6 public java . lang . String getUrl (); Type: java.lang.String Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import org.cdk8s.NameOptions ; NameOptions . builder () // .delimiter(java.lang.String) // .extra(java.util.List<java.lang.String>) // .includeHash(java.lang.Boolean) // .maxLen(java.lang.Number) . build (); delimiter Optional \u00b6 public java . lang . String getDelimiter (); Type: java.lang.String Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 public java . util . List < java . lang . String > getExtra (); Type: java.util.List< java.lang.String > Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 public java . lang . Boolean getIncludeHash (); Type: java.lang.Boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 public java . lang . Number getMaxLen (); Type: java.lang.Number Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import org.cdk8s.OwnerReference ; OwnerReference . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) . name ( java . lang . String ) . uid ( java . lang . String ) // .blockOwnerDeletion(java.lang.Boolean) // .controller(java.lang.Boolean) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String API version of the referent. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 public java . lang . String getUid (); Type: java.lang.String UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids blockOwnerDeletion Optional \u00b6 public java . lang . Boolean getBlockOwnerDeletion (); Type: java.lang.Boolean Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 public java . lang . Boolean getController (); Type: java.lang.Boolean If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import org.cdk8s.SizeConversionOptions ; SizeConversionOptions . builder () // .rounding(SizeRoundingBehavior) . build (); rounding Optional \u00b6 public SizeRoundingBehavior getRounding (); Type: org.cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import org.cdk8s.TimeConversionOptions ; TimeConversionOptions . builder () // .integral(java.lang.Boolean) . build (); integral Optional \u00b6 public java . lang . Boolean getIntegral (); Type: java.lang.Boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import org.cdk8s.ApiObjectMetadataDefinition ; ApiObjectMetadataDefinition . Builder . create () // .annotations(java.util.Map<java.lang.String, java.lang.String>) // .finalizers(java.util.List<java.lang.String>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .name(java.lang.String) // .namespace(java.lang.String) // .ownerReferences(java.util.List<OwnerReference>) . build (); annotations Optional \u00b6 Type: java.util.Map java.lang.String > Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 Type: java.util.List< java.lang.String > Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 Type: java.util.Map java.lang.String > Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: java.lang.String Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: java.lang.String Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 Type: java.util.List< org.cdk8s.OwnerReference > Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ Methods \u00b6 add \u00b6 public add ( java . lang . String key , java . lang . Object value ) key Required \u00b6 Type: java.lang.String Metadata key. value Required \u00b6 Type: java.lang.Object Metadata value. addAnnotation \u00b6 public addAnnotation ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addFinalizers \u00b6 public addFinalizers ( java . lang . String finalizers ) finalizers Required \u00b6 Type: java.lang.String the finalizers. addLabel \u00b6 public addLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addOwnerReference \u00b6 public addOwnerReference ( OwnerReference owner ) owner Required \u00b6 Type: org.cdk8s.OwnerReference the owner. getLabel \u00b6 public getLabel ( java . lang . String key ) key Required \u00b6 Type: java.lang.String the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String The object\u2019s namespace. Cron \u00b6 Represents a cron schedule. Initializers \u00b6 import org.cdk8s.Cron ; Cron . Builder . create () // .day(java.lang.String) // .hour(java.lang.String) // .minute(java.lang.String) // .month(java.lang.String) // .weekDay(java.lang.String) . build (); day Optional \u00b6 Type: java.lang.String Default: Every day of the month The day of the month to run this rule at. hour Optional \u00b6 Type: java.lang.String Default: Every hour The hour to run this rule at. minute Optional \u00b6 Type: java.lang.String Default: Every minute The minute to run this rule at. month Optional \u00b6 Type: java.lang.String Default: Every month The month to run this rule at. weekDay Optional \u00b6 Type: java.lang.String Default: Any day of the week The day of the week to run this rule at. Static Functions \u00b6 annually \u00b6 import org.cdk8s.Cron ; Cron . annually () daily \u00b6 import org.cdk8s.Cron ; Cron . daily () everyMinute \u00b6 import org.cdk8s.Cron ; Cron . everyMinute () hourly \u00b6 import org.cdk8s.Cron ; Cron . hourly () monthly \u00b6 import org.cdk8s.Cron ; Cron . monthly () schedule \u00b6 import org.cdk8s.Cron ; Cron . schedule ( CronOptions options ) options Required \u00b6 Type: org.cdk8s.CronOptions weekly \u00b6 import org.cdk8s.Cron ; Cron . weekly () Properties \u00b6 expressionString Required \u00b6 public java . lang . String getExpressionString (); Type: java.lang.String Retrieve the expression for this schedule. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import org.cdk8s.DependencyGraph ; new DependencyGraph ( Node node ); node Required \u00b6 Type: software.constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 public DependencyVertex getRoot (); Type: org.cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import org.cdk8s.DependencyVertex ; new DependencyVertex (); new DependencyVertex ( IConstruct value ); value Optional \u00b6 Type: software.constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( DependencyVertex dep ) dep Required \u00b6 Type: org.cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 public java . util . List < DependencyVertex > getInbound (); Type: java.util.List< org.cdk8s.DependencyVertex > Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 public java . util . List < DependencyVertex > getOutbound (); Type: java.util.List< org.cdk8s.DependencyVertex > Returns the children of the vertex (i.e dependencies). value Optional \u00b6 public IConstruct getValue (); Type: software.constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays () public toDays ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toHours \u00b6 public toHours () public toHours ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds () public toMilliseconds ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes () public toMinutes ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds () public toSeconds ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions unitLabel \u00b6 public unitLabel () Static Functions \u00b6 days \u00b6 import org.cdk8s.Duration ; Duration . days ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Days the Duration will represent. hours \u00b6 import org.cdk8s.Duration ; Duration . hours ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Hours the Duration will represent. millis \u00b6 import org.cdk8s.Duration ; Duration . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Milliseconds the Duration will represent. minutes \u00b6 import org.cdk8s.Duration ; Duration . minutes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Minutes the Duration will represent. parse \u00b6 import org.cdk8s.Duration ; Duration . parse ( java . lang . String duration ) duration Required \u00b6 Type: java.lang.String an ISO-formtted duration to be parsed. seconds \u00b6 import org.cdk8s.Duration ; Duration . seconds ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . add ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object apply \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . apply ( java . lang . Object document , JsonPatch ops ) document Required \u00b6 Type: java.lang.Object The document to patch. ops Required \u00b6 Type: org.cdk8s.JsonPatch The operations to apply. copy \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . copy ( java . lang . String from , java . lang . String path ) from Required \u00b6 Type: java.lang.String path Required \u00b6 Type: java.lang.String move \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . move ( java . lang . String from , java . lang . String path ) from Required \u00b6 Type: java.lang.String path Required \u00b6 Type: java.lang.String remove \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . remove ( java . lang . String path ) path Required \u00b6 Type: java.lang.String replace \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . replace ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object test \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . test ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import org.cdk8s.Lazy ; Lazy . any ( IAnyProducer producer ) producer Required \u00b6 Type: org.cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import org.cdk8s.Names ; Names . toDnsLabel ( Construct scope ) Names . toDnsLabel ( Construct scope , NameOptions options ) scope Required \u00b6 Type: software.constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: org.cdk8s.NameOptions Name options. toLabelValue \u00b6 import org.cdk8s.Names ; Names . toLabelValue ( Construct scope ) Names . toLabelValue ( Construct scope , NameOptions options ) scope Required \u00b6 Type: software.constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: org.cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes () public toGibibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes () public toKibibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes () public toMebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes () public toPebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes () public toTebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import org.cdk8s.Size ; Size . gibibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number kibibytes \u00b6 import org.cdk8s.Size ; Size . kibibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number mebibytes \u00b6 import org.cdk8s.Size ; Size . mebibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number pebibyte \u00b6 import org.cdk8s.Size ; Size . pebibyte ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number tebibytes \u00b6 import org.cdk8s.Size ; Size . tebibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import org.cdk8s.Testing ; Testing . app () Testing . app ( AppProps props ) props Optional \u00b6 Type: org.cdk8s.AppProps chart \u00b6 import org.cdk8s.Testing ; Testing . chart () synth \u00b6 import org.cdk8s.Testing ; Testing . synth ( Chart chart ) chart Required \u00b6 Type: org.cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ formatObjects ~~ \u00b6 import org.cdk8s.Yaml ; Yaml . formatObjects ( java . util . List < java . lang . Object > docs ) docs Required \u00b6 Type: java.util.List< java.lang.Object > load \u00b6 import org.cdk8s.Yaml ; Yaml . load ( java . lang . String urlOrFile ) urlOrFile Required \u00b6 Type: java.lang.String a URL of a file path to load from. save \u00b6 import org.cdk8s.Yaml ; Yaml . save ( java . lang . String filePath , java . util . List < java . lang . Object > docs ) filePath Required \u00b6 Type: java.lang.String The output path. docs Required \u00b6 Type: java.util.List< java.lang.Object > The set of objects. stringify \u00b6 import org.cdk8s.Yaml ; Yaml . stringify ( java . lang . Object docs ) docs Required \u00b6 Type: java.lang.Object A set of objects to convert to YAML. tmp \u00b6 import org.cdk8s.Yaml ; Yaml . tmp ( java . util . List < java . lang . Object > docs ) docs Required \u00b6 Type: java.util.List< java.lang.Object > the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: org.cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file. FOLDER_PER_CHART_FILE_PER_RESOURCE \u00b6 Each chart in its own folder and each resource in its own file.","title":"Java"},{"location":"reference/cdk8s/java/#cdk8s-java","text":"","title":"cdk8s (Java) "},{"location":"reference/cdk8s/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/java/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/java/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/java/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/java/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/java/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/java/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/java/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/java/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/java/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/java/#cronoptions","text":"Options to configure a cron expression. All fields are strings so you can use complex expressions. Absence of a field implies \u2018*\u2019","title":"CronOptions "},{"location":"reference/cdk8s/java/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/java/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/java/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/java/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/java/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/java/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/java/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/java/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/java/#cron","text":"Represents a cron schedule.","title":"Cron "},{"location":"reference/cdk8s/java/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/java/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/java/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/java/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/java/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/java/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/java/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/java/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/java/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/java/#ianyproducer","text":"Implemented By: org.cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/java/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/java/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/python/","text":"cdk8s (Python) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import cdk8s cdk8s . ApiObject ( scope : Construct , id : str , api_version : str , kind : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: str namespace. api_version Required \u00b6 Type: str API version. kind Required \u00b6 Type: str Resource kind. metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. add_json_patch \u00b6 def add_json_patch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. to_json \u00b6 def to_json () Static Functions \u00b6 of \u00b6 import cdk8s cdk8s . ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 chart : Chart Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 kind : str Type: str The object kind. metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 name : str Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import cdk8s cdk8s . App ( outdir : str = None , output_file_extension : str = None , record_construct_metadata : bool = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. output_file_extension Optional \u00b6 Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. record_construct_metadata Optional \u00b6 Type: bool Default: false When set to true, the output directory will contain a construct-metadata.json file that holds construct related metadata on every resource in the app. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 def synth () synth_yaml \u00b6 def synth_yaml () Properties \u00b6 charts Required \u00b6 charts : typing . List [ Chart ] Type: typing.List[ cdk8s.Chart ] Returns all the charts in this app, sorted topologically. outdir Required \u00b6 outdir : str Type: str The output directory into which manifests will be synthesized. output_file_extension Required \u00b6 output_file_extension : str Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. yaml_output_type Required \u00b6 yaml_output_type : YamlOutputType Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import cdk8s cdk8s . Chart ( scope : Construct , id : str , labels : typing . Mapping [ str ] = None , namespace : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generate_object_name \u00b6 def generate_object_name ( api_object : ApiObject ) api_object Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. to_json \u00b6 def to_json () Static Functions \u00b6 is_chart \u00b6 import cdk8s cdk8s . Chart . is_chart ( x : typing . Any ) x Required \u00b6 Type: typing.Any of \u00b6 import cdk8s cdk8s . Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 namespace : str Type: str The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import cdk8s cdk8s . Helm ( scope : Construct , id : str , chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str chart Required \u00b6 Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 release_name Required \u00b6 release_name : str Type: str The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import cdk8s cdk8s . Include ( scope : Construct , id : str , url : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str url Required \u00b6 Type: str Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 api_objects Required \u00b6 api_objects : typing . List [ ApiObject ] Type: typing.List[ cdk8s.ApiObject ] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import cdk8s cdk8s . ApiObjectMetadata ( annotations : typing . Mapping [ str ] = None , finalizers : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None , owner_references : typing . List [ OwnerReference ] = None ) annotations Optional \u00b6 annotations : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 finalizers : typing . List [ str ] Type: typing.List[ str ] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 name : str Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 namespace : str Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces owner_references Optional \u00b6 owner_references : typing . List [ OwnerReference ] Type: typing.List[ cdk8s.OwnerReference ] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import cdk8s cdk8s . ApiObjectProps ( api_version : str , kind : str , metadata : ApiObjectMetadata = None ) api_version Required \u00b6 api_version : str Type: str API version. kind Required \u00b6 kind : str Type: str Resource kind. metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . AppProps ( outdir : str = None , output_file_extension : str = None , record_construct_metadata : bool = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 outdir : str Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. output_file_extension Optional \u00b6 output_file_extension : str Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. record_construct_metadata Optional \u00b6 record_construct_metadata : bool Type: bool Default: false When set to true, the output directory will contain a construct-metadata.json file that holds construct related metadata on every resource in the app. yaml_output_type Optional \u00b6 yaml_output_type : YamlOutputType Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . ChartProps ( labels : typing . Mapping [ str ] = None , namespace : str = None ) labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 namespace : str Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. CronOptions \u00b6 Options to configure a cron expression. All fields are strings so you can use complex expressions. Absence of a field implies \u2018*\u2019 Initializer \u00b6 import cdk8s cdk8s . CronOptions ( day : str = None , hour : str = None , minute : str = None , month : str = None , week_day : str = None ) day Optional \u00b6 day : str Type: str Default: Every day of the month The day of the month to run this rule at. hour Optional \u00b6 hour : str Type: str Default: Every hour The hour to run this rule at. minute Optional \u00b6 minute : str Type: str Default: Every minute The minute to run this rule at. month Optional \u00b6 month : str Type: str Default: Every month The month to run this rule at. week_day Optional \u00b6 week_day : str Type: str Default: Any day of the week The day of the week to run this rule at. GroupVersionKind \u00b6 Initializer \u00b6 import cdk8s cdk8s . GroupVersionKind ( api_version : str , kind : str ) api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 kind : str Type: str The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import cdk8s cdk8s . HelmProps ( chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) chart Required \u00b6 chart : str Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 helm_executable : str Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 helm_flags : typing . List [ str ] Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 release_name : str Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 values : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . IncludeProps ( url : str ) url Required \u00b6 url : str Type: str Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import cdk8s cdk8s . NameOptions ( delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) delimiter Optional \u00b6 delimiter : str Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 extra : typing . List [ str ] Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 include_hash : bool Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 max_len : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import cdk8s cdk8s . OwnerReference ( api_version : str , kind : str , name : str , uid : str , block_owner_deletion : bool = None , controller : bool = None ) api_version Required \u00b6 api_version : str Type: str API version of the referent. kind Required \u00b6 kind : str Type: str Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 name : str Type: str Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 uid : str Type: str UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids block_owner_deletion Optional \u00b6 block_owner_deletion : bool Type: bool Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 controller : bool Type: bool If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . SizeConversionOptions ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 rounding : SizeRoundingBehavior Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . TimeConversionOptions ( integral : bool = None ) integral Optional \u00b6 integral : bool Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import cdk8s cdk8s . ApiObjectMetadataDefinition ( annotations : typing . Mapping [ str ] = None , finalizers : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None , owner_references : typing . List [ OwnerReference ] = None ) annotations Optional \u00b6 Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 Type: typing.List[ str ] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces owner_references Optional \u00b6 Type: typing.List[ cdk8s.OwnerReference ] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ Methods \u00b6 add \u00b6 def add ( key : str , value : typing . Any ) key Required \u00b6 Type: str Metadata key. value Required \u00b6 Type: typing.Any Metadata value. add_annotation \u00b6 def add_annotation ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_finalizers \u00b6 def add_finalizers ( finalizers : str ) finalizers Required \u00b6 Type: str the finalizers. add_label \u00b6 def add_label ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_owner_reference \u00b6 def add_owner_reference ( api_version : str , kind : str , name : str , uid : str , block_owner_deletion : bool = None , controller : bool = None ) api_version Required \u00b6 Type: str API version of the referent. kind Required \u00b6 Type: str Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 Type: str Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 Type: str UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids block_owner_deletion Optional \u00b6 Type: bool Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 Type: bool If true, this reference points to the managing controller. get_label \u00b6 def get_label ( key : str ) key Required \u00b6 Type: str the label. to_json \u00b6 def to_json () Properties \u00b6 name Optional \u00b6 name : str Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 namespace : str Type: str The object\u2019s namespace. Cron \u00b6 Represents a cron schedule. Initializers \u00b6 import cdk8s cdk8s . Cron ( day : str = None , hour : str = None , minute : str = None , month : str = None , week_day : str = None ) day Optional \u00b6 Type: str Default: Every day of the month The day of the month to run this rule at. hour Optional \u00b6 Type: str Default: Every hour The hour to run this rule at. minute Optional \u00b6 Type: str Default: Every minute The minute to run this rule at. month Optional \u00b6 Type: str Default: Every month The month to run this rule at. week_day Optional \u00b6 Type: str Default: Any day of the week The day of the week to run this rule at. Static Functions \u00b6 annually \u00b6 import cdk8s cdk8s . Cron . annually () daily \u00b6 import cdk8s cdk8s . Cron . daily () every_minute \u00b6 import cdk8s cdk8s . Cron . every_minute () hourly \u00b6 import cdk8s cdk8s . Cron . hourly () monthly \u00b6 import cdk8s cdk8s . Cron . monthly () schedule \u00b6 import cdk8s cdk8s . Cron . schedule ( day : str = None , hour : str = None , minute : str = None , month : str = None , week_day : str = None ) day Optional \u00b6 Type: str Default: Every day of the month The day of the month to run this rule at. hour Optional \u00b6 Type: str Default: Every hour The hour to run this rule at. minute Optional \u00b6 Type: str Default: Every minute The minute to run this rule at. month Optional \u00b6 Type: str Default: Every month The month to run this rule at. week_day Optional \u00b6 Type: str Default: Any day of the week The day of the week to run this rule at. weekly \u00b6 import cdk8s cdk8s . Cron . weekly () Properties \u00b6 expression_string Required \u00b6 expression_string : str Type: str Retrieve the expression for this schedule. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import cdk8s cdk8s . DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 def topology () Properties \u00b6 root Required \u00b6 root : DependencyVertex Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import cdk8s cdk8s . DependencyVertex ( value : IConstruct = None ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 add_child \u00b6 def add_child ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 def topology () Properties \u00b6 inbound Required \u00b6 inbound : typing . List [ DependencyVertex ] Type: typing.List[ cdk8s.DependencyVertex ] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 outbound : typing . List [ DependencyVertex ] Type: typing.List[ cdk8s.DependencyVertex ] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 value : IConstruct Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 to_days \u00b6 def to_days ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_hours \u00b6 def to_hours ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_human_string \u00b6 def to_human_string () to_iso_string \u00b6 def to_iso_string () to_milliseconds \u00b6 def to_milliseconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_minutes \u00b6 def to_minutes ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_seconds \u00b6 def to_seconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. unit_label \u00b6 def unit_label () Static Functions \u00b6 days \u00b6 import cdk8s cdk8s . Duration . days ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Days the Duration will represent. hours \u00b6 import cdk8s cdk8s . Duration . hours ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Hours the Duration will represent. millis \u00b6 import cdk8s cdk8s . Duration . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Milliseconds the Duration will represent. minutes \u00b6 import cdk8s cdk8s . Duration . minutes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Minutes the Duration will represent. parse \u00b6 import cdk8s cdk8s . Duration . parse ( duration : str ) duration Required \u00b6 Type: str an ISO-formtted duration to be parsed. seconds \u00b6 import cdk8s cdk8s . Duration . seconds ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import cdk8s cdk8s . JsonPatch . add ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any apply \u00b6 import cdk8s cdk8s . JsonPatch . apply ( document : typing . Any , ops : JsonPatch ) document Required \u00b6 Type: typing.Any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import cdk8s cdk8s . JsonPatch . copy ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str move \u00b6 import cdk8s cdk8s . JsonPatch . move ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str remove \u00b6 import cdk8s cdk8s . JsonPatch . remove ( path : str ) path Required \u00b6 Type: str replace \u00b6 import cdk8s cdk8s . JsonPatch . replace ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any test \u00b6 import cdk8s cdk8s . JsonPatch . test ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any Lazy \u00b6 Methods \u00b6 produce \u00b6 def produce () Static Functions \u00b6 any \u00b6 import cdk8s cdk8s . Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 to_dns_label \u00b6 import cdk8s cdk8s . Names . to_dns_label ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. to_label_value \u00b6 import cdk8s cdk8s . Names . to_label_value ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 to_gibibytes \u00b6 def to_gibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_kibibytes \u00b6 def to_kibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_mebibytes \u00b6 def to_mebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_pebibytes \u00b6 def to_pebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_tebibytes \u00b6 def to_tebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. Static Functions \u00b6 gibibytes \u00b6 import cdk8s cdk8s . Size . gibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] kibibytes \u00b6 import cdk8s cdk8s . Size . kibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] mebibytes \u00b6 import cdk8s cdk8s . Size . mebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] pebibyte \u00b6 import cdk8s cdk8s . Size . pebibyte ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] tebibytes \u00b6 import cdk8s cdk8s . Size . tebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import cdk8s cdk8s . Testing . app ( outdir : str = None , output_file_extension : str = None , record_construct_metadata : bool = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. output_file_extension Optional \u00b6 Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. record_construct_metadata Optional \u00b6 Type: bool Default: false When set to true, the output directory will contain a construct-metadata.json file that holds construct related metadata on every resource in the app. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. chart \u00b6 import cdk8s cdk8s . Testing . chart () synth \u00b6 import cdk8s cdk8s . Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ format_objects ~~ \u00b6 import cdk8s cdk8s . Yaml . format_objects ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] load \u00b6 import cdk8s cdk8s . Yaml . load ( url_or_file : str ) url_or_file Required \u00b6 Type: str a URL of a file path to load from. save \u00b6 import cdk8s cdk8s . Yaml . save ( file_path : str , docs : typing . List [ typing . Any ] ) file_path Required \u00b6 Type: str The output path. docs Required \u00b6 Type: typing.List[ typing.Any ] The set of objects. stringify \u00b6 import cdk8s cdk8s . Yaml . stringify ( docs : typing . Any ) docs Required \u00b6 Type: typing.Any A set of objects to convert to YAML. tmp \u00b6 import cdk8s cdk8s . Yaml . tmp ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 def produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file. FOLDER_PER_CHART_FILE_PER_RESOURCE \u00b6 Each chart in its own folder and each resource in its own file.","title":"Python"},{"location":"reference/cdk8s/python/#cdk8s-python","text":"","title":"cdk8s (Python) "},{"location":"reference/cdk8s/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/python/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/python/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/python/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/python/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/python/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/python/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/python/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/python/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/python/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/python/#cronoptions","text":"Options to configure a cron expression. All fields are strings so you can use complex expressions. Absence of a field implies \u2018*\u2019","title":"CronOptions "},{"location":"reference/cdk8s/python/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/python/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/python/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/python/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/python/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/python/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/python/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/python/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/python/#cron","text":"Represents a cron schedule.","title":"Cron "},{"location":"reference/cdk8s/python/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/python/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/python/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/python/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/python/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/python/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/python/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/python/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/python/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/python/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/python/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/python/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/typescript/","text":"cdk8s (TypeScript) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import { ApiObject } from 'cdk8s' new ApiObject ( scope : Construct , id : string , props : ApiObjectProps ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: string namespace. props Required \u00b6 Type: cdk8s.ApiObjectProps options. Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import { ApiObject } from 'cdk8s' ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 public readonly chart : Chart ; Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 public readonly kind : string ; Type: string The object kind. metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 public readonly name : string ; Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import { App } from 'cdk8s' new App ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps configuration options. Methods \u00b6 synth \u00b6 public synth () synthYaml \u00b6 public synthYaml () Properties \u00b6 charts Required \u00b6 public readonly charts : Chart []; Type: cdk8s.Chart [] Returns all the charts in this app, sorted topologically. outdir Required \u00b6 public readonly outdir : string ; Type: string The output directory into which manifests will be synthesized. outputFileExtension Required \u00b6 public readonly outputFileExtension : string ; Type: string Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Required \u00b6 public readonly yamlOutputType : YamlOutputType ; Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import { Chart } from 'cdk8s' new Chart ( scope : Construct , id : string , props? : ChartProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s.ChartProps Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( apiObject : ApiObject ) apiObject Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 isChart \u00b6 import { Chart } from 'cdk8s' Chart . isChart ( x : any ) x Required \u00b6 Type: any of \u00b6 import { Chart } from 'cdk8s' Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 public readonly namespace : string ; Type: string The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import { Helm } from 'cdk8s' new Helm ( scope : Construct , id : string , props : HelmProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.HelmProps Properties \u00b6 releaseName Required \u00b6 public readonly releaseName : string ; Type: string The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import { Include } from 'cdk8s' new Include ( scope : Construct , id : string , props : IncludeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.IncludeProps Properties \u00b6 apiObjects Required \u00b6 public readonly apiObjects : ApiObject []; Type: cdk8s.ApiObject [] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import { ApiObjectMetadata } from 'cdk8s' const apiObjectMetadata : ApiObjectMetadata = { ... } annotations Optional \u00b6 public readonly annotations : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 public readonly finalizers : string []; Type: string [] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 public readonly name : string ; Type: string Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 public readonly namespace : string ; Type: string Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 public readonly ownerReferences : OwnerReference []; Type: cdk8s.OwnerReference [] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import { ApiObjectProps } from 'cdk8s' const apiObjectProps : ApiObjectProps = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string API version. kind Required \u00b6 public readonly kind : string ; Type: string Resource kind. metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import { AppProps } from 'cdk8s' const appProps : AppProps = { ... } outdir Optional \u00b6 public readonly outdir : string ; Type: string Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. outputFileExtension Optional \u00b6 public readonly outputFileExtension : string ; Type: string Default: .k8s.yaml The file extension to use for rendered YAML files. recordConstructMetadata Optional \u00b6 public readonly recordConstructMetadata : boolean ; Type: boolean Default: false When set to true, the output directory will contain a construct-metadata.json file that holds construct related metadata on every resource in the app. yamlOutputType Optional \u00b6 public readonly yamlOutputType : YamlOutputType ; Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import { ChartProps } from 'cdk8s' const chartProps : ChartProps = { ... } labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 public readonly namespace : string ; Type: string Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. CronOptions \u00b6 Options to configure a cron expression. All fields are strings so you can use complex expressions. Absence of a field implies \u2018*\u2019 Initializer \u00b6 import { CronOptions } from 'cdk8s' const cronOptions : CronOptions = { ... } day Optional \u00b6 public readonly day : string ; Type: string Default: Every day of the month The day of the month to run this rule at. hour Optional \u00b6 public readonly hour : string ; Type: string Default: Every hour The hour to run this rule at. minute Optional \u00b6 public readonly minute : string ; Type: string Default: Every minute The minute to run this rule at. month Optional \u00b6 public readonly month : string ; Type: string Default: Every month The month to run this rule at. weekDay Optional \u00b6 public readonly weekDay : string ; Type: string Default: Any day of the week The day of the week to run this rule at. GroupVersionKind \u00b6 Initializer \u00b6 import { GroupVersionKind } from 'cdk8s' const groupVersionKind : GroupVersionKind = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 public readonly kind : string ; Type: string The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import { HelmProps } from 'cdk8s' const helmProps : HelmProps = { ... } chart Required \u00b6 public readonly chart : string ; Type: string The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 public readonly helmExecutable : string ; Type: string Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 public readonly helmFlags : string []; Type: string [] Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 public readonly releaseName : string ; Type: string Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 public readonly values : {[ key : string ] : any }; Type: {[ key: string ]: any } Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import { IncludeProps } from 'cdk8s' const includeProps : IncludeProps = { ... } url Required \u00b6 public readonly url : string ; Type: string Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import { NameOptions } from 'cdk8s' const nameOptions : NameOptions = { ... } delimiter Optional \u00b6 public readonly delimiter : string ; Type: string Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 public readonly extra : string []; Type: string [] Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 public readonly includeHash : boolean ; Type: boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 public readonly maxLen : number ; Type: number Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import { OwnerReference } from 'cdk8s' const ownerReference : OwnerReference = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string API version of the referent. kind Required \u00b6 public readonly kind : string ; Type: string Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 public readonly name : string ; Type: string Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 public readonly uid : string ; Type: string UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids blockOwnerDeletion Optional \u00b6 public readonly blockOwnerDeletion : boolean ; Type: boolean Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 public readonly controller : boolean ; Type: boolean If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { SizeConversionOptions } from 'cdk8s' const sizeConversionOptions : SizeConversionOptions = { ... } rounding Optional \u00b6 public readonly rounding : SizeRoundingBehavior ; Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { TimeConversionOptions } from 'cdk8s' const timeConversionOptions : TimeConversionOptions = { ... } integral Optional \u00b6 public readonly integral : boolean ; Type: boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import { ApiObjectMetadataDefinition } from 'cdk8s' new ApiObjectMetadataDefinition ( options? : ApiObjectMetadata ) options Optional \u00b6 Type: cdk8s.ApiObjectMetadata Methods \u00b6 add \u00b6 public add ( key : string , value : any ) key Required \u00b6 Type: string Metadata key. value Required \u00b6 Type: any Metadata value. addAnnotation \u00b6 public addAnnotation ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addFinalizers \u00b6 public addFinalizers ( finalizers : string ) finalizers Required \u00b6 Type: string the finalizers. addLabel \u00b6 public addLabel ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addOwnerReference \u00b6 public addOwnerReference ( owner : OwnerReference ) owner Required \u00b6 Type: cdk8s.OwnerReference the owner. getLabel \u00b6 public getLabel ( key : string ) key Required \u00b6 Type: string the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 public readonly name : string ; Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 public readonly namespace : string ; Type: string The object\u2019s namespace. Cron \u00b6 Represents a cron schedule. Initializers \u00b6 import { Cron } from 'cdk8s' new Cron ( cronOptions? : CronOptions ) cronOptions Optional \u00b6 Type: cdk8s.CronOptions Static Functions \u00b6 annually \u00b6 import { Cron } from 'cdk8s' Cron . annually () daily \u00b6 import { Cron } from 'cdk8s' Cron . daily () everyMinute \u00b6 import { Cron } from 'cdk8s' Cron . everyMinute () hourly \u00b6 import { Cron } from 'cdk8s' Cron . hourly () monthly \u00b6 import { Cron } from 'cdk8s' Cron . monthly () schedule \u00b6 import { Cron } from 'cdk8s' Cron . schedule ( options : CronOptions ) options Required \u00b6 Type: cdk8s.CronOptions weekly \u00b6 import { Cron } from 'cdk8s' Cron . weekly () Properties \u00b6 expressionString Required \u00b6 public readonly expressionString : string ; Type: string Retrieve the expression for this schedule. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import { DependencyGraph } from 'cdk8s' new DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 public readonly root : DependencyVertex ; Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import { DependencyVertex } from 'cdk8s' new DependencyVertex ( value? : IConstruct ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 public readonly inbound : DependencyVertex []; Type: cdk8s.DependencyVertex [] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 public readonly outbound : DependencyVertex []; Type: cdk8s.DependencyVertex [] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 public readonly value : IConstruct ; Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHours \u00b6 public toHours ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions unitLabel \u00b6 public unitLabel () Static Functions \u00b6 days \u00b6 import { Duration } from 'cdk8s' Duration . days ( amount : number ) amount Required \u00b6 Type: number the amount of Days the Duration will represent. hours \u00b6 import { Duration } from 'cdk8s' Duration . hours ( amount : number ) amount Required \u00b6 Type: number the amount of Hours the Duration will represent. millis \u00b6 import { Duration } from 'cdk8s' Duration . millis ( amount : number ) amount Required \u00b6 Type: number the amount of Milliseconds the Duration will represent. minutes \u00b6 import { Duration } from 'cdk8s' Duration . minutes ( amount : number ) amount Required \u00b6 Type: number the amount of Minutes the Duration will represent. parse \u00b6 import { Duration } from 'cdk8s' Duration . parse ( duration : string ) duration Required \u00b6 Type: string an ISO-formtted duration to be parsed. seconds \u00b6 import { Duration } from 'cdk8s' Duration . seconds ( amount : number ) amount Required \u00b6 Type: number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . add ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any apply \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . apply ( document : any , ops : JsonPatch ) document Required \u00b6 Type: any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . copy ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string move \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . move ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string remove \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . remove ( path : string ) path Required \u00b6 Type: string replace \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . replace ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any test \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . test ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import { Lazy } from 'cdk8s' Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import { Names } from 'cdk8s' Names . toDnsLabel ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. toLabelValue \u00b6 import { Names } from 'cdk8s' Names . toLabelValue ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import { Size } from 'cdk8s' Size . gibibytes ( amount : number ) amount Required \u00b6 Type: number kibibytes \u00b6 import { Size } from 'cdk8s' Size . kibibytes ( amount : number ) amount Required \u00b6 Type: number mebibytes \u00b6 import { Size } from 'cdk8s' Size . mebibytes ( amount : number ) amount Required \u00b6 Type: number pebibyte \u00b6 import { Size } from 'cdk8s' Size . pebibyte ( amount : number ) amount Required \u00b6 Type: number tebibytes \u00b6 import { Size } from 'cdk8s' Size . tebibytes ( amount : number ) amount Required \u00b6 Type: number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import { Testing } from 'cdk8s' Testing . app ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps chart \u00b6 import { Testing } from 'cdk8s' Testing . chart () synth \u00b6 import { Testing } from 'cdk8s' Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ formatObjects ~~ \u00b6 import { Yaml } from 'cdk8s' Yaml . formatObjects ( docs : any []) docs Required \u00b6 Type: any [] load \u00b6 import { Yaml } from 'cdk8s' Yaml . load ( urlOrFile : string ) urlOrFile Required \u00b6 Type: string a URL of a file path to load from. save \u00b6 import { Yaml } from 'cdk8s' Yaml . save ( filePath : string , docs : any []) filePath Required \u00b6 Type: string The output path. docs Required \u00b6 Type: any [] The set of objects. stringify \u00b6 import { Yaml } from 'cdk8s' Yaml . stringify ( docs : any ) docs Required \u00b6 Type: any A set of objects to convert to YAML. tmp \u00b6 import { Yaml } from 'cdk8s' Yaml . tmp ( docs : any []) docs Required \u00b6 Type: any [] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file. FOLDER_PER_CHART_FILE_PER_RESOURCE \u00b6 Each chart in its own folder and each resource in its own file.","title":"TypeScript"},{"location":"reference/cdk8s/typescript/#cdk8s-typescript","text":"","title":"cdk8s (TypeScript) "},{"location":"reference/cdk8s/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/typescript/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/typescript/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/typescript/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/typescript/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/typescript/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/typescript/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/typescript/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/typescript/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/typescript/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/typescript/#cronoptions","text":"Options to configure a cron expression. All fields are strings so you can use complex expressions. Absence of a field implies \u2018*\u2019","title":"CronOptions "},{"location":"reference/cdk8s/typescript/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/typescript/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/typescript/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/typescript/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/typescript/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/typescript/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/typescript/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/typescript/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/typescript/#cron","text":"Represents a cron schedule.","title":"Cron "},{"location":"reference/cdk8s/typescript/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/typescript/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/typescript/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/typescript/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/typescript/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/typescript/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/typescript/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/typescript/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/typescript/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/typescript/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/typescript/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/typescript/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s-plus-22/go/","text":"cdk8s-plus-22 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22 .","title":"Go"},{"location":"reference/cdk8s-plus-22/go/#cdk8s-plus-22-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22 .","title":"cdk8s-plus-22 (Go) "},{"location":"reference/cdk8s-plus-22/java/","text":"cdk8s-plus-22 (Java) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: org.cdk8s.plus22.IPodSelector , org.cdk8s.plus22.INetworkPolicyPeer , org.cdk8s.plus22.ISubject Initializers \u00b6 import org.cdk8s.plus22.AbstractPod ; AbstractPod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addHostAlias \u00b6 public addHostAlias ( HostAlias hostAlias ) hostAlias Required \u00b6 Type: org.cdk8s.plus22.HostAlias addInitContainer \u00b6 public addInitContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume vol ) vol Required \u00b6 Type: org.cdk8s.plus22.Volume toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 automountServiceAccountToken Required \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > dns Required \u00b6 public PodDns getDns (); Type: org.cdk8s.plus22.PodDns hostAliases Required \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > initContainers Required \u00b6 public java . util . List < Container > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.Container > podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition securityContext Required \u00b6 public PodSecurityContext getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContext volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume ; AwsElasticBlockStorePersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Volume id of this volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import org.cdk8s.plus22.AzureDiskPersistentVolume ; AzureDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azureKind Required \u00b6 public AzureDiskPersistentVolumeKind getAzureKind (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String Disk name of this volume. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String Disk URI of this volume. fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import org.cdk8s.plus22.BasicAuthSecret ; BasicAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: java.lang.String The password or token for authentication. username Required \u00b6 Type: java.lang.String The user name for authentication. ClusterRole \u00b6 Implements: org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import org.cdk8s.plus22.ClusterRole ; ClusterRole . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 public aggregate ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiEndpoint endpoints ) verbs Required \u00b6 Type: java.util.List< java.lang.String > endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( java . lang . String namespace , ISubject subjects ) namespace Required \u00b6 Type: java.lang.String the namespace to limit permissions to. subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject a list of subjects to bind to. combine \u00b6 public combine ( ClusterRole rol ) rol Required \u00b6 Type: org.cdk8s.plus22.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import org.cdk8s.plus22.ClusterRole ; ClusterRole . fromClusterRoleName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.ClusterRolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import org.cdk8s.plus22.ClusterRoleBinding ; ClusterRoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus22.IClusterRole The role to bind to. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus22.IClusterRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus22.ISubject > ConfigMap \u00b6 Implements: org.cdk8s.plus22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus22.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus22.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus22.ConfigMap ; ConfigMap . fromConfigMapName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not this config map is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import org.cdk8s.plus22.CronJob ; CronJob . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . schedule ( Cron ) // .concurrencyPolicy(ConcurrencyPolicy) // .failedJobsRetained(java.lang.Number) // .startingDeadline(Duration) // .successfulJobsRetained(java.lang.Number) // .suspend(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 Type: org.cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 Type: org.cdk8s.plus22.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 Type: java.lang.Number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 Type: java.lang.Number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 Type: java.lang.Boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. Properties \u00b6 concurrencyPolicy Required \u00b6 public java . lang . String getConcurrencyPolicy (); Type: java.lang.String The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failedJobsRetained Required \u00b6 public java . lang . Number getFailedJobsRetained (); Type: java.lang.Number The number of failed jobs retained by this cron job. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String Represents the resource type. schedule Required \u00b6 public Cron getSchedule (); Type: org.cdk8s.Cron The schedule this cron job is scheduled to run in. startingDeadline Required \u00b6 public Duration getStartingDeadline (); Type: org.cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successfulJobsRetained Required \u00b6 public java . lang . Number getSuccessfulJobsRetained (); Type: java.lang.Number The number of successful jobs retained by this cron job. suspend Required \u00b6 public java . lang . Boolean getSuspend (); Type: java.lang.Boolean Whether or not the cron job is currently suspended or not. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import org.cdk8s.plus22.DaemonSet ; DaemonSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 minReadySeconds Required \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus22.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: java.lang.Number Default: 2 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus22.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( DeploymentExposeViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.DeploymentExposeViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus22.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import org.cdk8s.plus22.DockerConfigSecret ; DockerConfigSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import org.cdk8s.plus22.GCEPersistentDiskPersistentVolume ; GCEPersistentDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String PD resource in GCE of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. Group \u00b6 Implements: org.cdk8s.plus22.ISubject Represents a group. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import org.cdk8s.plus22.Group ; Group . fromName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String name Required \u00b6 public java . lang . String getName (); Type: java.lang.String apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus22.Ingress ; Ingress . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressBackend backend ) backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressBackend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend ) public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus22.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( java . lang . String path , IngressBackend backend ) public addRule ( java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus22.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( IngressRule rules ) rules Required \u00b6 Type: org.cdk8s.plus22.IngressRule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressTls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressTls > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus22.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: org.cdk8s.plus22.INamespaceSelector , org.cdk8s.plus22.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import org.cdk8s.plus22.Namespace ; Namespace . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: java.lang.String https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: org.cdk8s.plus22.INamespaceSelector , org.cdk8s.plus22.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import org.cdk8s.plus22.Namespaces ; new Namespaces ( Construct scope , java . lang . String id ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . List < java . lang . String > names ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . List < java . lang . String > names , java . util . Map < java . lang . String , java . lang . String > labels ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String expressions Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.LabelExpression > names Optional \u00b6 Type: java.util.List< java.lang.String > labels Optional \u00b6 Type: java.util.Map java.lang.String > Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 all \u00b6 import org.cdk8s.plus22.Namespaces ; Namespaces . all ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String select \u00b6 import org.cdk8s.plus22.Namespaces ; Namespaces . select ( Construct scope , java . lang . String id , NamespacesSelectOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus22.NamespacesSelectOptions NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import org.cdk8s.plus22.NetworkPolicy ; NetworkPolicy . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .egress(NetworkPolicyTraffic) // .ingress(NetworkPolicyTraffic) // .selector(IPodSelector) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 Type: org.cdk8s.plus22.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 Type: org.cdk8s.plus22.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 Type: org.cdk8s.plus22.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that Methods \u00b6 addEgressRule \u00b6 public addEgressRule ( INetworkPolicyPeer peer ) public addEgressRule ( INetworkPolicyPeer peer , java . util . List < NetworkPolicyPort > ports ) peer Required \u00b6 Type: org.cdk8s.plus22.INetworkPolicyPeer ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.NetworkPolicyPort > addIngressRule \u00b6 public addIngressRule ( INetworkPolicyPeer peer ) public addIngressRule ( INetworkPolicyPeer peer , java . util . List < NetworkPolicyPort > ports ) peer Required \u00b6 Type: org.cdk8s.plus22.INetworkPolicyPeer ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.NetworkPolicyPort > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: org.cdk8s.plus22.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 anyIpv4 \u00b6 import org.cdk8s.plus22.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . anyIpv4 ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String anyIpv6 \u00b6 import org.cdk8s.plus22.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . anyIpv6 ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String ipv4 \u00b6 import org.cdk8s.plus22.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . ipv4 ( Construct scope , java . lang . String id , java . lang . String cidrIp ) NetworkPolicyIpBlock . ipv4 ( Construct scope , java . lang . String id , java . lang . String cidrIp , java . util . List < java . lang . String > except ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String cidrIp Required \u00b6 Type: java.lang.String except Optional \u00b6 Type: java.util.List< java.lang.String > ipv6 \u00b6 import org.cdk8s.plus22.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . ipv6 ( Construct scope , java . lang . String id , java . lang . String cidrIp ) NetworkPolicyIpBlock . ipv6 ( Construct scope , java . lang . String id , java . lang . String cidrIp , java . util . List < java . lang . String > except ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String cidrIp Required \u00b6 Type: java.lang.String except Optional \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 cidr Required \u00b6 public java . lang . String getCidr (); Type: java.lang.String A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 public java . util . List < java . lang . String > getExcept (); Type: java.util.List< java.lang.String > A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import org.cdk8s.plus22.PersistentVolume ; PersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( IPersistentVolumeClaim claim ) claim Required \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import org.cdk8s.plus22.PersistentVolume ; PersistentVolume . fromPersistentVolumeName ( Construct scope , java . lang . String id , java . lang . String volumeName ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String volumeName Required \u00b6 Type: java.lang.String Properties \u00b6 mode Required \u00b6 public PersistentVolumeMode getMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Access modes requirement of this claim. claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Mount options of this volume. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: org.cdk8s.plus22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import org.cdk8s.plus22.PersistentVolumeClaim ; PersistentVolumeClaim . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 public bind ( IPersistentVolume vol ) vol Required \u00b6 Type: org.cdk8s.plus22.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import org.cdk8s.plus22.PersistentVolumeClaim ; PersistentVolumeClaim . fromClaimName ( Construct scope , java . lang . String id , java . lang . String claimName ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String claimName Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Access modes requirement of this claim. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class requirment of this claim. volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus22.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus22.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 connections Required \u00b6 public PodConnections getConnections (); Type: org.cdk8s.plus22.PodConnections podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 public PodScheduling getScheduling (); Type: org.cdk8s.plus22.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: java.lang.String This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: org.cdk8s.plus22.IPodSelector Represents a group of pods. Initializers \u00b6 import org.cdk8s.plus22.Pods ; new Pods ( Construct scope , java . lang . String id ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . Map < java . lang . String , java . lang . String > labels ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . Map < java . lang . String , java . lang . String > labels , INamespaceSelector namespaces ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String expressions Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.LabelExpression > labels Optional \u00b6 Type: java.util.Map java.lang.String > namespaces Optional \u00b6 Type: org.cdk8s.plus22.INamespaceSelector Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () Static Functions \u00b6 all \u00b6 import org.cdk8s.plus22.Pods ; Pods . all ( Construct scope , java . lang . String id ) Pods . all ( Construct scope , java . lang . String id , PodsAllOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.PodsAllOptions select \u00b6 import org.cdk8s.plus22.Pods ; Pods . select ( Construct scope , java . lang . String id , PodsSelectOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus22.PodsSelectOptions Resource \u00b6 Implements: org.cdk8s.plus22.IResource , org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus22.Resource ; new Resource ( Construct scope , java . lang . String id ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. permissions Required \u00b6 public ResourcePermissions getPermissions (); Type: org.cdk8s.plus22.ResourcePermissions resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: org.cdk8s.plus22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import org.cdk8s.plus22.Role ; Role . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.RolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiResource resources ) verbs Required \u00b6 Type: java.util.List< java.lang.String > resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import org.cdk8s.plus22.Role ; Role . fromRoleName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.RolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import org.cdk8s.plus22.RoleBinding ; RoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus22.IRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus22.ISubject > Secret \u00b6 Implements: org.cdk8s.plus22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus22.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus22.Secret ; Secret . fromSecretName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not the secret is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus22.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .selector(IPodSelector) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ServicePort > Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 Type: org.cdk8s.plus22.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 Type: org.cdk8s.plus22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 bind \u00b6 public bind ( java . lang . Number port ) public bind ( java . lang . Number port , ServiceBindOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus22.ServiceBindOptions exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus22.ExposeServiceViaIngressOptions Additional options. select \u00b6 public select ( IPodSelector selector ) selector Required \u00b6 Type: org.cdk8s.plus22.IPodSelector selectLabel \u00b6 public selectLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > Ports for this service. Use bind() to bind additional service ports. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus22.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus22.IServiceAccount , org.cdk8s.plus22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus22.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus22.ISecret The secret. toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus22.ServiceAccount ; ServiceAccount . fromServiceAccountName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import org.cdk8s.plus22.ServiceAccountTokenSecret ; ServiceAccountTokenSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 Type: org.cdk8s.plus22.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import org.cdk8s.plus22.SshAuthSecret ; SshAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 Type: java.lang.String The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus22.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 Type: org.cdk8s.plus22.Service Service to associate with the statefulset. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus22.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus22.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import org.cdk8s.plus22.TlsSecret ; TlsSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 Type: java.lang.String The TLS cert. tlsKey Required \u00b6 Type: java.lang.String The TLS key. User \u00b6 Implements: org.cdk8s.plus22.ISubject Represents a user. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import org.cdk8s.plus22.User ; User . fromName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String name Required \u00b6 public java . lang . String getName (); Type: java.lang.String apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String Volume \u00b6 Implements: org.cdk8s.plus22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromAwsElasticBlockStore ( Construct scope , java . lang . String id , java . lang . String volumeId ) Volume . fromAwsElasticBlockStore ( Construct scope , java . lang . String id , java . lang . String volumeId , AwsElasticBlockStoreVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String volumeId Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromAzureDisk ( Construct scope , java . lang . String id , java . lang . String diskName , java . lang . String diskUri ) Volume . fromAzureDisk ( Construct scope , java . lang . String id , java . lang . String diskName , java . lang . String diskUri , AzureDiskVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String diskName Required \u00b6 Type: java.lang.String diskUri Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.AzureDiskVolumeOptions fromConfigMap \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromConfigMap ( Construct scope , java . lang . String id , IConfigMap configMap ) Volume . fromConfigMap ( Construct scope , java . lang . String id , IConfigMap configMap , ConfigMapVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus22.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromEmptyDir ( Construct scope , java . lang . String id , java . lang . String name ) Volume . fromEmptyDir ( Construct scope , java . lang . String id , java . lang . String name , EmptyDirVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromGcePersistentDisk ( Construct scope , java . lang . String id , java . lang . String pdName ) Volume . fromGcePersistentDisk ( Construct scope , java . lang . String id , java . lang . String pdName , GCEPersistentDiskVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String pdName Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.GCEPersistentDiskVolumeOptions fromHostPath \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromHostPath ( Construct scope , java . lang . String id , java . lang . String name , HostPathVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus22.HostPathVolumeOptions fromPersistentVolumeClaim \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromPersistentVolumeClaim ( Construct scope , java . lang . String id , IPersistentVolumeClaim claim ) Volume . fromPersistentVolumeClaim ( Construct scope , java . lang . String id , IPersistentVolumeClaim claim , PersistentVolumeClaimVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String claim Required \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim options Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromSecret ( Construct scope , java . lang . String id , ISecret secr ) Volume . fromSecret ( Construct scope , java . lang . String id , ISecret secr , SecretVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String secr Required \u00b6 Type: org.cdk8s.plus22.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus22.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import org.cdk8s.plus22.Workload ; Workload . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints Methods \u00b6 select \u00b6 public select ( LabelSelector selectors ) selectors Required \u00b6 Type: org.cdk8s.plus22.LabelSelector Properties \u00b6 connections Required \u00b6 public PodConnections getConnections (); Type: org.cdk8s.plus22.PodConnections matchExpressions Required \u00b6 public java . util . List < LabelSelectorRequirement > getMatchExpressions (); Type: java.util.List< org.cdk8s.plus22.LabelSelectorRequirement > The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getMatchLabels (); Type: java.util.Map java.lang.String > The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 public WorkloadScheduling getScheduling (); Type: org.cdk8s.plus22.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import org.cdk8s.plus22.AbstractPodProps ; AbstractPodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus22.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus22.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import org.cdk8s.plus22.ApiResourceOptions ; ApiResourceOptions . builder () . apiGroup ( java . lang . String ) . resourceType ( java . lang . String ) . build (); apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.AwsElasticBlockStorePersistentVolumeProps ; AwsElasticBlockStorePersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import org.cdk8s.plus22.AwsElasticBlockStoreVolumeOptions ; AwsElasticBlockStoreVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.AzureDiskPersistentVolumeProps ; AzureDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import org.cdk8s.plus22.AzureDiskVolumeOptions ; AzureDiskVolumeOptions . builder () // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import org.cdk8s.plus22.BasicAuthSecretProps ; BasicAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public java . lang . String getPassword (); Type: java.lang.String The password or token for authentication. username Required \u00b6 public java . lang . String getUsername (); Type: java.lang.String The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import org.cdk8s.plus22.ClusterRoleBindingProps ; ClusterRoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus22.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import org.cdk8s.plus22.ClusterRolePolicyRule ; ClusterRolePolicyRule . builder () . endpoints ( java . util . List < IApiEndpoint > ) . verbs ( java . util . List < java . lang . String > ) . build (); endpoints Required \u00b6 public java . util . List < IApiEndpoint > getEndpoints (); Type: java.util.List< org.cdk8s.plus22.IApiEndpoint > Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import org.cdk8s.plus22.ClusterRoleProps ; ClusterRoleProps . builder () // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAggregationLabels (); Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus22.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import org.cdk8s.plus22.CommonSecretProps ; CommonSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus22.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus22.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:11076\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import org.cdk8s.plus22.ContainerLifecycle ; ContainerLifecycle . builder () // .postStart(Handler) // .preStop(Handler) . build (); postStart Optional \u00b6 public Handler getPostStart (); Type: org.cdk8s.plus22.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public Handler getPreStop (); Type: org.cdk8s.plus22.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import org.cdk8s.plus22.ContainerPort ; ContainerPort . builder () . number ( java . lang . Number ) // .hostIp(java.lang.String) // .hostPort(java.lang.Number) // .name(java.lang.String) // .protocol(Protocol) . build (); number Required \u00b6 public java . lang . Number getNumber (); Type: java.lang.Number Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. hostIp Optional \u00b6 public java . lang . String getHostIp (); Type: java.lang.String Default: 127.0.0.1. What host IP to bind the external port to. hostPort Optional \u00b6 public java . lang . Number getHostPort (); Type: java.lang.Number Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus22.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .envFrom(java.util.List<EnvFrom>) // .envVariables(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .portNumber(java.lang.Number) // .ports(java.util.List<ContainerPort>) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 public java . util . List < EnvFrom > getEnvFrom (); Type: java.util.List< org.cdk8s.plus22.EnvFrom > Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnvVariables (); Type: java.util.Map \u0002klzzwxh:11030\u0003 > Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public ContainerLifecycle getLifecycle (); Type: org.cdk8s.plus22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public java . lang . Number getPort (); Type: java.lang.Number portNumber Optional \u00b6 public java . lang . Number getPortNumber (); Type: java.lang.Number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 public java . util . List < ContainerPort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ContainerPort > Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public ContainerSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus22.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import org.cdk8s.plus22.ContainerResources ; ContainerResources . builder () // .cpu(CpuResources) // .ephemeralStorage(EphemeralStorageResources) // .memory(MemoryResources) . build (); cpu Optional \u00b6 public CpuResources getCpu (); Type: org.cdk8s.plus22.CpuResources ephemeralStorage Optional \u00b6 public EphemeralStorageResources getEphemeralStorage (); Type: org.cdk8s.plus22.EphemeralStorageResources memory Optional \u00b6 public MemoryResources getMemory (); Type: org.cdk8s.plus22.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import org.cdk8s.plus22.ContainerSecurityContextProps ; ContainerSecurityContextProps . builder () // .allowPrivilegeEscalation(java.lang.Boolean) // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); allowPrivilegeEscalation Optional \u00b6 public java . lang . Boolean getAllowPrivilegeEscalation (); Type: java.lang.Boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import org.cdk8s.plus22.CpuResources ; CpuResources . builder () // .limit(Cpu) // .request(Cpu) . build (); limit Optional \u00b6 public Cpu getLimit (); Type: org.cdk8s.plus22.Cpu request Optional \u00b6 public Cpu getRequest (); Type: org.cdk8s.plus22.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import org.cdk8s.plus22.CronJobProps ; CronJobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . schedule ( Cron ) // .concurrencyPolicy(ConcurrencyPolicy) // .failedJobsRetained(java.lang.Number) // .startingDeadline(Duration) // .successfulJobsRetained(java.lang.Number) // .suspend(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 public Cron getSchedule (); Type: org.cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 public ConcurrencyPolicy getConcurrencyPolicy (); Type: org.cdk8s.plus22.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 public java . lang . Number getFailedJobsRetained (); Type: java.lang.Number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 public Duration getStartingDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 public java . lang . Number getSuccessfulJobsRetained (); Type: java.lang.Number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 public java . lang . Boolean getSuspend (); Type: java.lang.Boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import org.cdk8s.plus22.DaemonSetProps ; DaemonSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import org.cdk8s.plus22.DeploymentExposeViaServiceOptions ; DeploymentExposeViaServiceOptions . builder () // .name(java.lang.String) // .ports(java.util.List<ServicePort>) // .serviceType(ServiceType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus22.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import org.cdk8s.plus22.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 2 Number of desired pods. strategy Optional \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus22.DeploymentStrategyRollingUpdateOptions ; DeploymentStrategyRollingUpdateOptions . builder () // .maxSurge(PercentOrAbsolute) // .maxUnavailable(PercentOrAbsolute) . build (); maxSurge Optional \u00b6 public PercentOrAbsolute getMaxSurge (); Type: org.cdk8s.plus22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public PercentOrAbsolute getMaxUnavailable (); Type: org.cdk8s.plus22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import org.cdk8s.plus22.DnsOption ; DnsOption . builder () . name ( java . lang . String ) // .value(java.lang.String) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Option name. value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import org.cdk8s.plus22.DockerConfigSecretProps ; DockerConfigSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getData (); Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus22.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromFieldRefOptions ; EnvValueFromFieldRefOptions . builder () // .apiVersion(java.lang.String) // .key(java.lang.String) . build (); apiVersion Optional \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromResourceOptions ; EnvValueFromResourceOptions . builder () // .container(Container) // .divisor(java.lang.String) . build (); container Optional \u00b6 public Container getContainer (); Type: org.cdk8s.plus22.Container The container to select the value from. divisor Optional \u00b6 public java . lang . String getDivisor (); Type: java.lang.String The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import org.cdk8s.plus22.EphemeralStorageResources ; EphemeralStorageResources . builder () // .limit(Size) // .request(Size) . build (); limit Optional \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Optional \u00b6 public Size getRequest (); Type: org.cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus22.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .ports(java.util.List<ServicePort>) // .serviceType(ServiceType) // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus22.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus22.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.GCEPersistentDiskPersistentVolumeProps ; GCEPersistentDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import org.cdk8s.plus22.GCEPersistentDiskVolumeOptions ; GCEPersistentDiskVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import org.cdk8s.plus22.HandlerFromHttpGetOptions ; HandlerFromHttpGetOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import org.cdk8s.plus22.HandlerFromTcpSocketOptions ; HandlerFromTcpSocketOptions . builder () // .host(java.lang.String) // .port(java.lang.Number) . build (); host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import org.cdk8s.plus22.HostAlias ; HostAlias . builder () . hostnames ( java . util . List < java . lang . String > ) . ip ( java . lang . String ) . build (); hostnames Required \u00b6 public java . util . List < java . lang . String > getHostnames (); Type: java.util.List< java.lang.String > Hostnames for the chosen IP address. ip Required \u00b6 public java . lang . String getIp (); Type: java.lang.String IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import org.cdk8s.plus22.HostPathVolumeOptions ; HostPathVolumeOptions . builder () . path ( java . lang . String ) // .type(HostPathVolumeType) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The path of the directory on the host. type Optional \u00b6 public HostPathVolumeType getType (); Type: org.cdk8s.plus22.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus22.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) // .scheme(ConnectionScheme) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 public ConnectionScheme getScheme (); Type: org.cdk8s.plus22.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus22.IngressProps ; IngressProps . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressBackend getDefaultBackend (); Type: org.cdk8s.plus22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressRule > getRules (); Type: java.util.List< org.cdk8s.plus22.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressTls > getTls (); Type: java.util.List< org.cdk8s.plus22.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus22.IngressRule ; IngressRule . builder () . backend ( IngressBackend ) // .host(java.lang.String) // .path(java.lang.String) // .pathType(HttpIngressPathType) . build (); backend Required \u00b6 public IngressBackend getBackend (); Type: org.cdk8s.plus22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus22.IngressTls ; IngressTls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import org.cdk8s.plus22.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import org.cdk8s.plus22.LabelSelectorOptions ; LabelSelectorOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus22.LabelExpression > Expression based label matchers. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import org.cdk8s.plus22.LabelSelectorRequirement ; LabelSelectorRequirement . builder () . key ( java . lang . String ) . operator ( java . lang . String ) // .values(java.util.List<java.lang.String>) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The label key that the selector applies to. operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import org.cdk8s.plus22.MemoryResources ; MemoryResources . builder () // .limit(Size) // .request(Size) . build (); limit Optional \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Optional \u00b6 public Size getRequest (); Type: org.cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus22.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import org.cdk8s.plus22.NamespaceProps ; NamespaceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import org.cdk8s.plus22.NamespaceSelectorConfig ; NamespaceSelectorConfig . builder () // .labelSelector(LabelSelector) // .names(java.util.List<java.lang.String>) . build (); labelSelector Optional \u00b6 public LabelSelector getLabelSelector (); Type: org.cdk8s.plus22.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 public java . util . List < java . lang . String > getNames (); Type: java.util.List< java.lang.String > A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import org.cdk8s.plus22.NamespacesSelectOptions ; NamespacesSelectOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .names(java.util.List<java.lang.String>) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus22.LabelExpression > Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 public java . util . List < java . lang . String > getNames (); Type: java.util.List< java.lang.String > Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import org.cdk8s.plus22.NetworkPolicyAddEgressRuleOptions ; NetworkPolicyAddEgressRuleOptions . builder () // .ports(java.util.List<NetworkPolicyPort>) . build (); ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus22.NetworkPolicyPort > Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import org.cdk8s.plus22.NetworkPolicyPeerConfig ; NetworkPolicyPeerConfig . builder () // .ipBlock(NetworkPolicyIpBlock) // .podSelector(PodSelectorConfig) . build (); ipBlock Optional \u00b6 public NetworkPolicyIpBlock getIpBlock (); Type: org.cdk8s.plus22.NetworkPolicyIpBlock The ip block this peer represents. podSelector Optional \u00b6 public PodSelectorConfig getPodSelector (); Type: org.cdk8s.plus22.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import org.cdk8s.plus22.NetworkPolicyPortProps ; NetworkPolicyPortProps . builder () // .endPort(java.lang.Number) // .port(java.lang.Number) // .protocol(NetworkProtocol) . build (); endPort Optional \u00b6 public java . lang . Number getEndPort (); Type: java.lang.Number Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: all ports are allowed. Specific port number. protocol Optional \u00b6 public NetworkProtocol getProtocol (); Type: org.cdk8s.plus22.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import org.cdk8s.plus22.NetworkPolicyProps ; NetworkPolicyProps . builder () // .metadata(ApiObjectMetadata) // .egress(NetworkPolicyTraffic) // .ingress(NetworkPolicyTraffic) // .selector(IPodSelector) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 public NetworkPolicyTraffic getEgress (); Type: org.cdk8s.plus22.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 public NetworkPolicyTraffic getIngress (); Type: org.cdk8s.plus22.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 public IPodSelector getSelector (); Type: org.cdk8s.plus22.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import org.cdk8s.plus22.NetworkPolicyRule ; NetworkPolicyRule . builder () . peer ( INetworkPolicyPeer ) // .ports(java.util.List<NetworkPolicyPort>) . build (); peer Required \u00b6 public INetworkPolicyPeer getPeer (); Type: org.cdk8s.plus22.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus22.NetworkPolicyPort > Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import org.cdk8s.plus22.NetworkPolicyTraffic ; NetworkPolicyTraffic . builder () // .default(NetworkPolicyTrafficDefault) // .rules(java.util.List<NetworkPolicyRule>) . build (); default Optional \u00b6 public NetworkPolicyTrafficDefault getDefault (); Type: org.cdk8s.plus22.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 public java . util . List < NetworkPolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.NetworkPolicyRule > Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import org.cdk8s.plus22.NodeTaintQueryOptions ; NodeTaintQueryOptions . builder () // .effect(TaintEffect) // .evictAfter(Duration) . build (); effect Optional \u00b6 public TaintEffect getEffect (); Type: org.cdk8s.plus22.TaintEffect Default: all effects are matched. The taint effect to match. evictAfter Optional \u00b6 public Duration getEvictAfter (); Type: org.cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus22.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import org.cdk8s.plus22.PersistentVolumeClaimProps ; PersistentVolumeClaimProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import org.cdk8s.plus22.PersistentVolumeClaimVolumeOptions ; PersistentVolumeClaimVolumeOptions . builder () // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.PersistentVolumeProps ; PersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import org.cdk8s.plus22.PodConnectionsAllowFromOptions ; PodConnectionsAllowFromOptions . builder () // .isolation(PodConnectionsIsolation) // .ports(java.util.List<NetworkPolicyPort>) . build (); isolation Optional \u00b6 public PodConnectionsIsolation getIsolation (); Type: org.cdk8s.plus22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus22.NetworkPolicyPort > Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import org.cdk8s.plus22.PodConnectionsAllowToOptions ; PodConnectionsAllowToOptions . builder () // .isolation(PodConnectionsIsolation) // .ports(java.util.List<NetworkPolicyPort>) . build (); isolation Optional \u00b6 public PodConnectionsIsolation getIsolation (); Type: org.cdk8s.plus22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus22.NetworkPolicyPort > Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import org.cdk8s.plus22.PodDnsProps ; PodDnsProps . builder () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus22.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import org.cdk8s.plus22.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import org.cdk8s.plus22.PodsAllOptions ; PodsAllOptions . builder () // .namespaces(Namespaces) . build (); namespaces Optional \u00b6 public Namespaces getNamespaces (); Type: org.cdk8s.plus22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import org.cdk8s.plus22.PodSchedulingAttractOptions ; PodSchedulingAttractOptions . builder () // .weight(java.lang.Number) . build (); weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import org.cdk8s.plus22.PodSchedulingColocateOptions ; PodSchedulingColocateOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus22.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import org.cdk8s.plus22.PodSchedulingSeparateOptions ; PodSchedulingSeparateOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus22.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import org.cdk8s.plus22.PodSecurityContextProps ; PodSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus22.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import org.cdk8s.plus22.PodSelectorConfig ; PodSelectorConfig . builder () . labelSelector ( LabelSelector ) // .namespaces(NamespaceSelectorConfig) . build (); labelSelector Required \u00b6 public LabelSelector getLabelSelector (); Type: org.cdk8s.plus22.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 public NamespaceSelectorConfig getNamespaces (); Type: org.cdk8s.plus22.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import org.cdk8s.plus22.PodsSelectOptions ; PodsSelectOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespaces(Namespaces) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus22.LabelExpression > Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 public Namespaces getNamespaces (); Type: org.cdk8s.plus22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus22.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus22.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import org.cdk8s.plus22.RoleBindingProps ; RoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import org.cdk8s.plus22.RolePolicyRule ; RolePolicyRule . builder () . resources ( java . util . List < IApiResource > ) . verbs ( java . util . List < java . lang . String > ) . build (); resources Required \u00b6 public java . util . List < IApiResource > getResources (); Type: java.util.List< org.cdk8s.plus22.IApiResource > Resources this rule applies to. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import org.cdk8s.plus22.RoleProps ; RoleProps . builder () // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.RolePolicyRule > Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import org.cdk8s.plus22.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus22.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus22.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import org.cdk8s.plus22.SecretVolumeOptions ; SecretVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:10097\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus22.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import org.cdk8s.plus22.ServiceAccountTokenSecretProps ; ServiceAccountTokenSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import org.cdk8s.plus22.ServiceBindOptions ; ServiceBindOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus22.ServiceIngressBackendOptions ; ServiceIngressBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus22.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import org.cdk8s.plus22.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .selector(IPodSelector) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 public IPodSelector getSelector (); Type: org.cdk8s.plus22.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import org.cdk8s.plus22.SshAuthSecretProps ; SshAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public java . lang . String getSshPrivateKey (); Type: java.lang.String The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus22.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 public Service getService (); Type: org.cdk8s.plus22.Service Service to associate with the statefulset. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus22.StatefulSetUpdateStrategyRollingUpdateOptions ; StatefulSetUpdateStrategyRollingUpdateOptions . builder () // .partition(java.lang.Number) . build (); partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import org.cdk8s.plus22.SubjectConfiguration ; SubjectConfiguration . builder () . kind ( java . lang . String ) . name ( java . lang . String ) // .apiGroup(java.lang.String) // .namespace(java.lang.String) . build (); kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import org.cdk8s.plus22.Sysctl ; Sysctl . builder () . name ( java . lang . String ) . value ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of a property to set. value Required \u00b6 public java . lang . String getValue (); Type: java.lang.String Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import org.cdk8s.plus22.TcpSocketProbeOptions ; TcpSocketProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .host(java.lang.String) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import org.cdk8s.plus22.TlsSecretProps ; TlsSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public java . lang . String getTlsCert (); Type: java.lang.String The TLS cert. tlsKey Required \u00b6 public java . lang . String getTlsKey (); Type: java.lang.String The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus22.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus22.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import org.cdk8s.plus22.WorkloadProps ; WorkloadProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import org.cdk8s.plus22.WorkloadSchedulingSpreadOptions ; WorkloadSchedulingSpreadOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus22.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus22.ApiResource ; ApiResource . custom ( ApiResourceOptions options ) options Required \u00b6 Type: org.cdk8s.plus22.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Ingress. JOBS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Job. LEASES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus22.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .envFrom(java.util.List<EnvFrom>) // .envVariables(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .portNumber(java.lang.Number) // .ports(java.util.List<ContainerPort>) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.EnvFrom > Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 Type: java.util.Map \u0002klzzwxh:9617\u0003 > Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: org.cdk8s.plus22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: java.lang.Number portNumber Optional \u00b6 Type: java.lang.Number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerPort > Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: org.cdk8s.plus22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 Type: org.cdk8s.plus22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addPort \u00b6 public addPort ( ContainerPort port ) port Required \u00b6 Type: org.cdk8s.plus22.ContainerPort mount \u00b6 public mount ( java . lang . String path , IStorage storage ) public mount ( java . lang . String path , IStorage storage , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. storage Required \u00b6 Type: org.cdk8s.plus22.IStorage The storage to mount. options Optional \u00b6 Type: org.cdk8s.plus22.MountOptions Properties \u00b6 env Required \u00b6 public Env getEnv (); Type: org.cdk8s.plus22.Env The environment of the container. image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus22.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. ports Required \u00b6 public java . util . List < ContainerPort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ContainerPort > Ports exposed by this containers. Returns a copy, use addPort to modify. securityContext Required \u00b6 public ContainerSecurityContext getSecurityContext (); Type: org.cdk8s.plus22.ContainerSecurityContext The security context of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public java . lang . Number getPort (); Type: java.lang.Number portNumber Optional \u00b6 public java . lang . Number getPortNumber (); Type: java.lang.Number The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import org.cdk8s.plus22.ContainerSecurityContext ; ContainerSecurityContext . Builder . create () // .allowPrivilegeEscalation(java.lang.Boolean) // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); allowPrivilegeEscalation Optional \u00b6 Type: java.lang.Boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: java.lang.Number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 Type: java.lang.Boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 Type: java.lang.Number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean privileged Required \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean readOnlyRootFilesystem Required \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean allowPrivilegeEscalation Optional \u00b6 public java . lang . Boolean getAllowPrivilegeEscalation (); Type: java.lang.Boolean group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import org.cdk8s.plus22.Cpu ; Cpu . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number units \u00b6 import org.cdk8s.plus22.Cpu ; Cpu . units ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Properties \u00b6 amount Required \u00b6 public java . lang . String getAmount (); Type: java.lang.String DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import org.cdk8s.plus22.DeploymentStrategy ; DeploymentStrategy . recreate () rollingUpdate \u00b6 import org.cdk8s.plus22.DeploymentStrategy ; DeploymentStrategy . rollingUpdate () DeploymentStrategy . rollingUpdate ( DeploymentStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.DeploymentStrategyRollingUpdateOptions Env \u00b6 Container environment variables. Initializers \u00b6 import org.cdk8s.plus22.Env ; new Env ( java . util . List < EnvFrom > sources , java . util . Map < java . lang . String , EnvValue > variables ); sources Required \u00b6 Type: java.util.List< org.cdk8s.plus22.EnvFrom > variables Required \u00b6 Type: java.util.Map \u0002klzzwxh:9477\u0003 > Methods \u00b6 addVariable \u00b6 public addVariable ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String value Required \u00b6 Type: org.cdk8s.plus22.EnvValue copyFrom \u00b6 public copyFrom ( EnvFrom from ) from Required \u00b6 Type: org.cdk8s.plus22.EnvFrom Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus22.Env ; Env . fromConfigMap ( IConfigMap configMap ) Env . fromConfigMap ( IConfigMap configMap , java . lang . String prefix ) configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap prefix Optional \u00b6 Type: java.lang.String fromSecret \u00b6 import org.cdk8s.plus22.Env ; Env . fromSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus22.ISecret Properties \u00b6 sources Required \u00b6 public java . util . List < EnvFrom > getSources (); Type: java.util.List< org.cdk8s.plus22.EnvFrom > The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getVariables (); Type: java.util.Map \u0002klzzwxh:9454\u0003 > The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import org.cdk8s.plus22.EnvFrom ; new EnvFrom (); new EnvFrom ( IConfigMap configMap ); new EnvFrom ( IConfigMap configMap , java . lang . String prefix ); new EnvFrom ( IConfigMap configMap , java . lang . String prefix , ISecret sec ); configMap Optional \u00b6 Type: org.cdk8s.plus22.IConfigMap prefix Optional \u00b6 Type: java.lang.String sec Optional \u00b6 Type: org.cdk8s.plus22.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromFieldRef ( EnvFieldPaths fieldPath ) EnvValue . fromFieldRef ( EnvFieldPaths fieldPath , EnvValueFromFieldRefOptions options ) fieldPath Required \u00b6 Type: org.cdk8s.plus22.EnvFieldPaths : The field reference. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromResource ( ResourceFieldPaths resource ) EnvValue . fromResource ( ResourceFieldPaths resource , EnvValueFromResourceOptions options ) resource Required \u00b6 Type: org.cdk8s.plus22.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus22.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus22.Handler ; Handler . fromCommand ( java . util . List < java . lang . String > command ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. fromHttpGet \u00b6 import org.cdk8s.plus22.Handler ; Handler . fromHttpGet ( java . lang . String path ) Handler . fromHttpGet ( java . lang . String path , HandlerFromHttpGetOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus22.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus22.Handler ; Handler . fromTcpSocket () Handler . fromTcpSocket ( HandlerFromTcpSocketOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromResource \u00b6 import org.cdk8s.plus22.IngressBackend ; IngressBackend . fromResource ( IResource resource ) resource Required \u00b6 Type: org.cdk8s.plus22.IResource fromService \u00b6 import org.cdk8s.plus22.IngressBackend ; IngressBackend . fromService ( Service serv ) IngressBackend . fromService ( Service serv , ServiceIngressBackendOptions options ) serv Required \u00b6 Type: org.cdk8s.plus22.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus22.ServiceIngressBackendOptions LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import org.cdk8s.plus22.LabeledNode ; new LabeledNode ( java . util . List < NodeLabelQuery > labelSelector ); labelSelector Required \u00b6 Type: java.util.List< org.cdk8s.plus22.NodeLabelQuery > Properties \u00b6 labelSelector Required \u00b6 public java . util . List < NodeLabelQuery > getLabelSelector (); Type: java.util.List< org.cdk8s.plus22.NodeLabelQuery > LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus22.LabelExpression ; LabelExpression . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus22.LabelExpression ; LabelExpression . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String in \u00b6 import org.cdk8s.plus22.LabelExpression ; LabelExpression . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > notIn \u00b6 import org.cdk8s.plus22.LabelExpression ; LabelExpression . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 isEmpty \u00b6 public isEmpty () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus22.LabelSelector ; LabelSelector . of () LabelSelector . of ( LabelSelectorOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.LabelSelectorOptions NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import org.cdk8s.plus22.NamedNode ; new NamedNode ( java . lang . String name ); name Required \u00b6 Type: java.lang.String Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 allTcp \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . allTcp () allUdp \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . allUdp () of \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . of ( NetworkPolicyPortProps props ) props Required \u00b6 Type: org.cdk8s.plus22.NetworkPolicyPortProps tcp \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . tcp ( java . lang . Number port ) port Required \u00b6 Type: java.lang.Number tcpRange \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . tcpRange ( java . lang . Number startPort , java . lang . Number endPort ) startPort Required \u00b6 Type: java.lang.Number endPort Required \u00b6 Type: java.lang.Number udp \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . udp ( java . lang . Number port ) port Required \u00b6 Type: java.lang.Number udpRange \u00b6 import org.cdk8s.plus22.NetworkPolicyPort ; NetworkPolicyPort . udpRange ( java . lang . Number startPort , java . lang . Number endPort ) startPort Required \u00b6 Type: java.lang.Number endPort Required \u00b6 Type: java.lang.Number Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import org.cdk8s.plus22.Node ; new Node (); Static Functions \u00b6 labeled \u00b6 import org.cdk8s.plus22.Node ; Node . labeled ( NodeLabelQuery labelSelector ) labelSelector Required \u00b6 Type: org.cdk8s.plus22.NodeLabelQuery named \u00b6 import org.cdk8s.plus22.Node ; Node . named ( java . lang . String nodeName ) nodeName Required \u00b6 Type: java.lang.String tainted \u00b6 import org.cdk8s.plus22.Node ; Node . tainted ( NodeTaintQuery taintSelector ) taintSelector Required \u00b6 Type: org.cdk8s.plus22.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String gt \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . gt ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > in \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > is \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . is ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String lt \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . lt ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > notIn \u00b6 import org.cdk8s.plus22.NodeLabelQuery ; NodeLabelQuery . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import org.cdk8s.plus22.NodeTaintQuery ; NodeTaintQuery . any () exists \u00b6 import org.cdk8s.plus22.NodeTaintQuery ; NodeTaintQuery . exists ( java . lang . String key ) NodeTaintQuery . exists ( java . lang . String key , NodeTaintQueryOptions options ) key Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.NodeTaintQueryOptions is \u00b6 import org.cdk8s.plus22.NodeTaintQuery ; NodeTaintQuery . is ( java . lang . String key , java . lang . String value ) NodeTaintQuery . is ( java . lang . String key , java . lang . String value , NodeTaintQueryOptions options ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.NodeTaintQueryOptions Properties \u00b6 operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String effect Optional \u00b6 public java . lang . String getEffect (); Type: java.lang.String evictAfter Optional \u00b6 public Duration getEvictAfter (); Type: org.cdk8s.Duration key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String NonApiResource \u00b6 Implements: org.cdk8s.plus22.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus22.NonApiResource ; NonApiResource . of ( java . lang . String url ) url Required \u00b6 Type: java.lang.String PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import org.cdk8s.plus22.PercentOrAbsolute ; PercentOrAbsolute . absolute ( java . lang . Number num ) num Required \u00b6 Type: java.lang.Number percent \u00b6 import org.cdk8s.plus22.PercentOrAbsolute ; PercentOrAbsolute . percent ( java . lang . Number percent ) percent Required \u00b6 Type: java.lang.Number Properties \u00b6 value Required \u00b6 public java . lang . Object getValue (); Type: java.lang.Object PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import org.cdk8s.plus22.PodConnections ; new PodConnections ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus22.AbstractPod Methods \u00b6 allowFrom \u00b6 public allowFrom ( INetworkPolicyPeer peer ) public allowFrom ( INetworkPolicyPeer peer , PodConnectionsAllowFromOptions options ) peer Required \u00b6 Type: org.cdk8s.plus22.INetworkPolicyPeer options Optional \u00b6 Type: org.cdk8s.plus22.PodConnectionsAllowFromOptions allowTo \u00b6 public allowTo ( INetworkPolicyPeer peer ) public allowTo ( INetworkPolicyPeer peer , PodConnectionsAllowToOptions options ) peer Required \u00b6 Type: org.cdk8s.plus22.INetworkPolicyPeer options Optional \u00b6 Type: org.cdk8s.plus22.PodConnectionsAllowToOptions PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import org.cdk8s.plus22.PodDns ; PodDns . Builder . create () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: org.cdk8s.plus22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 addNameserver \u00b6 public addNameserver ( java . lang . String nameservers ) nameservers Required \u00b6 Type: java.lang.String addOption \u00b6 public addOption ( DnsOption options ) options Required \u00b6 Type: org.cdk8s.plus22.DnsOption addSearch \u00b6 public addSearch ( java . lang . String searches ) searches Required \u00b6 Type: java.lang.String Properties \u00b6 hostnameAsFQDN Required \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > Nameservers defined for this pod. options Required \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus22.DnsOption > Custom dns options defined for this pod. policy Required \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus22.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > Search domains defined for this pod. hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import org.cdk8s.plus22.PodScheduling ; new PodScheduling ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus22.AbstractPod Methods \u00b6 assign \u00b6 public assign ( NamedNode node ) node Required \u00b6 Type: org.cdk8s.plus22.NamedNode attract \u00b6 public attract ( LabeledNode node ) public attract ( LabeledNode node , PodSchedulingAttractOptions options ) node Required \u00b6 Type: org.cdk8s.plus22.LabeledNode options Optional \u00b6 Type: org.cdk8s.plus22.PodSchedulingAttractOptions colocate \u00b6 public colocate ( IPodSelector selector ) public colocate ( IPodSelector selector , PodSchedulingColocateOptions options ) selector Required \u00b6 Type: org.cdk8s.plus22.IPodSelector options Optional \u00b6 Type: org.cdk8s.plus22.PodSchedulingColocateOptions separate \u00b6 public separate ( IPodSelector selector ) public separate ( IPodSelector selector , PodSchedulingSeparateOptions options ) selector Required \u00b6 Type: org.cdk8s.plus22.IPodSelector options Optional \u00b6 Type: org.cdk8s.plus22.PodSchedulingSeparateOptions tolerate \u00b6 public tolerate ( TaintedNode node ) node Required \u00b6 Type: org.cdk8s.plus22.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import org.cdk8s.plus22.PodSecurityContext ; PodSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 Type: org.cdk8s.plus22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean fsGroupChangePolicy Required \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus22.FsGroupChangePolicy sysctls Required \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus22.Sysctl > fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus22.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus22.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromTcpSocket () Probe . fromTcpSocket ( TcpSocketProbeOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.TcpSocketProbeOptions Options. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import org.cdk8s.plus22.ResourcePermissions ; new ResourcePermissions ( Resource instance ); instance Required \u00b6 Type: org.cdk8s.plus22.Resource Methods \u00b6 grantRead \u00b6 public grantRead ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject grantReadWrite \u00b6 public grantReadWrite ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import org.cdk8s.plus22.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import org.cdk8s.plus22.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . rollingUpdate () StatefulSetUpdateStrategy . rollingUpdate ( StatefulSetUpdateStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.StatefulSetUpdateStrategyRollingUpdateOptions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import org.cdk8s.plus22.TaintedNode ; new TaintedNode ( java . util . List < NodeTaintQuery > taintSelector ); taintSelector Required \u00b6 Type: java.util.List< org.cdk8s.plus22.NodeTaintQuery > Properties \u00b6 taintSelector Required \u00b6 public java . util . List < NodeTaintQuery > getTaintSelector (); Type: java.util.List< org.cdk8s.plus22.NodeTaintQuery > Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus22.Topology ; Topology . custom ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String Constants \u00b6 HOSTNAME \u00b6 Type: org.cdk8s.plus22.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: org.cdk8s.plus22.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: org.cdk8s.plus22.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import org.cdk8s.plus22.WorkloadScheduling ; new WorkloadScheduling ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus22.AbstractPod Methods \u00b6 spread \u00b6 public spread () public spread ( WorkloadSchedulingSpreadOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.WorkloadSchedulingSpreadOptions Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.NetworkPolicy , org.cdk8s.plus22.NonApiResource , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.NetworkPolicy , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IConfigMap \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.Namespace , org.cdk8s.plus22.Namespaces , org.cdk8s.plus22.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.Namespaces , org.cdk8s.plus22.NetworkPolicyIpBlock , org.cdk8s.plus22.Pod , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.Workload , org.cdk8s.plus22.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. IPersistentVolume \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSelector \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Pods , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IPodSelector Represents an object that can select pods. Methods \u00b6 toPodSelectorConfig \u00b6 public toPodSelectorConfig () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. IResource \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.NetworkPolicy , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IConfigMap , org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IPersistentVolumeClaim , org.cdk8s.plus22.IResource , org.cdk8s.plus22.IRole , org.cdk8s.plus22.ISecret , org.cdk8s.plus22.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IRole \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.Role , org.cdk8s.plus22.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.Secret , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.ISecret Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.IServiceAccount Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IStorage \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.Volume , org.cdk8s.plus22.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. ISubject \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Group , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.User , org.cdk8s.plus22.Workload , org.cdk8s.plus22.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. Pods that tolerate the taint without specifying duration remain bound forever. Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"Java"},{"location":"reference/cdk8s-plus-22/java/#cdk8s-plus-22-java","text":"","title":"cdk8s-plus-22 (Java) "},{"location":"reference/cdk8s-plus-22/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/java/#abstractpod","text":"Implements: org.cdk8s.plus22.IPodSelector , org.cdk8s.plus22.INetworkPolicyPeer , org.cdk8s.plus22.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-22/java/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-22/java/#clusterrole","text":"Implements: org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-22/java/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-22/java/#configmap","text":"Implements: org.cdk8s.plus22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/java/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-22/java/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-22/java/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/java/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-22/java/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#group","text":"Implements: org.cdk8s.plus22.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-22/java/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/java/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/java/#namespace","text":"Implements: org.cdk8s.plus22.INamespaceSelector , org.cdk8s.plus22.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-22/java/#namespaces","text":"Implements: org.cdk8s.plus22.INamespaceSelector , org.cdk8s.plus22.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-22/java/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-22/java/#networkpolicyipblock","text":"Implements: org.cdk8s.plus22.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-22/java/#persistentvolume","text":"Implements: org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeclaim","text":"Implements: org.cdk8s.plus22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/java/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/java/#pods","text":"Implements: org.cdk8s.plus22.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-22/java/#resource","text":"Implements: org.cdk8s.plus22.IResource , org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/java/#role","text":"Implements: org.cdk8s.plus22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-22/java/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-22/java/#secret","text":"Implements: org.cdk8s.plus22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/java/#serviceaccount","text":"Implements: org.cdk8s.plus22.IServiceAccount , org.cdk8s.plus22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/java/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-22/java/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-22/java/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/java/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-22/java/#user","text":"Implements: org.cdk8s.plus22.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-22/java/#volume","text":"Implements: org.cdk8s.plus22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/java/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-22/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/java/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-22/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/java/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-22/java/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-22/java/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-22/java/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-22/java/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-22/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-22/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-22/java/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-22/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/java/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-22/java/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-22/java/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-22/java/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-22/java/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-22/java/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-22/java/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/java/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/java/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-22/java/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-22/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/java/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-22/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/java/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-22/java/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-22/java/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-22/java/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/java/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/java/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/java/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/java/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-22/java/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-22/java/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-22/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/java/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-22/java/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-22/java/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-22/java/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-22/java/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-22/java/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-22/java/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-22/java/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-22/java/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-22/java/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-22/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-22/java/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-22/java/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-22/java/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/java/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-22/java/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-22/java/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-22/java/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-22/java/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-22/java/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-22/java/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-22/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/java/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-22/java/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-22/java/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-22/java/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/java/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/java/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-22/java/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/java/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/java/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-22/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/java/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/java/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-22/java/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-22/java/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-22/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/java/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-22/java/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-22/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/java/#apiresource","text":"Implements: org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-22/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/java/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-22/java/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-22/java/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-22/java/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-22/java/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-22/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/java/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-22/java/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/java/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-22/java/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-22/java/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-22/java/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-22/java/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-22/java/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-22/java/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-22/java/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-22/java/#nonapiresource","text":"Implements: org.cdk8s.plus22.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-22/java/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-22/java/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-22/java/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-22/java/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-22/java/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-22/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/java/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-22/java/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-22/java/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-22/java/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-22/java/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-22/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/java/#iapiendpoint","text":"Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.NetworkPolicy , org.cdk8s.plus22.NonApiResource , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-22/java/#iapiresource","text":"Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.NetworkPolicy , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-22/java/#iclusterrole","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-22/java/#iconfigmap","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/java/#inamespaceselector","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.Namespace , org.cdk8s.plus22.Namespaces , org.cdk8s.plus22.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-22/java/#inetworkpolicypeer","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.Namespaces , org.cdk8s.plus22.NetworkPolicyIpBlock , org.cdk8s.plus22.Pod , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.Workload , org.cdk8s.plus22.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-22/java/#ipersistentvolume","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#ipersistentvolumeclaim","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/java/#ipodselector","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Pods , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-22/java/#iresource","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Namespace , org.cdk8s.plus22.NetworkPolicy , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IConfigMap , org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IPersistentVolumeClaim , org.cdk8s.plus22.IResource , org.cdk8s.plus22.IRole , org.cdk8s.plus22.ISecret , org.cdk8s.plus22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/java/#irole","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.Role , org.cdk8s.plus22.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-22/java/#isecret","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.Secret , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/java/#iserviceaccount","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/java/#istorage","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.Volume , org.cdk8s.plus22.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-22/java/#isubject","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.CronJob , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Group , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.User , org.cdk8s.plus22.Workload , org.cdk8s.plus22.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-22/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-22/java/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-22/java/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-22/java/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-22/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/java/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-22/java/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-22/java/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-22/java/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/java/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-22/java/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-22/java/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-22/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/java/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-22/java/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-22/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/java/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-22/python/","text":"cdk8s-plus-22 (Python) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: cdk8s_plus_22.IPodSelector , cdk8s_plus_22.INetworkPolicyPeer , cdk8s_plus_22.ISubject Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AbstractPod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_22.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_host_alias \u00b6 def add_host_alias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 Type: str IP address of the host file entry. add_init_container \u00b6 def add_init_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_22.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( vol : Volume ) vol Required \u00b6 Type: cdk8s_plus_22.Volume to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () to_pod_selector_config \u00b6 def to_pod_selector_config () to_subject_configuration \u00b6 def to_subject_configuration () Properties \u00b6 automount_service_account_token Required \u00b6 automount_service_account_token : bool Type: bool containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] dns Required \u00b6 dns : PodDns Type: cdk8s_plus_22.PodDns host_aliases Required \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] init_containers Required \u00b6 init_containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition security_context Required \u00b6 security_context : PodSecurityContext Type: cdk8s_plus_22.PodSecurityContext volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AwsElasticBlockStorePersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. volume_id Required \u00b6 volume_id : str Type: str Volume id of this volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AzureDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azure_kind Required \u00b6 azure_kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Azure kind of this volume. caching_mode Required \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. disk_name Required \u00b6 disk_name : str Type: str Disk name of this volume. disk_uri Required \u00b6 disk_uri : str Type: str Disk URI of this volume. fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . BasicAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: str The password or token for authentication. username Required \u00b6 Type: str The user name for authentication. ClusterRole \u00b6 Implements: cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRole ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 def aggregate ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str allow \u00b6 def allow ( verbs : typing . List [ str ], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: typing.List[ str ] endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The endpoints(s) to apply to. allow_create \u00b6 def allow_create ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_get \u00b6 def allow_get ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_list \u00b6 def allow_list ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_read \u00b6 def allow_read ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_update \u00b6 def allow_update ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject a list of subjects to bind to. bind_in_namespace \u00b6 def bind_in_namespace ( namespace : str , subjects : ISubject ) namespace Required \u00b6 Type: str the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s_plus_22.ISubject a list of subjects to bind to. combine \u00b6 def combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s_plus_22.ClusterRole Static Functions \u00b6 from_cluster_role_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRole . from_cluster_role_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_22.ClusterRolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IClusterRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_22.IClusterRole The role to bind to. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_22.IClusterRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_22.ISubject ] ConfigMap \u00b6 Implements: cdk8s_plus_22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMap . from_config_map_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 immutable : bool Type: bool Whether or not this config map is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CronJob ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None , schedule : Cron , concurrency_policy : ConcurrencyPolicy = None , failed_jobs_retained : typing . Union [ int , float ] = None , starting_deadline : Duration = None , successful_jobs_retained : typing . Union [ int , float ] = None , suspend : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrency_policy Optional \u00b6 Type: cdk8s_plus_22.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failed_jobs_retained Optional \u00b6 Type: typing.Union[int, float] Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. starting_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successful_jobs_retained Optional \u00b6 Type: typing.Union[int, float] Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 Type: bool Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. Properties \u00b6 concurrency_policy Required \u00b6 concurrency_policy : str Type: str The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failed_jobs_retained Required \u00b6 failed_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] The number of failed jobs retained by this cron job. resource_type Required \u00b6 resource_type : str Type: str Represents the resource type. schedule Required \u00b6 schedule : Cron Type: cdk8s.Cron The schedule this cron job is scheduled to run in. starting_deadline Required \u00b6 starting_deadline : Duration Type: cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successful_jobs_retained Required \u00b6 successful_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] The number of successful jobs retained by this cron job. suspend Required \u00b6 suspend : bool Type: bool Whether or not the cron job is currently suspended or not. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DaemonSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready_seconds Optional \u00b6 Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 min_ready_seconds Required \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: typing.Union[int, float] Default: 2 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. expose_via_service \u00b6 def expose_via_service ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None ) name Optional \u00b6 Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progress_deadline Required \u00b6 progress_deadline : Duration Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_22.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DockerConfigSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GCEPersistentDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. pd_name Required \u00b6 pd_name : str Type: str PD resource in GCE of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. Group \u00b6 Implements: cdk8s_plus_22.ISubject Represents a group. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Group . from_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 kind Required \u00b6 kind : str Type: str name Required \u00b6 name : str Type: str api_group Optional \u00b6 api_group : str Type: str Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Ingress ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_22.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressBackend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType How the path is matched against request paths. add_rule \u00b6 def add_rule ( path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType How the path is matched against request paths. add_rules \u00b6 def add_rules ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types add_tls \u00b6 def add_tls ( tls : typing . List [ IngressTls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_22.IngressTls ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: cdk8s_plus_22.INamespaceSelector , cdk8s_plus_22.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Namespace ( scope : Construct , id : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: str https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: cdk8s_plus_22.INamespaceSelector , cdk8s_plus_22.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Namespaces ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , names : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_22.LabelExpression ] names Optional \u00b6 Type: typing.List[ str ] labels Optional \u00b6 Type: typing.Mapping[ str ] Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Static Functions \u00b6 all \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Namespaces . all ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str select \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Namespaces . select ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , names : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_22.LabelExpression ] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 Type: typing.List[ str ] Default: no name requirements. Namespaces names must be one of these. NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicy ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , egress : NetworkPolicyTraffic = None , ingress : NetworkPolicyTraffic = None , selector : IPodSelector = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 Type: cdk8s_plus_22.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 Type: cdk8s_plus_22.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 Type: cdk8s_plus_22.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that Methods \u00b6 add_egress_rule \u00b6 def add_egress_rule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_22.INetworkPolicyPeer ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] add_ingress_rule \u00b6 def add_ingress_rule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_22.INetworkPolicyPeer ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: cdk8s_plus_22.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Static Functions \u00b6 any_ipv4 \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyIpBlock . any_ipv4 ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str any_ipv6 \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyIpBlock . any_ipv6 ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str ipv4 \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyIpBlock . ipv4 ( scope : Construct , id : str , cidr_ip : str , except : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str cidr_ip Required \u00b6 Type: str except Optional \u00b6 Type: typing.List[ str ] ipv6 \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyIpBlock . ipv6 ( scope : Construct , id : str , cidr_ip : str , except : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str cidr_ip Required \u00b6 Type: str except Optional \u00b6 Type: typing.List[ str ] Properties \u00b6 cidr Required \u00b6 cidr : str Type: str A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 except : typing . List [ str ] Type: typing.List[ str ] A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 as_volume \u00b6 def as_volume () bind \u00b6 def bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 def reserve () Static Functions \u00b6 from_persistent_volume_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolume . from_persistent_volume_name ( scope : Construct , id : str , volume_name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str volume_name Required \u00b6 Type: str Properties \u00b6 mode Required \u00b6 mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Volume mode of this volume. reclaim_policy Required \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Access modes requirement of this claim. claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Mount options of this volume. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage size of this volume. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s_plus_22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaim ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 def bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s_plus_22.IPersistentVolume The PV to bind to. Static Functions \u00b6 from_claim_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaim . from_claim_name ( scope : Construct , id : str , claim_name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str claim_name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. volume_mode Required \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Volume mode requirement of this claim. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Access modes requirement of this claim. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage requirement of this claim. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class requirment of this claim. volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_22.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 connections Required \u00b6 connections : PodConnections Type: cdk8s_plus_22.PodConnections pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 scheduling : PodScheduling Type: cdk8s_plus_22.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: str This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: cdk8s_plus_22.IPodSelector Represents a group of pods. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Pods ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : INamespaceSelector = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_22.LabelExpression ] labels Optional \u00b6 Type: typing.Mapping[ str ] namespaces Optional \u00b6 Type: cdk8s_plus_22.INamespaceSelector Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () to_pod_selector_config \u00b6 def to_pod_selector_config () Static Functions \u00b6 all \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Pods . all ( scope : Construct , id : str , namespaces : Namespaces = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str namespaces Optional \u00b6 Type: cdk8s_plus_22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. select \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Pods . select ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : Namespaces = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_22.LabelExpression ] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 Type: cdk8s_plus_22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. Resource \u00b6 Implements: cdk8s_plus_22.IResource , cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Resource ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. permissions Required \u00b6 permissions : ResourcePermissions Type: cdk8s_plus_22.ResourcePermissions resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s_plus_22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Role ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.RolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 def allow ( verbs : typing . List [ str ], resources : IApiResource ) verbs Required \u00b6 Type: typing.List[ str ] resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_create \u00b6 def allow_create ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_get \u00b6 def allow_get ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_list \u00b6 def allow_list ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_read \u00b6 def allow_read ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_update \u00b6 def allow_update ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject a list of subjects to bind to. Static Functions \u00b6 from_role_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Role . from_role_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_22.RolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IRole Type: cdk8s_plus_22.IRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_22.ISubject ] Secret \u00b6 Implements: cdk8s_plus_22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Secret . from_secret_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 immutable Required \u00b6 immutable : bool Type: bool Whether or not the secret is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , selector : IPodSelector = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ServicePort ] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 Type: cdk8s_plus_22.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 bind \u00b6 def bind ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. select \u00b6 def select ( selector : IPodSelector ) selector Required \u00b6 Type: cdk8s_plus_22.IPodSelector select_label \u00b6 def select_label ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] Ports for this service. Use bind() to bind additional service ports. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 type : ServiceType Type: cdk8s_plus_22.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_22.IServiceAccount , cdk8s_plus_22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 Type: bool Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_22.ISecret The secret. to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccount . from_service_account_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 automount_token Required \u00b6 automount_token : bool Type: bool Whether or not a token is automatically mounted for this service account. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountTokenSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 Type: cdk8s_plus_22.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SshAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 Type: str The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 Type: cdk8s_plus_22.Service Service to associate with the statefulset. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 Type: cdk8s_plus_22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_22.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_22.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TlsSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 Type: str The TLS cert. tls_key Required \u00b6 Type: str The TLS key. User \u00b6 Implements: cdk8s_plus_22.ISubject Represents a user. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . User . from_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 kind Required \u00b6 kind : str Type: str name Required \u00b6 name : str Type: str api_group Optional \u00b6 api_group : str Type: str Volume \u00b6 Implements: cdk8s_plus_22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 as_volume \u00b6 def as_volume () Static Functions \u00b6 from_aws_elastic_block_store \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_aws_elastic_block_store ( scope : Construct , id : str , volume_id : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str volume_id Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_azure_disk \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_azure_disk ( scope : Construct , id : str , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str disk_name Required \u00b6 Type: str disk_uri Required \u00b6 Type: str caching_mode Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 Type: str Default: auto-generated The volume name. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_config_map ( scope : Construct , id : str , config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_empty_dir ( scope : Construct , id : str , name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. from_gce_persistent_disk \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_gce_persistent_disk ( scope : Construct , id : str , pd_name : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str pd_name Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_host_path \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_host_path ( scope : Construct , id : str , name : str , path : str , type : HostPathVolumeType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str path Required \u00b6 Type: str The path of the directory on the host. type Optional \u00b6 Type: cdk8s_plus_22.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. from_persistent_volume_claim \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_persistent_volume_claim ( scope : Construct , id : str , claim : IPersistentVolumeClaim , name : str = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str claim Required \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim name Optional \u00b6 Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. from_secret \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_secret ( scope : Construct , id : str , secr : ISecret , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str secr Required \u00b6 Type: cdk8s_plus_22.ISecret The secret to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the secret or its keys must be defined. Properties \u00b6 name Required \u00b6 name : str Type: str Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Workload ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints Methods \u00b6 select \u00b6 def select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s_plus_22.LabelSelector Properties \u00b6 connections Required \u00b6 connections : PodConnections Type: cdk8s_plus_22.PodConnections match_expressions Required \u00b6 match_expressions : typing . List [ LabelSelectorRequirement ] Type: typing.List[ cdk8s_plus_22.LabelSelectorRequirement ] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. match_labels Required \u00b6 match_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 scheduling : WorkloadScheduling Type: cdk8s_plus_22.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AbstractPodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ApiResourceOptions ( api_group : str , resource_type : str ) api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AwsElasticBlockStorePersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 volume_id : str Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AwsElasticBlockStoreVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AzureDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 disk_name : str Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 disk_uri : str Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AzureDiskVolumeOptions ( caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . BasicAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 password : str Type: str The password or token for authentication. username Required \u00b6 username : str Type: str The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRoleBindingProps ( metadata : ApiObjectMetadata = None , role : IClusterRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_22.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRolePolicyRule ( endpoints : typing . List [ IApiEndpoint ], verbs : typing . List [ str ] ) endpoints Required \u00b6 endpoints : typing . List [ IApiEndpoint ] Type: typing.List[ cdk8s_plus_22.IApiEndpoint ] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRoleProps ( metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 aggregation_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_22.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CommonSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerLifecycle ( post_start : Handler = None , pre_stop : Handler = None ) post_start Optional \u00b6 post_start : Handler Type: cdk8s_plus_22.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. pre_stop Optional \u00b6 pre_stop : Handler Type: cdk8s_plus_22.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerPort ( number : typing . Union [ int , float ], host_ip : str = None , host_port : typing . Union [ int , float ] = None , name : str = None , protocol : Protocol = None ) number Required \u00b6 number : typing . Union [ int , float ] Type: typing.Union[int, float] Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. host_ip Optional \u00b6 host_ip : str Type: str Default: 127.0.0.1. What host IP to bind the external port to. host_port Optional \u00b6 host_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 name : str Type: str Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 env_from : typing . List [ EnvFrom ] Type: typing.List[ cdk8s_plus_22.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 env_variables : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 lifecycle : ContainerLifecycle Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . port : typing . Union [ int , float ] Type: typing.Union[int, float] port_number Optional \u00b6 port_number : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 ports : typing . List [ ContainerPort ] Type: typing.List[ cdk8s_plus_22.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 security_context : ContainerSecurityContextProps Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 startup : Probe Type: cdk8s_plus_22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerResources ( cpu : CpuResources = None , ephemeral_storage : EphemeralStorageResources = None , memory : MemoryResources = None ) cpu Optional \u00b6 cpu : CpuResources Type: cdk8s_plus_22.CpuResources ephemeral_storage Optional \u00b6 ephemeral_storage : EphemeralStorageResources Type: cdk8s_plus_22.EphemeralStorageResources memory Optional \u00b6 memory : MemoryResources Type: cdk8s_plus_22.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerSecurityContextProps ( allow_privilege_escalation : bool = None , ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) allow_privilege_escalation Optional \u00b6 allow_privilege_escalation : bool Type: bool Default: false Whether a process can gain more privileges than its parent process. ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 privileged : bool Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 read_only_root_filesystem : bool Type: bool Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CpuResources ( limit : Cpu = None , request : Cpu = None ) limit Optional \u00b6 limit : Cpu Type: cdk8s_plus_22.Cpu request Optional \u00b6 request : Cpu Type: cdk8s_plus_22.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CronJobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None , schedule : Cron , concurrency_policy : ConcurrencyPolicy = None , failed_jobs_retained : typing . Union [ int , float ] = None , starting_deadline : Duration = None , successful_jobs_retained : typing . Union [ int , float ] = None , suspend : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 schedule : Cron Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrency_policy Optional \u00b6 concurrency_policy : ConcurrencyPolicy Type: cdk8s_plus_22.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failed_jobs_retained Optional \u00b6 failed_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. starting_deadline Optional \u00b6 starting_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successful_jobs_retained Optional \u00b6 successful_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 suspend : bool Type: bool Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DaemonSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready_seconds Optional \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentExposeViaServiceOptions ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None ) name Optional \u00b6 name : str Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 progress_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 2 Number of desired pods. strategy Optional \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentStrategyRollingUpdateOptions ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 max_surge : PercentOrAbsolute Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 max_unavailable : PercentOrAbsolute Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DnsOption ( name : str , value : str = None ) name Required \u00b6 name : str Type: str Option name. value Optional \u00b6 value : str Type: str Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DockerConfigSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 data : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromFieldRefOptions ( api_version : str = None , key : str = None ) api_version Optional \u00b6 api_version : str Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 key : str Type: str The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromResourceOptions ( container : Container = None , divisor : str = None ) container Optional \u00b6 container : Container Type: cdk8s_plus_22.Container The container to select the value from. divisor Optional \u00b6 divisor : str Type: str The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EphemeralStorageResources ( limit : Size = None , request : Size = None ) limit Optional \u00b6 limit : Size Type: cdk8s.Size request Optional \u00b6 request : Size Type: cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeDeploymentViaIngressOptions ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) name Optional \u00b6 name : str Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeServiceViaIngressOptions ( ingress : Ingress = None , path_type : HttpIngressPathType = None ) ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GCEPersistentDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 pd_name : str Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GCEPersistentDiskVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HandlerFromHttpGetOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HandlerFromTcpSocketOptions ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HostAlias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 hostnames : typing . List [ str ] Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 ip : str Type: str IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HostPathVolumeOptions ( path : str , type : HostPathVolumeType = None ) path Required \u00b6 path : str Type: str The path of the directory on the host. type Optional \u00b6 type : HostPathVolumeType Type: cdk8s_plus_22.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None , scheme : ConnectionScheme = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 scheme : ConnectionScheme Type: cdk8s_plus_22.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressProps ( metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressBackend Type: cdk8s_plus_22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressRule ] Type: typing.List[ cdk8s_plus_22.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressTls ] Type: typing.List[ cdk8s_plus_22.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressRule ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 backend : IngressBackend Type: cdk8s_plus_22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressTls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . JobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelectorOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_22.LabelExpression ] Expression based label matchers. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelectorRequirement ( key : str , operator : str , values : typing . List [ str ] = None ) key Required \u00b6 key : str Type: str The label key that the selector applies to. operator Required \u00b6 operator : str Type: str Represents a key\u2019s relationship to a set of values. values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . MemoryResources ( limit : Size = None , request : Size = None ) limit Optional \u00b6 limit : Size Type: cdk8s.Size request Optional \u00b6 request : Size Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NamespaceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NamespaceSelectorConfig ( label_selector : LabelSelector = None , names : typing . List [ str ] = None ) label_selector Optional \u00b6 label_selector : LabelSelector Type: cdk8s_plus_22.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 names : typing . List [ str ] Type: typing.List[ str ] A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NamespacesSelectOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , names : typing . List [ str ] = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_22.LabelExpression ] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 names : typing . List [ str ] Type: typing.List[ str ] Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyAddEgressRuleOptions ( ports : typing . List [ NetworkPolicyPort ] = None ) ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPeerConfig ( ip_block : NetworkPolicyIpBlock = None , pod_selector : PodSelectorConfig = None ) ip_block Optional \u00b6 ip_block : NetworkPolicyIpBlock Type: cdk8s_plus_22.NetworkPolicyIpBlock The ip block this peer represents. pod_selector Optional \u00b6 pod_selector : PodSelectorConfig Type: cdk8s_plus_22.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPortProps ( end_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None , protocol : NetworkProtocol = None ) end_port Optional \u00b6 end_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: all ports are allowed. Specific port number. protocol Optional \u00b6 protocol : NetworkProtocol Type: cdk8s_plus_22.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyProps ( metadata : ApiObjectMetadata = None , egress : NetworkPolicyTraffic = None , ingress : NetworkPolicyTraffic = None , selector : IPodSelector = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 egress : NetworkPolicyTraffic Type: cdk8s_plus_22.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 ingress : NetworkPolicyTraffic Type: cdk8s_plus_22.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 selector : IPodSelector Type: cdk8s_plus_22.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyRule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 peer : INetworkPolicyPeer Type: cdk8s_plus_22.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyTraffic ( default : NetworkPolicyTrafficDefault = None , rules : typing . List [ NetworkPolicyRule ] = None ) default Optional \u00b6 default : NetworkPolicyTrafficDefault Type: cdk8s_plus_22.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 rules : typing . List [ NetworkPolicyRule ] Type: typing.List[ cdk8s_plus_22.NetworkPolicyRule ] Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeTaintQueryOptions ( effect : TaintEffect = None , evict_after : Duration = None ) effect Optional \u00b6 effect : TaintEffect Type: cdk8s_plus_22.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 evict_after : Duration Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaimProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaimVolumeOptions ( name : str = None , read_only : bool = None ) name Optional \u00b6 name : str Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodConnectionsAllowFromOptions ( isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) isolation Optional \u00b6 isolation : PodConnectionsIsolation Type: cdk8s_plus_22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodConnectionsAllowToOptions ( isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) isolation Optional \u00b6 isolation : PodConnectionsIsolation Type: cdk8s_plus_22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodDnsProps ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 hostname : str Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 hostname_as_fqd_n : bool Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_22.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 policy : DnsPolicy Type: cdk8s_plus_22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 subdomain : str Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodsAllOptions ( namespaces : Namespaces = None ) namespaces Optional \u00b6 namespaces : Namespaces Type: cdk8s_plus_22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSchedulingAttractOptions ( weight : typing . Union [ int , float ] = None ) weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSchedulingColocateOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_22.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSchedulingSeparateOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_22.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSecurityContextProps ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_22.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSelectorConfig ( label_selector : LabelSelector , namespaces : NamespaceSelectorConfig = None ) label_selector Required \u00b6 label_selector : LabelSelector Type: cdk8s_plus_22.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 namespaces : NamespaceSelectorConfig Type: cdk8s_plus_22.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodsSelectOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : Namespaces = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_22.LabelExpression ] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 namespaces : Namespaces Type: cdk8s_plus_22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RoleBindingProps ( metadata : ApiObjectMetadata = None , role : IRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IRole Type: cdk8s_plus_22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RolePolicyRule ( resources : typing . List [ IApiResource ], verbs : typing . List [ str ] ) resources Required \u00b6 resources : typing . List [ IApiResource ] Type: typing.List[ cdk8s_plus_22.IApiResource ] Resources this rule applies to. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RoleProps ( metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_22.RolePolicyRule ] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_22.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 automount_token : bool Type: bool Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountTokenSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceBindOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceIngressBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , selector : IPodSelector = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 selector : IPodSelector Type: cdk8s_plus_22.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SshAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 ssh_private_key : str Type: str The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 service : Service Type: cdk8s_plus_22.Service Service to associate with the statefulset. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetUpdateStrategyRollingUpdateOptions ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SubjectConfiguration ( kind : str , name : str , api_group : str = None , namespace : str = None ) kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 namespace : str Type: str Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Sysctl ( name : str , value : str ) name Required \u00b6 name : str Type: str Name of a property to set. value Required \u00b6 value : str Type: str Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TcpSocketProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TlsSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 tls_cert : str Type: str The TLS cert. tls_key Required \u00b6 tls_key : str Type: str The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_22.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . WorkloadProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . WorkloadSchedulingSpreadOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_22.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Represents information about an API resource type. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 custom \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ApiResource . custom ( api_group : str , resource_type : str ) api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_22.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_port \u00b6 def add_port ( number : typing . Union [ int , float ], host_ip : str = None , host_port : typing . Union [ int , float ] = None , name : str = None , protocol : Protocol = None ) number Required \u00b6 Type: typing.Union[int, float] Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. host_ip Optional \u00b6 Type: str Default: 127.0.0.1. What host IP to bind the external port to. host_port Optional \u00b6 Type: typing.Union[int, float] Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 Type: str Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. mount \u00b6 def mount ( path : str , storage : IStorage , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. storage Required \u00b6 Type: cdk8s_plus_22.IStorage The storage to mount. propagation Optional \u00b6 Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. Properties \u00b6 env Required \u00b6 env : Env Type: cdk8s_plus_22.Env The environment of the container. image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_22.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. ports Required \u00b6 ports : typing . List [ ContainerPort ] Type: typing.List[ cdk8s_plus_22.ContainerPort ] Ports exposed by this containers. Returns a copy, use addPort to modify. security_context Required \u00b6 security_context : ContainerSecurityContext Type: cdk8s_plus_22.ContainerSecurityContext The security context of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . port : typing . Union [ int , float ] Type: typing.Union[int, float] port_number Optional \u00b6 port_number : typing . Union [ int , float ] Type: typing.Union[int, float] The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerSecurityContext ( allow_privilege_escalation : bool = None , ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) allow_privilege_escalation Optional \u00b6 Type: bool Default: false Whether a process can gain more privileges than its parent process. ensure_non_root Optional \u00b6 Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: typing.Union[int, float] Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 Type: bool Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 Type: typing.Union[int, float] Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool privileged Required \u00b6 privileged : bool Type: bool read_only_root_filesystem Required \u00b6 read_only_root_filesystem : bool Type: bool allow_privilege_escalation Optional \u00b6 allow_privilege_escalation : bool Type: bool group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Cpu . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] units \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Cpu . units ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 amount Required \u00b6 amount : str Type: str DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentStrategy . recreate () rolling_update \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentStrategy . rolling_update ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. Env \u00b6 Container environment variables. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Env ( sources : typing . List [ EnvFrom ], variables : typing . Mapping [ EnvValue ] ) sources Required \u00b6 Type: typing.List[ cdk8s_plus_22.EnvFrom ] variables Required \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Methods \u00b6 add_variable \u00b6 def add_variable ( name : str , value : EnvValue ) name Required \u00b6 Type: str value Required \u00b6 Type: cdk8s_plus_22.EnvValue copy_from \u00b6 def copy_from ( from : EnvFrom ) from Required \u00b6 Type: cdk8s_plus_22.EnvFrom Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Env . from_config_map ( config_map : IConfigMap , prefix : str = None ) config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap prefix Optional \u00b6 Type: str from_secret \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Env . from_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_22.ISecret Properties \u00b6 sources Required \u00b6 sources : typing . List [ EnvFrom ] Type: typing.List[ cdk8s_plus_22.EnvFrom ] The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 variables : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvFrom ( config_map : IConfigMap = None , prefix : str = None , sec : ISecret = None ) config_map Optional \u00b6 Type: cdk8s_plus_22.IConfigMap prefix Optional \u00b6 Type: str sec Optional \u00b6 Type: cdk8s_plus_22.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_field_ref \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_field_ref ( field_path : EnvFieldPaths , api_version : str = None , key : str = None ) field_path Required \u00b6 Type: cdk8s_plus_22.EnvFieldPaths : The field reference. api_version Optional \u00b6 Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 Type: str The key to select the pod label or annotation. from_process \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_resource \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_resource ( resource : ResourceFieldPaths , container : Container = None , divisor : str = None ) resource Required \u00b6 Type: cdk8s_plus_22.ResourceFieldPaths : Resource to select the value from. container Optional \u00b6 Type: cdk8s_plus_22.Container The container to select the value from. divisor Optional \u00b6 Type: str The output format of the exposed resource. from_secret_value \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_22.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Handler . from_command ( command : typing . List [ str ] ) command Required \u00b6 Type: typing.List[ str ] The command to execute. from_http_get \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Handler . from_http_get ( path : str , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Handler . from_tcp_socket ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_resource \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressBackend . from_resource ( resource : IResource ) resource Required \u00b6 Type: cdk8s_plus_22.IResource from_service \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressBackend . from_service ( serv : Service , port : typing . Union [ int , float ] = None ) serv Required \u00b6 Type: cdk8s_plus_22.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabeledNode ( label_selector : typing . List [ NodeLabelQuery ] ) label_selector Required \u00b6 Type: typing.List[ cdk8s_plus_22.NodeLabelQuery ] Properties \u00b6 label_selector Required \u00b6 label_selector : typing . List [ NodeLabelQuery ] Type: typing.List[ cdk8s_plus_22.NodeLabelQuery ] LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelExpression . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelExpression . exists ( key : str ) key Required \u00b6 Type: str in \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelExpression . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] not_in \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelExpression . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 key Required \u00b6 key : str Type: str operator Required \u00b6 operator : str Type: str values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 is_empty \u00b6 def is_empty () Static Functions \u00b6 of \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelector . of ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None ) expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_22.LabelExpression ] Expression based label matchers. labels Optional \u00b6 Type: typing.Mapping[ str ] Strict label matchers. NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NamedNode ( name : str ) name Required \u00b6 Type: str Properties \u00b6 name Required \u00b6 name : str Type: str NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 all_tcp \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . all_tcp () all_udp \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . all_udp () of \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . of ( end_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None , protocol : NetworkProtocol = None ) end_port Optional \u00b6 Type: typing.Union[int, float] Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 Type: typing.Union[int, float] Default: all ports are allowed. Specific port number. protocol Optional \u00b6 Type: cdk8s_plus_22.NetworkProtocol Default: NetworkProtocol.TCP Protocol. tcp \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . tcp ( port : typing . Union [ int , float ] ) port Required \u00b6 Type: typing.Union[int, float] tcp_range \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . tcp_range ( start_port : typing . Union [ int , float ], end_port : typing . Union [ int , float ] ) start_port Required \u00b6 Type: typing.Union[int, float] end_port Required \u00b6 Type: typing.Union[int, float] udp \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . udp ( port : typing . Union [ int , float ] ) port Required \u00b6 Type: typing.Union[int, float] udp_range \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NetworkPolicyPort . udp_range ( start_port : typing . Union [ int , float ], end_port : typing . Union [ int , float ] ) start_port Required \u00b6 Type: typing.Union[int, float] end_port Required \u00b6 Type: typing.Union[int, float] Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Node () Static Functions \u00b6 labeled \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Node . labeled ( label_selector : NodeLabelQuery ) label_selector Required \u00b6 Type: cdk8s_plus_22.NodeLabelQuery named \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Node . named ( node_name : str ) node_name Required \u00b6 Type: str tainted \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Node . tainted ( taint_selector : NodeTaintQuery ) taint_selector Required \u00b6 Type: cdk8s_plus_22.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . exists ( key : str ) key Required \u00b6 Type: str gt \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . gt ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] in \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] is \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . is ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str lt \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . lt ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] not_in \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeLabelQuery . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 key Required \u00b6 key : str Type: str operator Required \u00b6 operator : str Type: str values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeTaintQuery . any () exists \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeTaintQuery . exists ( key : str , effect : TaintEffect = None , evict_after : Duration = None ) key Required \u00b6 Type: str effect Optional \u00b6 Type: cdk8s_plus_22.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. is \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NodeTaintQuery . is ( key : str , value : str , effect : TaintEffect = None , evict_after : Duration = None ) key Required \u00b6 Type: str value Required \u00b6 Type: str effect Optional \u00b6 Type: cdk8s_plus_22.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. Properties \u00b6 operator Required \u00b6 operator : str Type: str effect Optional \u00b6 effect : str Type: str evict_after Optional \u00b6 evict_after : Duration Type: cdk8s.Duration key Optional \u00b6 key : str Type: str value Optional \u00b6 value : str Type: str NonApiResource \u00b6 Implements: cdk8s_plus_22.IApiEndpoint Factory for creating non api resources. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 of \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NonApiResource . of ( url : str ) url Required \u00b6 Type: str PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 is_zero \u00b6 def is_zero () Static Functions \u00b6 absolute \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PercentOrAbsolute . absolute ( num : typing . Union [ int , float ] ) num Required \u00b6 Type: typing.Union[int, float] percent \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PercentOrAbsolute . percent ( percent : typing . Union [ int , float ] ) percent Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 value Required \u00b6 value : typing . Any Type: typing.Any PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodConnections ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_22.AbstractPod Methods \u00b6 allow_from \u00b6 def allow_from ( peer : INetworkPolicyPeer , isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_22.INetworkPolicyPeer isolation Optional \u00b6 Type: cdk8s_plus_22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Default: The pod ports. Ports to allow incoming traffic to. allow_to \u00b6 def allow_to ( peer : INetworkPolicyPeer , isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_22.INetworkPolicyPeer isolation Optional \u00b6 Type: cdk8s_plus_22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodDns ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: typing.List[ cdk8s_plus_22.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: cdk8s_plus_22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 add_nameserver \u00b6 def add_nameserver ( nameservers : str ) nameservers Required \u00b6 Type: str add_option \u00b6 def add_option ( name : str , value : str = None ) name Required \u00b6 Type: str Option name. value Optional \u00b6 Type: str Default: No value. Option value. add_search \u00b6 def add_search ( searches : str ) searches Required \u00b6 Type: str Properties \u00b6 hostname_as_fqd_n Required \u00b6 hostname_as_fqd_n : bool Type: bool Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] Nameservers defined for this pod. options Required \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_22.DnsOption ] Custom dns options defined for this pod. policy Required \u00b6 policy : DnsPolicy Type: cdk8s_plus_22.DnsPolicy The DNS policy of this pod. searches Required \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] Search domains defined for this pod. hostname Optional \u00b6 hostname : str Type: str The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 subdomain : str Type: str The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_22.AbstractPod Methods \u00b6 assign \u00b6 def assign ( node : NamedNode ) node Required \u00b6 Type: cdk8s_plus_22.NamedNode attract \u00b6 def attract ( node : LabeledNode , weight : typing . Union [ int , float ] = None ) node Required \u00b6 Type: cdk8s_plus_22.LabeledNode weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. colocate \u00b6 def colocate ( selector : IPodSelector , topology : Topology = None , weight : typing . Union [ int , float ] = None ) selector Required \u00b6 Type: cdk8s_plus_22.IPodSelector topology Optional \u00b6 Type: cdk8s_plus_22.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. separate \u00b6 def separate ( selector : IPodSelector , topology : Topology = None , weight : typing . Union [ int , float ] = None ) selector Required \u00b6 Type: cdk8s_plus_22.IPodSelector topology Optional \u00b6 Type: cdk8s_plus_22.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. tolerate \u00b6 def tolerate ( node : TaintedNode ) node Required \u00b6 Type: cdk8s_plus_22.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSecurityContext ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 Type: cdk8s_plus_22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool fs_group_change_policy Required \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_22.FsGroupChangePolicy sysctls Required \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_22.Sysctl ] fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None , scheme : ConnectionScheme = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 Type: cdk8s_plus_22.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). from_tcp_socket \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_tcp_socket ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ResourcePermissions ( instance : Resource ) instance Required \u00b6 Type: cdk8s_plus_22.Resource Methods \u00b6 grant_read \u00b6 def grant_read ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject grant_read_write \u00b6 def grant_read_write ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 on_delete \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetUpdateStrategy . on_delete () rolling_update \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetUpdateStrategy . rolling_update ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TaintedNode ( taint_selector : typing . List [ NodeTaintQuery ] ) taint_selector Required \u00b6 Type: typing.List[ cdk8s_plus_22.NodeTaintQuery ] Properties \u00b6 taint_selector Required \u00b6 taint_selector : typing . List [ NodeTaintQuery ] Type: typing.List[ cdk8s_plus_22.NodeTaintQuery ] Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Topology . custom ( key : str ) key Required \u00b6 Type: str Properties \u00b6 key Required \u00b6 key : str Type: str Constants \u00b6 HOSTNAME \u00b6 Type: cdk8s_plus_22.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: cdk8s_plus_22.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: cdk8s_plus_22.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . WorkloadScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_22.AbstractPod Methods \u00b6 spread \u00b6 def spread ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 Type: cdk8s_plus_22.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.NetworkPolicy , cdk8s_plus_22.NonApiResource , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () IApiResource \u00b6 Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.NetworkPolicy , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiResource Represents a resource or collection of resources. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.Namespace , cdk8s_plus_22.Namespaces , cdk8s_plus_22.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.Namespaces , cdk8s_plus_22.NetworkPolicyIpBlock , cdk8s_plus_22.Pod , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.Workload , cdk8s_plus_22.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. IPersistentVolume \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.Pods , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.Workload , cdk8s_plus_22.IPodSelector Represents an object that can select pods. Methods \u00b6 to_pod_selector_config \u00b6 def to_pod_selector_config () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. IResource \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.NetworkPolicy , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IConfigMap , cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IPersistentVolumeClaim , cdk8s_plus_22.IResource , cdk8s_plus_22.IRole , cdk8s_plus_22.ISecret , cdk8s_plus_22.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.Role , cdk8s_plus_22.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.Secret , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.ISecret Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.IServiceAccount Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IStorage \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.Volume , cdk8s_plus_22.IStorage Represents a piece of storage in the cluster. Methods \u00b6 as_volume \u00b6 def as_volume () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. ISubject \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.Group , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.User , cdk8s_plus_22.Workload , cdk8s_plus_22.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. Pods that tolerate the taint without specifying duration remain bound forever. Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"Python"},{"location":"reference/cdk8s-plus-22/python/#cdk8s-plus-22-python","text":"","title":"cdk8s-plus-22 (Python) "},{"location":"reference/cdk8s-plus-22/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/python/#abstractpod","text":"Implements: cdk8s_plus_22.IPodSelector , cdk8s_plus_22.INetworkPolicyPeer , cdk8s_plus_22.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-22/python/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-22/python/#clusterrole","text":"Implements: cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-22/python/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-22/python/#configmap","text":"Implements: cdk8s_plus_22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/python/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-22/python/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-22/python/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/python/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-22/python/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#group","text":"Implements: cdk8s_plus_22.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-22/python/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/python/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/python/#namespace","text":"Implements: cdk8s_plus_22.INamespaceSelector , cdk8s_plus_22.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-22/python/#namespaces","text":"Implements: cdk8s_plus_22.INamespaceSelector , cdk8s_plus_22.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-22/python/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-22/python/#networkpolicyipblock","text":"Implements: cdk8s_plus_22.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-22/python/#persistentvolume","text":"Implements: cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeclaim","text":"Implements: cdk8s_plus_22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/python/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/python/#pods","text":"Implements: cdk8s_plus_22.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-22/python/#resource","text":"Implements: cdk8s_plus_22.IResource , cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/python/#role","text":"Implements: cdk8s_plus_22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-22/python/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-22/python/#secret","text":"Implements: cdk8s_plus_22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/python/#serviceaccount","text":"Implements: cdk8s_plus_22.IServiceAccount , cdk8s_plus_22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/python/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-22/python/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-22/python/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/python/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-22/python/#user","text":"Implements: cdk8s_plus_22.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-22/python/#volume","text":"Implements: cdk8s_plus_22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/python/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-22/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/python/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-22/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/python/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-22/python/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-22/python/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-22/python/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-22/python/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-22/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-22/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-22/python/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-22/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/python/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-22/python/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-22/python/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-22/python/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-22/python/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-22/python/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-22/python/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/python/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/python/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-22/python/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-22/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/python/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-22/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/python/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-22/python/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-22/python/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-22/python/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/python/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/python/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/python/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/python/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-22/python/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-22/python/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-22/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/python/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-22/python/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-22/python/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-22/python/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-22/python/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-22/python/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-22/python/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-22/python/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-22/python/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-22/python/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-22/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-22/python/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-22/python/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-22/python/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/python/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-22/python/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-22/python/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-22/python/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-22/python/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-22/python/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-22/python/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-22/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/python/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-22/python/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-22/python/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-22/python/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/python/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/python/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-22/python/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/python/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/python/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-22/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/python/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/python/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-22/python/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-22/python/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-22/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/python/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-22/python/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-22/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/python/#apiresource","text":"Implements: cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-22/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/python/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-22/python/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-22/python/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-22/python/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-22/python/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-22/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/python/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-22/python/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/python/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-22/python/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-22/python/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-22/python/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-22/python/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-22/python/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-22/python/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-22/python/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-22/python/#nonapiresource","text":"Implements: cdk8s_plus_22.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-22/python/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-22/python/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-22/python/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-22/python/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-22/python/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-22/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/python/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-22/python/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-22/python/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-22/python/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-22/python/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-22/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/python/#iapiendpoint","text":"Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.NetworkPolicy , cdk8s_plus_22.NonApiResource , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-22/python/#iapiresource","text":"Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.NetworkPolicy , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-22/python/#iclusterrole","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-22/python/#iconfigmap","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/python/#inamespaceselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.Namespace , cdk8s_plus_22.Namespaces , cdk8s_plus_22.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-22/python/#inetworkpolicypeer","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.Namespaces , cdk8s_plus_22.NetworkPolicyIpBlock , cdk8s_plus_22.Pod , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.Workload , cdk8s_plus_22.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-22/python/#ipersistentvolume","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#ipersistentvolumeclaim","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/python/#ipodselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.Pods , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.Workload , cdk8s_plus_22.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-22/python/#iresource","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Namespace , cdk8s_plus_22.NetworkPolicy , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IConfigMap , cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IPersistentVolumeClaim , cdk8s_plus_22.IResource , cdk8s_plus_22.IRole , cdk8s_plus_22.ISecret , cdk8s_plus_22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/python/#irole","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.Role , cdk8s_plus_22.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-22/python/#isecret","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.Secret , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/python/#iserviceaccount","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/python/#istorage","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.Volume , cdk8s_plus_22.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-22/python/#isubject","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.CronJob , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.Group , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.User , cdk8s_plus_22.Workload , cdk8s_plus_22.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-22/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-22/python/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-22/python/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-22/python/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-22/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/python/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-22/python/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-22/python/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-22/python/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/python/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-22/python/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-22/python/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-22/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/python/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-22/python/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-22/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/python/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-22/typescript/","text":"cdk8s-plus-22 (TypeScript) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: cdk8s-plus-22.IPodSelector , cdk8s-plus-22.INetworkPolicyPeer , cdk8s-plus-22.ISubject Initializers \u00b6 import { AbstractPod } from 'cdk8s-plus-22' new AbstractPod ( scope : Construct , id : string , props? : AbstractPodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.AbstractPodProps Methods \u00b6 addContainer \u00b6 public addContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-22.ContainerProps addHostAlias \u00b6 public addHostAlias ( hostAlias : HostAlias ) hostAlias Required \u00b6 Type: cdk8s-plus-22.HostAlias addInitContainer \u00b6 public addInitContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( vol : Volume ) vol Required \u00b6 Type: cdk8s-plus-22.Volume toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 automountServiceAccountToken Required \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] dns Required \u00b6 public readonly dns : PodDns ; Type: cdk8s-plus-22.PodDns hostAliases Required \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] initContainers Required \u00b6 public readonly initContainers : Container []; Type: cdk8s-plus-22.Container [] podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition securityContext Required \u00b6 public readonly securityContext : PodSecurityContext ; Type: cdk8s-plus-22.PodSecurityContext volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import { AwsElasticBlockStorePersistentVolume } from 'cdk8s-plus-22' new AwsElasticBlockStorePersistentVolume ( scope : Construct , id : string , props : AwsElasticBlockStorePersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.AwsElasticBlockStorePersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Volume id of this volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import { AzureDiskPersistentVolume } from 'cdk8s-plus-22' new AzureDiskPersistentVolume ( scope : Construct , id : string , props : AzureDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.AzureDiskPersistentVolumeProps Properties \u00b6 azureKind Required \u00b6 public readonly azureKind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public readonly diskName : string ; Type: string Disk name of this volume. diskUri Required \u00b6 public readonly diskUri : string ; Type: string Disk URI of this volume. fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import { BasicAuthSecret } from 'cdk8s-plus-22' new BasicAuthSecret ( scope : Construct , id : string , props : BasicAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.BasicAuthSecretProps ClusterRole \u00b6 Implements: cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import { ClusterRole } from 'cdk8s-plus-22' new ClusterRole ( scope : Construct , id : string , props? : ClusterRoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ClusterRoleProps Methods \u00b6 aggregate \u00b6 public aggregate ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string allow \u00b6 public allow ( verbs : string [], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: string [] endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( namespace : string , subjects : ISubject ) namespace Required \u00b6 Type: string the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s-plus-22.ISubject a list of subjects to bind to. combine \u00b6 public combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s-plus-22.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import { ClusterRole } from 'cdk8s-plus-22' ClusterRole . fromClusterRoleName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-22.ClusterRolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import { ClusterRoleBinding } from 'cdk8s-plus-22' new ClusterRoleBinding ( scope : Construct , id : string , props : ClusterRoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.ClusterRoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-22.IClusterRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-22.ISubject [] ConfigMap \u00b6 Implements: cdk8s-plus-22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-22' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-22.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-22' ConfigMap . fromConfigMapName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not this config map is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import { CronJob } from 'cdk8s-plus-22' new CronJob ( scope : Construct , id : string , props : CronJobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.CronJobProps Properties \u00b6 concurrencyPolicy Required \u00b6 public readonly concurrencyPolicy : string ; Type: string The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failedJobsRetained Required \u00b6 public readonly failedJobsRetained : number ; Type: number The number of failed jobs retained by this cron job. resourceType Required \u00b6 public readonly resourceType : string ; Type: string Represents the resource type. schedule Required \u00b6 public readonly schedule : Cron ; Type: cdk8s.Cron The schedule this cron job is scheduled to run in. startingDeadline Required \u00b6 public readonly startingDeadline : Duration ; Type: cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successfulJobsRetained Required \u00b6 public readonly successfulJobsRetained : number ; Type: number The number of successful jobs retained by this cron job. suspend Required \u00b6 public readonly suspend : boolean ; Type: boolean Whether or not the cron job is currently suspended or not. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import { DaemonSet } from 'cdk8s-plus-22' new DaemonSet ( scope : Construct , id : string , props? : DaemonSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.DaemonSetProps Properties \u00b6 minReadySeconds Required \u00b6 public readonly minReadySeconds : number ; Type: number resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-22' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.DeploymentProps Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-22.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : DeploymentExposeViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-22.DeploymentExposeViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-22.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import { DockerConfigSecret } from 'cdk8s-plus-22' new DockerConfigSecret ( scope : Construct , id : string , props : DockerConfigSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.DockerConfigSecretProps GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import { GCEPersistentDiskPersistentVolume } from 'cdk8s-plus-22' new GCEPersistentDiskPersistentVolume ( scope : Construct , id : string , props : GCEPersistentDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.GCEPersistentDiskPersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. pdName Required \u00b6 public readonly pdName : string ; Type: string PD resource in GCE of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. Group \u00b6 Implements: cdk8s-plus-22.ISubject Represents a group. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import { Group } from 'cdk8s-plus-22' Group . fromName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string name Required \u00b6 public readonly name : string ; Type: string apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { Ingress } from 'cdk8s-plus-22' new Ingress ( scope : Construct , id : string , props? : IngressProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.IngressProps Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressBackend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-22.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-22.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( rules : IngressRule ) rules Required \u00b6 Type: cdk8s-plus-22.IngressRule The rules to add. addTls \u00b6 public addTls ( tls : IngressTls []) tls Required \u00b6 Type: cdk8s-plus-22.IngressTls [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-22' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.JobProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: cdk8s-plus-22.INamespaceSelector , cdk8s-plus-22.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import { Namespace } from 'cdk8s-plus-22' new Namespace ( scope : Construct , id : string , props? : NamespaceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.NamespaceProps Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: string https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: cdk8s-plus-22.INamespaceSelector , cdk8s-plus-22.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import { Namespaces } from 'cdk8s-plus-22' new Namespaces ( scope : Construct , id : string , expressions? : LabelExpression [], names? : string [], labels ?: {[ key : string ] : string }) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string expressions Optional \u00b6 Type: cdk8s-plus-22.LabelExpression [] names Optional \u00b6 Type: string [] labels Optional \u00b6 Type: {[ key: string ]: string } Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 all \u00b6 import { Namespaces } from 'cdk8s-plus-22' Namespaces . all ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string select \u00b6 import { Namespaces } from 'cdk8s-plus-22' Namespaces . select ( scope : Construct , id : string , options : NamespacesSelectOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-22.NamespacesSelectOptions NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import { NetworkPolicy } from 'cdk8s-plus-22' new NetworkPolicy ( scope : Construct , id : string , props? : NetworkPolicyProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.NetworkPolicyProps Methods \u00b6 addEgressRule \u00b6 public addEgressRule ( peer : INetworkPolicyPeer , ports? : NetworkPolicyPort []) peer Required \u00b6 Type: cdk8s-plus-22.INetworkPolicyPeer ports Optional \u00b6 Type: cdk8s-plus-22.NetworkPolicyPort [] addIngressRule \u00b6 public addIngressRule ( peer : INetworkPolicyPeer , ports? : NetworkPolicyPort []) peer Required \u00b6 Type: cdk8s-plus-22.INetworkPolicyPeer ports Optional \u00b6 Type: cdk8s-plus-22.NetworkPolicyPort [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: cdk8s-plus-22.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 anyIpv4 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-22' NetworkPolicyIpBlock . anyIpv4 ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string anyIpv6 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-22' NetworkPolicyIpBlock . anyIpv6 ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string ipv4 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-22' NetworkPolicyIpBlock . ipv4 ( scope : Construct , id : string , cidrIp : string , except? : string []) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string cidrIp Required \u00b6 Type: string except Optional \u00b6 Type: string [] ipv6 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-22' NetworkPolicyIpBlock . ipv6 ( scope : Construct , id : string , cidrIp : string , except? : string []) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string cidrIp Required \u00b6 Type: string except Optional \u00b6 Type: string [] Properties \u00b6 cidr Required \u00b6 public readonly cidr : string ; Type: string A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 public readonly except : string []; Type: string [] A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import { PersistentVolume } from 'cdk8s-plus-22' new PersistentVolume ( scope : Construct , id : string , props? : PersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PersistentVolumeProps Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s-plus-22.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import { PersistentVolume } from 'cdk8s-plus-22' PersistentVolume . fromPersistentVolumeName ( scope : Construct , id : string , volumeName : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string volumeName Required \u00b6 Type: string Properties \u00b6 mode Required \u00b6 public readonly mode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Access modes requirement of this claim. claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Mount options of this volume. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s-plus-22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-22' new PersistentVolumeClaim ( scope : Construct , id : string , props? : PersistentVolumeClaimProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PersistentVolumeClaimProps Methods \u00b6 bind \u00b6 public bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s-plus-22.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-22' PersistentVolumeClaim . fromClaimName ( scope : Construct , id : string , claimName : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string claimName Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Access modes requirement of this claim. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class requirment of this claim. volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-22.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-22' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PodProps Properties \u00b6 connections Required \u00b6 public readonly connections : PodConnections ; Type: cdk8s-plus-22.PodConnections podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 public readonly scheduling : PodScheduling ; Type: cdk8s-plus-22.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: string This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: cdk8s-plus-22.IPodSelector Represents a group of pods. Initializers \u00b6 import { Pods } from 'cdk8s-plus-22' new Pods ( scope : Construct , id : string , expressions? : LabelExpression [], labels ?: {[ key : string ] : string }, namespaces? : INamespaceSelector ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string expressions Optional \u00b6 Type: cdk8s-plus-22.LabelExpression [] labels Optional \u00b6 Type: {[ key: string ]: string } namespaces Optional \u00b6 Type: cdk8s-plus-22.INamespaceSelector Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () Static Functions \u00b6 all \u00b6 import { Pods } from 'cdk8s-plus-22' Pods . all ( scope : Construct , id : string , options? : PodsAllOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.PodsAllOptions select \u00b6 import { Pods } from 'cdk8s-plus-22' Pods . select ( scope : Construct , id : string , options : PodsSelectOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-22.PodsSelectOptions Resource \u00b6 Implements: cdk8s-plus-22.IResource , cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-22' new Resource ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. permissions Required \u00b6 public readonly permissions : ResourcePermissions ; Type: cdk8s-plus-22.ResourcePermissions resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s-plus-22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import { Role } from 'cdk8s-plus-22' new Role ( scope : Construct , id : string , props? : RoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.RoleProps Methods \u00b6 allow \u00b6 public allow ( verbs : string [], resources : IApiResource ) verbs Required \u00b6 Type: string [] resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import { Role } from 'cdk8s-plus-22' Role . fromRoleName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-22.RolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import { RoleBinding } from 'cdk8s-plus-22' new RoleBinding ( scope : Construct , id : string , props : RoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.RoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-22.IRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-22.ISubject [] Secret \u00b6 Implements: cdk8s-plus-22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-22' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-22' Secret . fromSecretName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not the secret is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-22' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ServiceProps Methods \u00b6 bind \u00b6 public bind ( port : number , options? : ServiceBindOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-22.ServiceBindOptions exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-22.ExposeServiceViaIngressOptions Additional options. select \u00b6 public select ( selector : IPodSelector ) selector Required \u00b6 Type: cdk8s-plus-22.IPodSelector selectLabel \u00b6 public selectLabel ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] Ports for this service. Use bind() to bind additional service ports. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-22.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-22.IServiceAccount , cdk8s-plus-22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-22' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-22.ISecret The secret. toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-22' ServiceAccount . fromServiceAccountName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public readonly automountToken : boolean ; Type: boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-22.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import { ServiceAccountTokenSecret } from 'cdk8s-plus-22' new ServiceAccountTokenSecret ( scope : Construct , id : string , props : ServiceAccountTokenSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.ServiceAccountTokenSecretProps SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import { SshAuthSecret } from 'cdk8s-plus-22' new SshAuthSecret ( scope : Construct , id : string , props : SshAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.SshAuthSecretProps StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-22' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.StatefulSetProps Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-22.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-22.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import { TlsSecret } from 'cdk8s-plus-22' new TlsSecret ( scope : Construct , id : string , props : TlsSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.TlsSecretProps User \u00b6 Implements: cdk8s-plus-22.ISubject Represents a user. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import { User } from 'cdk8s-plus-22' User . fromName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string name Required \u00b6 public readonly name : string ; Type: string apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string Volume \u00b6 Implements: cdk8s-plus-22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromAwsElasticBlockStore ( scope : Construct , id : string , volumeId : string , options? : AwsElasticBlockStoreVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string volumeId Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromAzureDisk ( scope : Construct , id : string , diskName : string , diskUri : string , options? : AzureDiskVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string diskName Required \u00b6 Type: string diskUri Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.AzureDiskVolumeOptions fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromConfigMap ( scope : Construct , id : string , configMap : IConfigMap , options? : ConfigMapVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-22.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromEmptyDir ( scope : Construct , id : string , name : string , options? : EmptyDirVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromGcePersistentDisk ( scope : Construct , id : string , pdName : string , options? : GCEPersistentDiskVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string pdName Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.GCEPersistentDiskVolumeOptions fromHostPath \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromHostPath ( scope : Construct , id : string , name : string , options : HostPathVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-22.HostPathVolumeOptions fromPersistentVolumeClaim \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromPersistentVolumeClaim ( scope : Construct , id : string , claim : IPersistentVolumeClaim , options? : PersistentVolumeClaimVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string claim Required \u00b6 Type: cdk8s-plus-22.IPersistentVolumeClaim options Optional \u00b6 Type: cdk8s-plus-22.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromSecret ( scope : Construct , id : string , secr : ISecret , options? : SecretVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string secr Required \u00b6 Type: cdk8s-plus-22.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-22.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import { Workload } from 'cdk8s-plus-22' new Workload ( scope : Construct , id : string , props? : WorkloadProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.WorkloadProps Methods \u00b6 select \u00b6 public select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s-plus-22.LabelSelector Properties \u00b6 connections Required \u00b6 public readonly connections : PodConnections ; Type: cdk8s-plus-22.PodConnections matchExpressions Required \u00b6 public readonly matchExpressions : LabelSelectorRequirement []; Type: cdk8s-plus-22.LabelSelectorRequirement [] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public readonly matchLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 public readonly scheduling : WorkloadScheduling ; Type: cdk8s-plus-22.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import { AbstractPodProps } from 'cdk8s-plus-22' const abstractPodProps : AbstractPodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-22' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-22' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import { ApiResourceOptions } from 'cdk8s-plus-22' const apiResourceOptions : ApiResourceOptions = { ... } apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import { AwsElasticBlockStorePersistentVolumeProps } from 'cdk8s-plus-22' const awsElasticBlockStorePersistentVolumeProps : AwsElasticBlockStorePersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import { AwsElasticBlockStoreVolumeOptions } from 'cdk8s-plus-22' const awsElasticBlockStoreVolumeOptions : AwsElasticBlockStoreVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import { AzureDiskPersistentVolumeProps } from 'cdk8s-plus-22' const azureDiskPersistentVolumeProps : AzureDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public readonly diskName : string ; Type: string The Name of the data disk in the blob storage. diskUri Required \u00b6 public readonly diskUri : string ; Type: string The URI the data disk in the blob storage. cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import { AzureDiskVolumeOptions } from 'cdk8s-plus-22' const azureDiskVolumeOptions : AzureDiskVolumeOptions = { ... } cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import { BasicAuthSecretProps } from 'cdk8s-plus-22' const basicAuthSecretProps : BasicAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public readonly password : string ; Type: string The password or token for authentication. username Required \u00b6 public readonly username : string ; Type: string The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import { ClusterRoleBindingProps } from 'cdk8s-plus-22' const clusterRoleBindingProps : ClusterRoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-22.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import { ClusterRolePolicyRule } from 'cdk8s-plus-22' const clusterRolePolicyRule : ClusterRolePolicyRule = { ... } endpoints Required \u00b6 public readonly endpoints : IApiEndpoint []; Type: cdk8s-plus-22.IApiEndpoint [] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import { ClusterRoleProps } from 'cdk8s-plus-22' const clusterRoleProps : ClusterRoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public readonly aggregationLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-22.ClusterRolePolicyRule [] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-22' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import { CommonSecretProps } from 'cdk8s-plus-22' const commonSecretProps : CommonSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-22' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-22' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-22.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import { ContainerLifecycle } from 'cdk8s-plus-22' const containerLifecycle : ContainerLifecycle = { ... } postStart Optional \u00b6 public readonly postStart : Handler ; Type: cdk8s-plus-22.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public readonly preStop : Handler ; Type: cdk8s-plus-22.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import { ContainerPort } from 'cdk8s-plus-22' const containerPort : ContainerPort = { ... } number Required \u00b6 public readonly number : number ; Type: number Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. hostIp Optional \u00b6 public readonly hostIp : string ; Type: string Default: 127.0.0.1. What host IP to bind the external port to. hostPort Optional \u00b6 public readonly hostPort : number ; Type: number Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 public readonly name : string ; Type: string Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-22' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 public readonly envFrom : EnvFrom []; Type: cdk8s-plus-22.EnvFrom [] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 public readonly envVariables : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-22.EnvValue } Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public readonly lifecycle : ContainerLifecycle ; Type: cdk8s-plus-22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public readonly port : number ; Type: number portNumber Optional \u00b6 public readonly portNumber : number ; Type: number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 public readonly ports : ContainerPort []; Type: cdk8s-plus-22.ContainerPort [] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-22.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public readonly securityContext : ContainerSecurityContextProps ; Type: cdk8s-plus-22.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-22.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-22.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import { ContainerResources } from 'cdk8s-plus-22' const containerResources : ContainerResources = { ... } cpu Optional \u00b6 public readonly cpu : CpuResources ; Type: cdk8s-plus-22.CpuResources ephemeralStorage Optional \u00b6 public readonly ephemeralStorage : EphemeralStorageResources ; Type: cdk8s-plus-22.EphemeralStorageResources memory Optional \u00b6 public readonly memory : MemoryResources ; Type: cdk8s-plus-22.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import { ContainerSecurityContextProps } from 'cdk8s-plus-22' const containerSecurityContextProps : ContainerSecurityContextProps = { ... } allowPrivilegeEscalation Optional \u00b6 public readonly allowPrivilegeEscalation : boolean ; Type: boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public readonly group : number ; Type: number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 public readonly privileged : boolean ; Type: boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 public readonly user : number ; Type: number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import { CpuResources } from 'cdk8s-plus-22' const cpuResources : CpuResources = { ... } limit Optional \u00b6 public readonly limit : Cpu ; Type: cdk8s-plus-22.Cpu request Optional \u00b6 public readonly request : Cpu ; Type: cdk8s-plus-22.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import { CronJobProps } from 'cdk8s-plus-22' const cronJobProps : CronJobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 public readonly schedule : Cron ; Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 public readonly concurrencyPolicy : ConcurrencyPolicy ; Type: cdk8s-plus-22.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 public readonly failedJobsRetained : number ; Type: number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 public readonly startingDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 public readonly successfulJobsRetained : number ; Type: number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 public readonly suspend : boolean ; Type: boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import { DaemonSetProps } from 'cdk8s-plus-22' const daemonSetProps : DaemonSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 public readonly minReadySeconds : number ; Type: number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import { DeploymentExposeViaServiceOptions } from 'cdk8s-plus-22' const deploymentExposeViaServiceOptions : DeploymentExposeViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-22' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 2 Number of desired pods. strategy Optional \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import { DeploymentStrategyRollingUpdateOptions } from 'cdk8s-plus-22' const deploymentStrategyRollingUpdateOptions : DeploymentStrategyRollingUpdateOptions = { ... } maxSurge Optional \u00b6 public readonly maxSurge : PercentOrAbsolute ; Type: cdk8s-plus-22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public readonly maxUnavailable : PercentOrAbsolute ; Type: cdk8s-plus-22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import { DnsOption } from 'cdk8s-plus-22' const dnsOption : DnsOption = { ... } name Required \u00b6 public readonly name : string ; Type: string Option name. value Optional \u00b6 public readonly value : string ; Type: string Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import { DockerConfigSecretProps } from 'cdk8s-plus-22' const dockerConfigSecretProps : DockerConfigSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public readonly data : {[ key : string ] : any }; Type: {[ key: string ]: any } JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-22' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-22' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import { EnvValueFromFieldRefOptions } from 'cdk8s-plus-22' const envValueFromFieldRefOptions : EnvValueFromFieldRefOptions = { ... } apiVersion Optional \u00b6 public readonly apiVersion : string ; Type: string Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public readonly key : string ; Type: string The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-22' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import { EnvValueFromResourceOptions } from 'cdk8s-plus-22' const envValueFromResourceOptions : EnvValueFromResourceOptions = { ... } container Optional \u00b6 public readonly container : Container ; Type: cdk8s-plus-22.Container The container to select the value from. divisor Optional \u00b6 public readonly divisor : string ; Type: string The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-22' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import { EphemeralStorageResources } from 'cdk8s-plus-22' const ephemeralStorageResources : EphemeralStorageResources = { ... } limit Optional \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Optional \u00b6 public readonly request : Size ; Type: cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-22' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-22' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import { GCEPersistentDiskPersistentVolumeProps } from 'cdk8s-plus-22' const gCEPersistentDiskPersistentVolumeProps : GCEPersistentDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public readonly pdName : string ; Type: string Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import { GCEPersistentDiskVolumeOptions } from 'cdk8s-plus-22' const gCEPersistentDiskVolumeOptions : GCEPersistentDiskVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import { HandlerFromHttpGetOptions } from 'cdk8s-plus-22' const handlerFromHttpGetOptions : HandlerFromHttpGetOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import { HandlerFromTcpSocketOptions } from 'cdk8s-plus-22' const handlerFromTcpSocketOptions : HandlerFromTcpSocketOptions = { ... } host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import { HostAlias } from 'cdk8s-plus-22' const hostAlias : HostAlias = { ... } hostnames Required \u00b6 public readonly hostnames : string []; Type: string [] Hostnames for the chosen IP address. ip Required \u00b6 public readonly ip : string ; Type: string IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import { HostPathVolumeOptions } from 'cdk8s-plus-22' const hostPathVolumeOptions : HostPathVolumeOptions = { ... } path Required \u00b6 public readonly path : string ; Type: string The path of the directory on the host. type Optional \u00b6 public readonly type : HostPathVolumeType ; Type: cdk8s-plus-22.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-22' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 public readonly scheme : ConnectionScheme ; Type: cdk8s-plus-22.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressProps } from 'cdk8s-plus-22' const ingressProps : IngressProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressBackend ; Type: cdk8s-plus-22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressRule []; Type: cdk8s-plus-22.IngressRule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressTls []; Type: cdk8s-plus-22.IngressTls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressRule } from 'cdk8s-plus-22' const ingressRule : IngressRule = { ... } backend Required \u00b6 public readonly backend : IngressBackend ; Type: cdk8s-plus-22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressTls } from 'cdk8s-plus-22' const ingressTls : IngressTls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-22' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import { LabelSelectorOptions } from 'cdk8s-plus-22' const labelSelectorOptions : LabelSelectorOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-22.LabelExpression [] Expression based label matchers. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import { LabelSelectorRequirement } from 'cdk8s-plus-22' const labelSelectorRequirement : LabelSelectorRequirement = { ... } key Required \u00b6 public readonly key : string ; Type: string The label key that the selector applies to. operator Required \u00b6 public readonly operator : string ; Type: string Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public readonly values : string []; Type: string [] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import { MemoryResources } from 'cdk8s-plus-22' const memoryResources : MemoryResources = { ... } limit Optional \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Optional \u00b6 public readonly request : Size ; Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-22' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import { NamespaceProps } from 'cdk8s-plus-22' const namespaceProps : NamespaceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import { NamespaceSelectorConfig } from 'cdk8s-plus-22' const namespaceSelectorConfig : NamespaceSelectorConfig = { ... } labelSelector Optional \u00b6 public readonly labelSelector : LabelSelector ; Type: cdk8s-plus-22.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 public readonly names : string []; Type: string [] A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import { NamespacesSelectOptions } from 'cdk8s-plus-22' const namespacesSelectOptions : NamespacesSelectOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-22.LabelExpression [] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 public readonly names : string []; Type: string [] Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import { NetworkPolicyAddEgressRuleOptions } from 'cdk8s-plus-22' const networkPolicyAddEgressRuleOptions : NetworkPolicyAddEgressRuleOptions = { ... } ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-22.NetworkPolicyPort [] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import { NetworkPolicyPeerConfig } from 'cdk8s-plus-22' const networkPolicyPeerConfig : NetworkPolicyPeerConfig = { ... } ipBlock Optional \u00b6 public readonly ipBlock : NetworkPolicyIpBlock ; Type: cdk8s-plus-22.NetworkPolicyIpBlock The ip block this peer represents. podSelector Optional \u00b6 public readonly podSelector : PodSelectorConfig ; Type: cdk8s-plus-22.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import { NetworkPolicyPortProps } from 'cdk8s-plus-22' const networkPolicyPortProps : NetworkPolicyPortProps = { ... } endPort Optional \u00b6 public readonly endPort : number ; Type: number Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 public readonly port : number ; Type: number Default: all ports are allowed. Specific port number. protocol Optional \u00b6 public readonly protocol : NetworkProtocol ; Type: cdk8s-plus-22.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import { NetworkPolicyProps } from 'cdk8s-plus-22' const networkPolicyProps : NetworkPolicyProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 public readonly egress : NetworkPolicyTraffic ; Type: cdk8s-plus-22.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 public readonly ingress : NetworkPolicyTraffic ; Type: cdk8s-plus-22.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 public readonly selector : IPodSelector ; Type: cdk8s-plus-22.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import { NetworkPolicyRule } from 'cdk8s-plus-22' const networkPolicyRule : NetworkPolicyRule = { ... } peer Required \u00b6 public readonly peer : INetworkPolicyPeer ; Type: cdk8s-plus-22.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-22.NetworkPolicyPort [] Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import { NetworkPolicyTraffic } from 'cdk8s-plus-22' const networkPolicyTraffic : NetworkPolicyTraffic = { ... } default Optional \u00b6 public readonly default : NetworkPolicyTrafficDefault ; Type: cdk8s-plus-22.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 public readonly rules : NetworkPolicyRule []; Type: cdk8s-plus-22.NetworkPolicyRule [] Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import { NodeTaintQueryOptions } from 'cdk8s-plus-22' const nodeTaintQueryOptions : NodeTaintQueryOptions = { ... } effect Optional \u00b6 public readonly effect : TaintEffect ; Type: cdk8s-plus-22.TaintEffect Default: all effects are matched. The taint effect to match. evictAfter Optional \u00b6 public readonly evictAfter : Duration ; Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-22' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import { PersistentVolumeClaimProps } from 'cdk8s-plus-22' const persistentVolumeClaimProps : PersistentVolumeClaimProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. - If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import { PersistentVolumeClaimVolumeOptions } from 'cdk8s-plus-22' const persistentVolumeClaimVolumeOptions : PersistentVolumeClaimVolumeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import { PersistentVolumeProps } from 'cdk8s-plus-22' const persistentVolumeProps : PersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import { PodConnectionsAllowFromOptions } from 'cdk8s-plus-22' const podConnectionsAllowFromOptions : PodConnectionsAllowFromOptions = { ... } isolation Optional \u00b6 public readonly isolation : PodConnectionsIsolation ; Type: cdk8s-plus-22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-22.NetworkPolicyPort [] Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import { PodConnectionsAllowToOptions } from 'cdk8s-plus-22' const podConnectionsAllowToOptions : PodConnectionsAllowToOptions = { ... } isolation Optional \u00b6 public readonly isolation : PodConnectionsIsolation ; Type: cdk8s-plus-22.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-22.NetworkPolicyPort [] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import { PodDnsProps } from 'cdk8s-plus-22' const podDnsProps : PodDnsProps = { ... } hostname Optional \u00b6 public readonly hostname : string ; Type: string Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public readonly nameservers : string []; Type: string [] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-22.DnsOption [] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public readonly searches : string []; Type: string [] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-22' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import { PodsAllOptions } from 'cdk8s-plus-22' const podsAllOptions : PodsAllOptions = { ... } namespaces Optional \u00b6 public readonly namespaces : Namespaces ; Type: cdk8s-plus-22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import { PodSchedulingAttractOptions } from 'cdk8s-plus-22' const podSchedulingAttractOptions : PodSchedulingAttractOptions = { ... } weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import { PodSchedulingColocateOptions } from 'cdk8s-plus-22' const podSchedulingColocateOptions : PodSchedulingColocateOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-22.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import { PodSchedulingSeparateOptions } from 'cdk8s-plus-22' const podSchedulingSeparateOptions : PodSchedulingSeparateOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-22.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import { PodSecurityContextProps } from 'cdk8s-plus-22' const podSecurityContextProps : PodSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-22.Sysctl [] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import { PodSelectorConfig } from 'cdk8s-plus-22' const podSelectorConfig : PodSelectorConfig = { ... } labelSelector Required \u00b6 public readonly labelSelector : LabelSelector ; Type: cdk8s-plus-22.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 public readonly namespaces : NamespaceSelectorConfig ; Type: cdk8s-plus-22.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import { PodsSelectOptions } from 'cdk8s-plus-22' const podsSelectOptions : PodsSelectOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-22.LabelExpression [] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 public readonly namespaces : Namespaces ; Type: cdk8s-plus-22.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-22' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-22' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import { RoleBindingProps } from 'cdk8s-plus-22' const roleBindingProps : RoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import { RolePolicyRule } from 'cdk8s-plus-22' const rolePolicyRule : RolePolicyRule = { ... } resources Required \u00b6 public readonly resources : IApiResource []; Type: cdk8s-plus-22.IApiResource [] Resources this rule applies to. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import { RoleProps } from 'cdk8s-plus-22' const roleProps : RoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-22.RolePolicyRule [] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-22' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-22' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-22.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import { SecretVolumeOptions } from 'cdk8s-plus-22' const secretVolumeOptions : SecretVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-22.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-22' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public readonly automountToken : boolean ; Type: boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-22.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import { ServiceAccountTokenSecretProps } from 'cdk8s-plus-22' const serviceAccountTokenSecretProps : ServiceAccountTokenSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import { ServiceBindOptions } from 'cdk8s-plus-22' const serviceBindOptions : ServiceBindOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressBackendOptions } from 'cdk8s-plus-22' const serviceIngressBackendOptions : ServiceIngressBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-22' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-22' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 public readonly selector : IPodSelector ; Type: cdk8s-plus-22.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import { SshAuthSecretProps } from 'cdk8s-plus-22' const sshAuthSecretProps : SshAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public readonly sshPrivateKey : string ; Type: string The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-22' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-22.Service Service to associate with the statefulset. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import { StatefulSetUpdateStrategyRollingUpdateOptions } from 'cdk8s-plus-22' const statefulSetUpdateStrategyRollingUpdateOptions : StatefulSetUpdateStrategyRollingUpdateOptions = { ... } partition Optional \u00b6 public readonly partition : number ; Type: number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import { SubjectConfiguration } from 'cdk8s-plus-22' const subjectConfiguration : SubjectConfiguration = { ... } kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public readonly namespace : string ; Type: string Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import { Sysctl } from 'cdk8s-plus-22' const sysctl : Sysctl = { ... } name Required \u00b6 public readonly name : string ; Type: string Name of a property to set. value Required \u00b6 public readonly value : string ; Type: string Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import { TcpSocketProbeOptions } from 'cdk8s-plus-22' const tcpSocketProbeOptions : TcpSocketProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import { TlsSecretProps } from 'cdk8s-plus-22' const tlsSecretProps : TlsSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public readonly tlsCert : string ; Type: string The TLS cert. tlsKey Required \u00b6 public readonly tlsKey : string ; Type: string The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-22' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-22.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import { WorkloadProps } from 'cdk8s-plus-22' const workloadProps : WorkloadProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import { WorkloadSchedulingSpreadOptions } from 'cdk8s-plus-22' const workloadSchedulingSpreadOptions : WorkloadSchedulingSpreadOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-22.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import { ApiResource } from 'cdk8s-plus-22' ApiResource . custom ( options : ApiResourceOptions ) options Required \u00b6 Type: cdk8s-plus-22.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-22' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-22.ContainerProps Methods \u00b6 addPort \u00b6 public addPort ( port : ContainerPort ) port Required \u00b6 Type: cdk8s-plus-22.ContainerPort mount \u00b6 public mount ( path : string , storage : IStorage , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. storage Required \u00b6 Type: cdk8s-plus-22.IStorage The storage to mount. options Optional \u00b6 Type: cdk8s-plus-22.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : Env ; Type: cdk8s-plus-22.Env The environment of the container. image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-22.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. ports Required \u00b6 public readonly ports : ContainerPort []; Type: cdk8s-plus-22.ContainerPort [] Ports exposed by this containers. Returns a copy, use addPort to modify. securityContext Required \u00b6 public readonly securityContext : ContainerSecurityContext ; Type: cdk8s-plus-22.ContainerSecurityContext The security context of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public readonly port : number ; Type: number portNumber Optional \u00b6 public readonly portNumber : number ; Type: number The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import { ContainerSecurityContext } from 'cdk8s-plus-22' new ContainerSecurityContext ( props? : ContainerSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-22.ContainerSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean privileged Required \u00b6 public readonly privileged : boolean ; Type: boolean readOnlyRootFilesystem Required \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean allowPrivilegeEscalation Optional \u00b6 public readonly allowPrivilegeEscalation : boolean ; Type: boolean group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import { Cpu } from 'cdk8s-plus-22' Cpu . millis ( amount : number ) amount Required \u00b6 Type: number units \u00b6 import { Cpu } from 'cdk8s-plus-22' Cpu . units ( amount : number ) amount Required \u00b6 Type: number Properties \u00b6 amount Required \u00b6 public readonly amount : string ; Type: string DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-22' DeploymentStrategy . recreate () rollingUpdate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-22' DeploymentStrategy . rollingUpdate ( options? : DeploymentStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-22.DeploymentStrategyRollingUpdateOptions Env \u00b6 Container environment variables. Initializers \u00b6 import { Env } from 'cdk8s-plus-22' new Env ( sources : EnvFrom [], variables : {[ key : string ] : EnvValue }) sources Required \u00b6 Type: cdk8s-plus-22.EnvFrom [] variables Required \u00b6 Type: {[ key: string ]: cdk8s-plus-22.EnvValue } Methods \u00b6 addVariable \u00b6 public addVariable ( name : string , value : EnvValue ) name Required \u00b6 Type: string value Required \u00b6 Type: cdk8s-plus-22.EnvValue copyFrom \u00b6 public copyFrom ( from : EnvFrom ) from Required \u00b6 Type: cdk8s-plus-22.EnvFrom Static Functions \u00b6 fromConfigMap \u00b6 import { Env } from 'cdk8s-plus-22' Env . fromConfigMap ( configMap : IConfigMap , prefix? : string ) configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap prefix Optional \u00b6 Type: string fromSecret \u00b6 import { Env } from 'cdk8s-plus-22' Env . fromSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-22.ISecret Properties \u00b6 sources Required \u00b6 public readonly sources : EnvFrom []; Type: cdk8s-plus-22.EnvFrom [] The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 public readonly variables : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-22.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import { EnvFrom } from 'cdk8s-plus-22' new EnvFrom ( configMap? : IConfigMap , prefix? : string , sec? : ISecret ) configMap Optional \u00b6 Type: cdk8s-plus-22.IConfigMap prefix Optional \u00b6 Type: string sec Optional \u00b6 Type: cdk8s-plus-22.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromFieldRef ( fieldPath : EnvFieldPaths , options? : EnvValueFromFieldRefOptions ) fieldPath Required \u00b6 Type: cdk8s-plus-22.EnvFieldPaths : The field reference. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromResource ( resource : ResourceFieldPaths , options? : EnvValueFromResourceOptions ) resource Required \u00b6 Type: cdk8s-plus-22.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-22.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import { Handler } from 'cdk8s-plus-22' Handler . fromCommand ( command : string []) command Required \u00b6 Type: string [] The command to execute. fromHttpGet \u00b6 import { Handler } from 'cdk8s-plus-22' Handler . fromHttpGet ( path : string , options? : HandlerFromHttpGetOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-22.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import { Handler } from 'cdk8s-plus-22' Handler . fromTcpSocket ( options? : HandlerFromTcpSocketOptions ) options Optional \u00b6 Type: cdk8s-plus-22.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromResource \u00b6 import { IngressBackend } from 'cdk8s-plus-22' IngressBackend . fromResource ( resource : IResource ) resource Required \u00b6 Type: cdk8s-plus-22.IResource fromService \u00b6 import { IngressBackend } from 'cdk8s-plus-22' IngressBackend . fromService ( serv : Service , options? : ServiceIngressBackendOptions ) serv Required \u00b6 Type: cdk8s-plus-22.Service The service object. options Optional \u00b6 Type: cdk8s-plus-22.ServiceIngressBackendOptions LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import { LabeledNode } from 'cdk8s-plus-22' new LabeledNode ( labelSelector : NodeLabelQuery []) labelSelector Required \u00b6 Type: cdk8s-plus-22.NodeLabelQuery [] Properties \u00b6 labelSelector Required \u00b6 public readonly labelSelector : NodeLabelQuery []; Type: cdk8s-plus-22.NodeLabelQuery [] LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 doesNotExist \u00b6 import { LabelExpression } from 'cdk8s-plus-22' LabelExpression . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { LabelExpression } from 'cdk8s-plus-22' LabelExpression . exists ( key : string ) key Required \u00b6 Type: string in \u00b6 import { LabelExpression } from 'cdk8s-plus-22' LabelExpression . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] notIn \u00b6 import { LabelExpression } from 'cdk8s-plus-22' LabelExpression . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string operator Required \u00b6 public readonly operator : string ; Type: string values Optional \u00b6 public readonly values : string []; Type: string [] LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 isEmpty \u00b6 public isEmpty () Static Functions \u00b6 of \u00b6 import { LabelSelector } from 'cdk8s-plus-22' LabelSelector . of ( options? : LabelSelectorOptions ) options Optional \u00b6 Type: cdk8s-plus-22.LabelSelectorOptions NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import { NamedNode } from 'cdk8s-plus-22' new NamedNode ( name : string ) name Required \u00b6 Type: string Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 allTcp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . allTcp () allUdp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . allUdp () of \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . of ( props : NetworkPolicyPortProps ) props Required \u00b6 Type: cdk8s-plus-22.NetworkPolicyPortProps tcp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . tcp ( port : number ) port Required \u00b6 Type: number tcpRange \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . tcpRange ( startPort : number , endPort : number ) startPort Required \u00b6 Type: number endPort Required \u00b6 Type: number udp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . udp ( port : number ) port Required \u00b6 Type: number udpRange \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-22' NetworkPolicyPort . udpRange ( startPort : number , endPort : number ) startPort Required \u00b6 Type: number endPort Required \u00b6 Type: number Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import { Node } from 'cdk8s-plus-22' new Node () Static Functions \u00b6 labeled \u00b6 import { Node } from 'cdk8s-plus-22' Node . labeled ( labelSelector : NodeLabelQuery ) labelSelector Required \u00b6 Type: cdk8s-plus-22.NodeLabelQuery named \u00b6 import { Node } from 'cdk8s-plus-22' Node . named ( nodeName : string ) nodeName Required \u00b6 Type: string tainted \u00b6 import { Node } from 'cdk8s-plus-22' Node . tainted ( taintSelector : NodeTaintQuery ) taintSelector Required \u00b6 Type: cdk8s-plus-22.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 doesNotExist \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . exists ( key : string ) key Required \u00b6 Type: string gt \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . gt ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] in \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] is \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . is ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string lt \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . lt ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] notIn \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-22' NodeLabelQuery . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string operator Required \u00b6 public readonly operator : string ; Type: string values Optional \u00b6 public readonly values : string []; Type: string [] NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-22' NodeTaintQuery . any () exists \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-22' NodeTaintQuery . exists ( key : string , options? : NodeTaintQueryOptions ) key Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.NodeTaintQueryOptions is \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-22' NodeTaintQuery . is ( key : string , value : string , options? : NodeTaintQueryOptions ) key Required \u00b6 Type: string value Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.NodeTaintQueryOptions Properties \u00b6 operator Required \u00b6 public readonly operator : string ; Type: string effect Optional \u00b6 public readonly effect : string ; Type: string evictAfter Optional \u00b6 public readonly evictAfter : Duration ; Type: cdk8s.Duration key Optional \u00b6 public readonly key : string ; Type: string value Optional \u00b6 public readonly value : string ; Type: string NonApiResource \u00b6 Implements: cdk8s-plus-22.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import { NonApiResource } from 'cdk8s-plus-22' NonApiResource . of ( url : string ) url Required \u00b6 Type: string PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-22' PercentOrAbsolute . absolute ( num : number ) num Required \u00b6 Type: number percent \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-22' PercentOrAbsolute . percent ( percent : number ) percent Required \u00b6 Type: number Properties \u00b6 value Required \u00b6 public readonly value : any ; Type: any PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import { PodConnections } from 'cdk8s-plus-22' new PodConnections ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-22.AbstractPod Methods \u00b6 allowFrom \u00b6 public allowFrom ( peer : INetworkPolicyPeer , options? : PodConnectionsAllowFromOptions ) peer Required \u00b6 Type: cdk8s-plus-22.INetworkPolicyPeer options Optional \u00b6 Type: cdk8s-plus-22.PodConnectionsAllowFromOptions allowTo \u00b6 public allowTo ( peer : INetworkPolicyPeer , options? : PodConnectionsAllowToOptions ) peer Required \u00b6 Type: cdk8s-plus-22.INetworkPolicyPeer options Optional \u00b6 Type: cdk8s-plus-22.PodConnectionsAllowToOptions PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import { PodDns } from 'cdk8s-plus-22' new PodDns ( props? : PodDnsProps ) props Optional \u00b6 Type: cdk8s-plus-22.PodDnsProps Methods \u00b6 addNameserver \u00b6 public addNameserver ( nameservers : string ) nameservers Required \u00b6 Type: string addOption \u00b6 public addOption ( options : DnsOption ) options Required \u00b6 Type: cdk8s-plus-22.DnsOption addSearch \u00b6 public addSearch ( searches : string ) searches Required \u00b6 Type: string Properties \u00b6 hostnameAsFQDN Required \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public readonly nameservers : string []; Type: string [] Nameservers defined for this pod. options Required \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-22.DnsOption [] Custom dns options defined for this pod. policy Required \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-22.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public readonly searches : string []; Type: string [] Search domains defined for this pod. hostname Optional \u00b6 public readonly hostname : string ; Type: string The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import { PodScheduling } from 'cdk8s-plus-22' new PodScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-22.AbstractPod Methods \u00b6 assign \u00b6 public assign ( node : NamedNode ) node Required \u00b6 Type: cdk8s-plus-22.NamedNode attract \u00b6 public attract ( node : LabeledNode , options? : PodSchedulingAttractOptions ) node Required \u00b6 Type: cdk8s-plus-22.LabeledNode options Optional \u00b6 Type: cdk8s-plus-22.PodSchedulingAttractOptions colocate \u00b6 public colocate ( selector : IPodSelector , options? : PodSchedulingColocateOptions ) selector Required \u00b6 Type: cdk8s-plus-22.IPodSelector options Optional \u00b6 Type: cdk8s-plus-22.PodSchedulingColocateOptions separate \u00b6 public separate ( selector : IPodSelector , options? : PodSchedulingSeparateOptions ) selector Required \u00b6 Type: cdk8s-plus-22.IPodSelector options Optional \u00b6 Type: cdk8s-plus-22.PodSchedulingSeparateOptions tolerate \u00b6 public tolerate ( node : TaintedNode ) node Required \u00b6 Type: cdk8s-plus-22.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import { PodSecurityContext } from 'cdk8s-plus-22' new PodSecurityContext ( props? : PodSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-22.PodSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean fsGroupChangePolicy Required \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-22.FsGroupChangePolicy sysctls Required \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-22.Sysctl [] fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-22.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-22.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromTcpSocket ( options? : TcpSocketProbeOptions ) options Optional \u00b6 Type: cdk8s-plus-22.TcpSocketProbeOptions Options. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import { ResourcePermissions } from 'cdk8s-plus-22' new ResourcePermissions ( instance : Resource ) instance Required \u00b6 Type: cdk8s-plus-22.Resource Methods \u00b6 grantRead \u00b6 public grantRead ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject grantReadWrite \u00b6 public grantReadWrite ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-22' StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-22' StatefulSetUpdateStrategy . rollingUpdate ( options? : StatefulSetUpdateStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-22.StatefulSetUpdateStrategyRollingUpdateOptions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import { TaintedNode } from 'cdk8s-plus-22' new TaintedNode ( taintSelector : NodeTaintQuery []) taintSelector Required \u00b6 Type: cdk8s-plus-22.NodeTaintQuery [] Properties \u00b6 taintSelector Required \u00b6 public readonly taintSelector : NodeTaintQuery []; Type: cdk8s-plus-22.NodeTaintQuery [] Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import { Topology } from 'cdk8s-plus-22' Topology . custom ( key : string ) key Required \u00b6 Type: string Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string Constants \u00b6 HOSTNAME \u00b6 Type: cdk8s-plus-22.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: cdk8s-plus-22.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: cdk8s-plus-22.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import { WorkloadScheduling } from 'cdk8s-plus-22' new WorkloadScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-22.AbstractPod Methods \u00b6 spread \u00b6 public spread ( options? : WorkloadSchedulingSpreadOptions ) options Optional \u00b6 Type: cdk8s-plus-22.WorkloadSchedulingSpreadOptions Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.NetworkPolicy , cdk8s-plus-22.NonApiResource , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.NetworkPolicy , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.Namespace , cdk8s-plus-22.Namespaces , cdk8s-plus-22.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.Namespaces , cdk8s-plus-22.NetworkPolicyIpBlock , cdk8s-plus-22.Pod , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.Workload , cdk8s-plus-22.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. IPersistentVolume \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.Pods , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.Workload , cdk8s-plus-22.IPodSelector Represents an object that can select pods. Methods \u00b6 toPodSelectorConfig \u00b6 public toPodSelectorConfig () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. IResource \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.NetworkPolicy , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IConfigMap , cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IPersistentVolumeClaim , cdk8s-plus-22.IResource , cdk8s-plus-22.IRole , cdk8s-plus-22.ISecret , cdk8s-plus-22.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.Role , cdk8s-plus-22.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.Secret , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.ISecret Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.IServiceAccount Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IStorage \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.Volume , cdk8s-plus-22.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. ISubject \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.Group , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.User , cdk8s-plus-22.Workload , cdk8s-plus-22.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. - Pods that tolerate the taint without specifying duration remain bound forever. - Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"TypeScript"},{"location":"reference/cdk8s-plus-22/typescript/#cdk8s-plus-22-typescript","text":"","title":"cdk8s-plus-22 (TypeScript) "},{"location":"reference/cdk8s-plus-22/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/typescript/#abstractpod","text":"Implements: cdk8s-plus-22.IPodSelector , cdk8s-plus-22.INetworkPolicyPeer , cdk8s-plus-22.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-22/typescript/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrole","text":"Implements: cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-22/typescript/#configmap","text":"Implements: cdk8s-plus-22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/typescript/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-22/typescript/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-22/typescript/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/typescript/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-22/typescript/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#group","text":"Implements: cdk8s-plus-22.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-22/typescript/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/typescript/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/typescript/#namespace","text":"Implements: cdk8s-plus-22.INamespaceSelector , cdk8s-plus-22.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-22/typescript/#namespaces","text":"Implements: cdk8s-plus-22.INamespaceSelector , cdk8s-plus-22.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicyipblock","text":"Implements: cdk8s-plus-22.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolume","text":"Implements: cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeclaim","text":"Implements: cdk8s-plus-22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/typescript/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/typescript/#pods","text":"Implements: cdk8s-plus-22.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-22/typescript/#resource","text":"Implements: cdk8s-plus-22.IResource , cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/typescript/#role","text":"Implements: cdk8s-plus-22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-22/typescript/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-22/typescript/#secret","text":"Implements: cdk8s-plus-22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccount","text":"Implements: cdk8s-plus-22.IServiceAccount , cdk8s-plus-22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-22/typescript/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-22/typescript/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/typescript/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-22/typescript/#user","text":"Implements: cdk8s-plus-22.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-22/typescript/#volume","text":"Implements: cdk8s-plus-22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/typescript/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-22/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/typescript/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-22/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/typescript/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-22/typescript/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-22/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-22/typescript/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-22/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/typescript/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-22/typescript/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-22/typescript/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-22/typescript/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-22/typescript/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/typescript/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-22/typescript/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/typescript/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-22/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/typescript/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-22/typescript/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-22/typescript/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-22/typescript/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/typescript/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/typescript/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/typescript/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/typescript/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-22/typescript/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-22/typescript/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-22/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/typescript/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-22/typescript/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-22/typescript/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-22/typescript/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-22/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-22/typescript/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-22/typescript/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-22/typescript/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/typescript/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-22/typescript/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-22/typescript/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-22/typescript/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-22/typescript/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-22/typescript/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-22/typescript/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-22/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/typescript/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-22/typescript/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-22/typescript/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-22/typescript/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/typescript/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/typescript/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/typescript/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/typescript/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-22/typescript/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-22/typescript/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/typescript/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-22/typescript/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-22/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/typescript/#apiresource","text":"Implements: cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-22/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/typescript/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-22/typescript/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-22/typescript/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-22/typescript/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-22/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/typescript/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-22/typescript/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/typescript/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-22/typescript/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-22/typescript/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-22/typescript/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-22/typescript/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-22/typescript/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-22/typescript/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-22/typescript/#nonapiresource","text":"Implements: cdk8s-plus-22.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-22/typescript/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-22/typescript/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-22/typescript/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-22/typescript/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-22/typescript/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-22/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/typescript/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-22/typescript/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-22/typescript/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-22/typescript/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-22/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/typescript/#iapiendpoint","text":"Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.NetworkPolicy , cdk8s-plus-22.NonApiResource , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-22/typescript/#iapiresource","text":"Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.NetworkPolicy , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-22/typescript/#iclusterrole","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-22/typescript/#iconfigmap","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/typescript/#inamespaceselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.Namespace , cdk8s-plus-22.Namespaces , cdk8s-plus-22.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-22/typescript/#inetworkpolicypeer","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.Namespaces , cdk8s-plus-22.NetworkPolicyIpBlock , cdk8s-plus-22.Pod , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.Workload , cdk8s-plus-22.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-22/typescript/#ipersistentvolume","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#ipersistentvolumeclaim","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/typescript/#ipodselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.Pods , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.Workload , cdk8s-plus-22.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-22/typescript/#iresource","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Namespace , cdk8s-plus-22.NetworkPolicy , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IConfigMap , cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IPersistentVolumeClaim , cdk8s-plus-22.IResource , cdk8s-plus-22.IRole , cdk8s-plus-22.ISecret , cdk8s-plus-22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/typescript/#irole","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.Role , cdk8s-plus-22.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-22/typescript/#isecret","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.Secret , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/typescript/#istorage","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.Volume , cdk8s-plus-22.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-22/typescript/#isubject","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.CronJob , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.Group , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.User , cdk8s-plus-22.Workload , cdk8s-plus-22.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-22/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-22/typescript/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-22/typescript/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/typescript/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-22/typescript/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-22/typescript/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-22/typescript/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/typescript/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-22/typescript/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-22/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-22/typescript/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-22/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/typescript/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-23/go/","text":"cdk8s-plus-23 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus23 .","title":"Go"},{"location":"reference/cdk8s-plus-23/go/#cdk8s-plus-23-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus23 .","title":"cdk8s-plus-23 (Go) "},{"location":"reference/cdk8s-plus-23/java/","text":"cdk8s-plus-23 (Java) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: org.cdk8s.plus23.IPodSelector , org.cdk8s.plus23.INetworkPolicyPeer , org.cdk8s.plus23.ISubject Initializers \u00b6 import org.cdk8s.plus23.AbstractPod ; AbstractPod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus23.ContainerProps addHostAlias \u00b6 public addHostAlias ( HostAlias hostAlias ) hostAlias Required \u00b6 Type: org.cdk8s.plus23.HostAlias addInitContainer \u00b6 public addInitContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus23.ContainerProps addVolume \u00b6 public addVolume ( Volume vol ) vol Required \u00b6 Type: org.cdk8s.plus23.Volume toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 automountServiceAccountToken Required \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus23.Container > dns Required \u00b6 public PodDns getDns (); Type: org.cdk8s.plus23.PodDns hostAliases Required \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > initContainers Required \u00b6 public java . util . List < Container > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.Container > podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition securityContext Required \u00b6 public PodSecurityContext getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContext volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume ; AwsElasticBlockStorePersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Volume id of this volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import org.cdk8s.plus23.AzureDiskPersistentVolume ; AzureDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 Type: org.cdk8s.plus23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: org.cdk8s.plus23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azureKind Required \u00b6 public AzureDiskPersistentVolumeKind getAzureKind (); Type: org.cdk8s.plus23.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus23.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String Disk name of this volume. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String Disk URI of this volume. fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import org.cdk8s.plus23.BasicAuthSecret ; BasicAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: java.lang.String The password or token for authentication. username Required \u00b6 Type: java.lang.String The user name for authentication. ClusterRole \u00b6 Implements: org.cdk8s.plus23.IClusterRole , org.cdk8s.plus23.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import org.cdk8s.plus23.ClusterRole ; ClusterRole . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 public aggregate ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiEndpoint endpoints ) verbs Required \u00b6 Type: java.util.List< java.lang.String > endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus23.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( java . lang . String namespace , ISubject subjects ) namespace Required \u00b6 Type: java.lang.String the namespace to limit permissions to. subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject a list of subjects to bind to. combine \u00b6 public combine ( ClusterRole rol ) rol Required \u00b6 Type: org.cdk8s.plus23.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import org.cdk8s.plus23.ClusterRole ; ClusterRole . fromClusterRoleName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus23.ClusterRolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import org.cdk8s.plus23.ClusterRoleBinding ; ClusterRoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus23.IClusterRole The role to bind to. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus23.IClusterRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus23.ISubject > ConfigMap \u00b6 Implements: org.cdk8s.plus23.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus23.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus23.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus23.ConfigMap ; ConfigMap . fromConfigMapName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not this config map is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import org.cdk8s.plus23.CronJob ; CronJob . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . schedule ( Cron ) // .concurrencyPolicy(ConcurrencyPolicy) // .failedJobsRetained(java.lang.Number) // .startingDeadline(Duration) // .successfulJobsRetained(java.lang.Number) // .suspend(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 Type: org.cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 Type: org.cdk8s.plus23.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 Type: java.lang.Number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 Type: java.lang.Number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 Type: java.lang.Boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. Properties \u00b6 concurrencyPolicy Required \u00b6 public java . lang . String getConcurrencyPolicy (); Type: java.lang.String The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failedJobsRetained Required \u00b6 public java . lang . Number getFailedJobsRetained (); Type: java.lang.Number The number of failed jobs retained by this cron job. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String Represents the resource type. schedule Required \u00b6 public Cron getSchedule (); Type: org.cdk8s.Cron The schedule this cron job is scheduled to run in. startingDeadline Required \u00b6 public Duration getStartingDeadline (); Type: org.cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successfulJobsRetained Required \u00b6 public java . lang . Number getSuccessfulJobsRetained (); Type: java.lang.Number The number of successful jobs retained by this cron job. suspend Required \u00b6 public java . lang . Boolean getSuspend (); Type: java.lang.Boolean Whether or not the cron job is currently suspended or not. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import org.cdk8s.plus23.DaemonSet ; DaemonSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 minReadySeconds Required \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus23.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: java.lang.Number Default: 2 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus23.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus23.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( DeploymentExposeViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.DeploymentExposeViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus23.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import org.cdk8s.plus23.DockerConfigSecret ; DockerConfigSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import org.cdk8s.plus23.GCEPersistentDiskPersistentVolume ; GCEPersistentDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String PD resource in GCE of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. Group \u00b6 Implements: org.cdk8s.plus23.ISubject Represents a group. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import org.cdk8s.plus23.Group ; Group . fromName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String name Required \u00b6 public java . lang . String getName (); Type: java.lang.String apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus23.Ingress ; Ingress . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus23.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressBackend backend ) backend Required \u00b6 Type: org.cdk8s.plus23.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressBackend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus23.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend ) public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus23.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus23.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( java . lang . String path , IngressBackend backend ) public addRule ( java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus23.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus23.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( IngressRule rules ) rules Required \u00b6 Type: org.cdk8s.plus23.IngressRule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressTls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus23.IngressTls > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus23.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: org.cdk8s.plus23.INamespaceSelector , org.cdk8s.plus23.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import org.cdk8s.plus23.Namespace ; Namespace . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: java.lang.String https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: org.cdk8s.plus23.INamespaceSelector , org.cdk8s.plus23.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import org.cdk8s.plus23.Namespaces ; new Namespaces ( Construct scope , java . lang . String id ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . List < java . lang . String > names ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . List < java . lang . String > names , java . util . Map < java . lang . String , java . lang . String > labels ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String expressions Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.LabelExpression > names Optional \u00b6 Type: java.util.List< java.lang.String > labels Optional \u00b6 Type: java.util.Map java.lang.String > Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 all \u00b6 import org.cdk8s.plus23.Namespaces ; Namespaces . all ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String select \u00b6 import org.cdk8s.plus23.Namespaces ; Namespaces . select ( Construct scope , java . lang . String id , NamespacesSelectOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus23.NamespacesSelectOptions NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import org.cdk8s.plus23.NetworkPolicy ; NetworkPolicy . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .egress(NetworkPolicyTraffic) // .ingress(NetworkPolicyTraffic) // .selector(IPodSelector) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 Type: org.cdk8s.plus23.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 Type: org.cdk8s.plus23.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 Type: org.cdk8s.plus23.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that Methods \u00b6 addEgressRule \u00b6 public addEgressRule ( INetworkPolicyPeer peer ) public addEgressRule ( INetworkPolicyPeer peer , java . util . List < NetworkPolicyPort > ports ) peer Required \u00b6 Type: org.cdk8s.plus23.INetworkPolicyPeer ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.NetworkPolicyPort > addIngressRule \u00b6 public addIngressRule ( INetworkPolicyPeer peer ) public addIngressRule ( INetworkPolicyPeer peer , java . util . List < NetworkPolicyPort > ports ) peer Required \u00b6 Type: org.cdk8s.plus23.INetworkPolicyPeer ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.NetworkPolicyPort > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: org.cdk8s.plus23.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 anyIpv4 \u00b6 import org.cdk8s.plus23.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . anyIpv4 ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String anyIpv6 \u00b6 import org.cdk8s.plus23.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . anyIpv6 ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String ipv4 \u00b6 import org.cdk8s.plus23.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . ipv4 ( Construct scope , java . lang . String id , java . lang . String cidrIp ) NetworkPolicyIpBlock . ipv4 ( Construct scope , java . lang . String id , java . lang . String cidrIp , java . util . List < java . lang . String > except ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String cidrIp Required \u00b6 Type: java.lang.String except Optional \u00b6 Type: java.util.List< java.lang.String > ipv6 \u00b6 import org.cdk8s.plus23.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . ipv6 ( Construct scope , java . lang . String id , java . lang . String cidrIp ) NetworkPolicyIpBlock . ipv6 ( Construct scope , java . lang . String id , java . lang . String cidrIp , java . util . List < java . lang . String > except ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String cidrIp Required \u00b6 Type: java.lang.String except Optional \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 cidr Required \u00b6 public java . lang . String getCidr (); Type: java.lang.String A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 public java . util . List < java . lang . String > getExcept (); Type: java.util.List< java.lang.String > A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: org.cdk8s.plus23.IPersistentVolume , org.cdk8s.plus23.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import org.cdk8s.plus23.PersistentVolume ; PersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( IPersistentVolumeClaim claim ) claim Required \u00b6 Type: org.cdk8s.plus23.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import org.cdk8s.plus23.PersistentVolume ; PersistentVolume . fromPersistentVolumeName ( Construct scope , java . lang . String id , java . lang . String volumeName ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String volumeName Required \u00b6 Type: java.lang.String Properties \u00b6 mode Required \u00b6 public PersistentVolumeMode getMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Access modes requirement of this claim. claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus23.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Mount options of this volume. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: org.cdk8s.plus23.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import org.cdk8s.plus23.PersistentVolumeClaim ; PersistentVolumeClaim . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: org.cdk8s.plus23.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 public bind ( IPersistentVolume vol ) vol Required \u00b6 Type: org.cdk8s.plus23.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import org.cdk8s.plus23.PersistentVolumeClaim ; PersistentVolumeClaim . fromClaimName ( Construct scope , java . lang . String id , java . lang . String claimName ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String claimName Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Access modes requirement of this claim. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class requirment of this claim. volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus23.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus23.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 connections Required \u00b6 public PodConnections getConnections (); Type: org.cdk8s.plus23.PodConnections podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 public PodScheduling getScheduling (); Type: org.cdk8s.plus23.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: java.lang.String This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: org.cdk8s.plus23.IPodSelector Represents a group of pods. Initializers \u00b6 import org.cdk8s.plus23.Pods ; new Pods ( Construct scope , java . lang . String id ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . Map < java . lang . String , java . lang . String > labels ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . Map < java . lang . String , java . lang . String > labels , INamespaceSelector namespaces ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String expressions Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.LabelExpression > labels Optional \u00b6 Type: java.util.Map java.lang.String > namespaces Optional \u00b6 Type: org.cdk8s.plus23.INamespaceSelector Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () Static Functions \u00b6 all \u00b6 import org.cdk8s.plus23.Pods ; Pods . all ( Construct scope , java . lang . String id ) Pods . all ( Construct scope , java . lang . String id , PodsAllOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.PodsAllOptions select \u00b6 import org.cdk8s.plus23.Pods ; Pods . select ( Construct scope , java . lang . String id , PodsSelectOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus23.PodsSelectOptions Resource \u00b6 Implements: org.cdk8s.plus23.IResource , org.cdk8s.plus23.IApiResource , org.cdk8s.plus23.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus23.Resource ; new Resource ( Construct scope , java . lang . String id ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. permissions Required \u00b6 public ResourcePermissions getPermissions (); Type: org.cdk8s.plus23.ResourcePermissions resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: org.cdk8s.plus23.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import org.cdk8s.plus23.Role ; Role . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.RolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiResource resources ) verbs Required \u00b6 Type: java.util.List< java.lang.String > resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus23.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import org.cdk8s.plus23.Role ; Role . fromRoleName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus23.RolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import org.cdk8s.plus23.RoleBinding ; RoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus23.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus23.IRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus23.ISubject > Secret \u00b6 Implements: org.cdk8s.plus23.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus23.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus23.Secret ; Secret . fromSecretName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not the secret is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus23.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .selector(IPodSelector) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ServicePort > Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 Type: org.cdk8s.plus23.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 Type: org.cdk8s.plus23.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 bind \u00b6 public bind ( java . lang . Number port ) public bind ( java . lang . Number port , ServiceBindOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus23.ServiceBindOptions exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus23.ExposeServiceViaIngressOptions Additional options. select \u00b6 public select ( IPodSelector selector ) selector Required \u00b6 Type: org.cdk8s.plus23.IPodSelector selectLabel \u00b6 public selectLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus23.ServicePort > Ports for this service. Use bind() to bind additional service ports. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus23.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus23.IServiceAccount , org.cdk8s.plus23.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus23.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus23.ISecret The secret. toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus23.ServiceAccount ; ServiceAccount . fromServiceAccountName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus23.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import org.cdk8s.plus23.ServiceAccountTokenSecret ; ServiceAccountTokenSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 Type: org.cdk8s.plus23.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import org.cdk8s.plus23.SshAuthSecret ; SshAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 Type: java.lang.String The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus23.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 Type: org.cdk8s.plus23.Service Service to associate with the statefulset. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus23.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus23.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus23.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus23.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import org.cdk8s.plus23.TlsSecret ; TlsSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 Type: java.lang.String The TLS cert. tlsKey Required \u00b6 Type: java.lang.String The TLS key. User \u00b6 Implements: org.cdk8s.plus23.ISubject Represents a user. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import org.cdk8s.plus23.User ; User . fromName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String name Required \u00b6 public java . lang . String getName (); Type: java.lang.String apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String Volume \u00b6 Implements: org.cdk8s.plus23.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromAwsElasticBlockStore ( Construct scope , java . lang . String id , java . lang . String volumeId ) Volume . fromAwsElasticBlockStore ( Construct scope , java . lang . String id , java . lang . String volumeId , AwsElasticBlockStoreVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String volumeId Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromAzureDisk ( Construct scope , java . lang . String id , java . lang . String diskName , java . lang . String diskUri ) Volume . fromAzureDisk ( Construct scope , java . lang . String id , java . lang . String diskName , java . lang . String diskUri , AzureDiskVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String diskName Required \u00b6 Type: java.lang.String diskUri Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.AzureDiskVolumeOptions fromConfigMap \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromConfigMap ( Construct scope , java . lang . String id , IConfigMap configMap ) Volume . fromConfigMap ( Construct scope , java . lang . String id , IConfigMap configMap , ConfigMapVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String configMap Required \u00b6 Type: org.cdk8s.plus23.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus23.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromEmptyDir ( Construct scope , java . lang . String id , java . lang . String name ) Volume . fromEmptyDir ( Construct scope , java . lang . String id , java . lang . String name , EmptyDirVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromGcePersistentDisk ( Construct scope , java . lang . String id , java . lang . String pdName ) Volume . fromGcePersistentDisk ( Construct scope , java . lang . String id , java . lang . String pdName , GCEPersistentDiskVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String pdName Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.GCEPersistentDiskVolumeOptions fromHostPath \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromHostPath ( Construct scope , java . lang . String id , java . lang . String name , HostPathVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus23.HostPathVolumeOptions fromPersistentVolumeClaim \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromPersistentVolumeClaim ( Construct scope , java . lang . String id , IPersistentVolumeClaim claim ) Volume . fromPersistentVolumeClaim ( Construct scope , java . lang . String id , IPersistentVolumeClaim claim , PersistentVolumeClaimVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String claim Required \u00b6 Type: org.cdk8s.plus23.IPersistentVolumeClaim options Optional \u00b6 Type: org.cdk8s.plus23.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import org.cdk8s.plus23.Volume ; Volume . fromSecret ( Construct scope , java . lang . String id , ISecret secr ) Volume . fromSecret ( Construct scope , java . lang . String id , ISecret secr , SecretVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String secr Required \u00b6 Type: org.cdk8s.plus23.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus23.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import org.cdk8s.plus23.Workload ; Workload . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints Methods \u00b6 select \u00b6 public select ( LabelSelector selectors ) selectors Required \u00b6 Type: org.cdk8s.plus23.LabelSelector Properties \u00b6 connections Required \u00b6 public PodConnections getConnections (); Type: org.cdk8s.plus23.PodConnections matchExpressions Required \u00b6 public java . util . List < LabelSelectorRequirement > getMatchExpressions (); Type: java.util.List< org.cdk8s.plus23.LabelSelectorRequirement > The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getMatchLabels (); Type: java.util.Map java.lang.String > The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 public WorkloadScheduling getScheduling (); Type: org.cdk8s.plus23.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import org.cdk8s.plus23.AbstractPodProps ; AbstractPodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus23.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus23.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import org.cdk8s.plus23.ApiResourceOptions ; ApiResourceOptions . builder () . apiGroup ( java . lang . String ) . resourceType ( java . lang . String ) . build (); apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import org.cdk8s.plus23.AwsElasticBlockStorePersistentVolumeProps ; AwsElasticBlockStorePersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import org.cdk8s.plus23.AwsElasticBlockStoreVolumeOptions ; AwsElasticBlockStoreVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus23.AzureDiskPersistentVolumeProps ; AzureDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import org.cdk8s.plus23.AzureDiskVolumeOptions ; AzureDiskVolumeOptions . builder () // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import org.cdk8s.plus23.BasicAuthSecretProps ; BasicAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public java . lang . String getPassword (); Type: java.lang.String The password or token for authentication. username Required \u00b6 public java . lang . String getUsername (); Type: java.lang.String The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import org.cdk8s.plus23.ClusterRoleBindingProps ; ClusterRoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus23.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import org.cdk8s.plus23.ClusterRolePolicyRule ; ClusterRolePolicyRule . builder () . endpoints ( java . util . List < IApiEndpoint > ) . verbs ( java . util . List < java . lang . String > ) . build (); endpoints Required \u00b6 public java . util . List < IApiEndpoint > getEndpoints (); Type: java.util.List< org.cdk8s.plus23.IApiEndpoint > Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import org.cdk8s.plus23.ClusterRoleProps ; ClusterRoleProps . builder () // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAggregationLabels (); Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus23.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus23.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import org.cdk8s.plus23.CommonSecretProps ; CommonSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus23.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus23.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:11015\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import org.cdk8s.plus23.ContainerLifecycle ; ContainerLifecycle . builder () // .postStart(Handler) // .preStop(Handler) . build (); postStart Optional \u00b6 public Handler getPostStart (); Type: org.cdk8s.plus23.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public Handler getPreStop (); Type: org.cdk8s.plus23.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import org.cdk8s.plus23.ContainerPort ; ContainerPort . builder () . number ( java . lang . Number ) // .hostIp(java.lang.String) // .hostPort(java.lang.Number) // .name(java.lang.String) // .protocol(Protocol) . build (); number Required \u00b6 public java . lang . Number getNumber (); Type: java.lang.Number Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. hostIp Optional \u00b6 public java . lang . String getHostIp (); Type: java.lang.String Default: 127.0.0.1. What host IP to bind the external port to. hostPort Optional \u00b6 public java . lang . Number getHostPort (); Type: java.lang.Number Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus23.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus23.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .envFrom(java.util.List<EnvFrom>) // .envVariables(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .portNumber(java.lang.Number) // .ports(java.util.List<ContainerPort>) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 public java . util . List < EnvFrom > getEnvFrom (); Type: java.util.List< org.cdk8s.plus23.EnvFrom > Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnvVariables (); Type: java.util.Map \u0002klzzwxh:10969\u0003 > Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public ContainerLifecycle getLifecycle (); Type: org.cdk8s.plus23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public java . lang . Number getPort (); Type: java.lang.Number portNumber Optional \u00b6 public java . lang . Number getPortNumber (); Type: java.lang.Number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 public java . util . List < ContainerPort > getPorts (); Type: java.util.List< org.cdk8s.plus23.ContainerPort > Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public ContainerSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus23.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import org.cdk8s.plus23.ContainerResources ; ContainerResources . builder () // .cpu(CpuResources) // .ephemeralStorage(EphemeralStorageResources) // .memory(MemoryResources) . build (); cpu Optional \u00b6 public CpuResources getCpu (); Type: org.cdk8s.plus23.CpuResources ephemeralStorage Optional \u00b6 public EphemeralStorageResources getEphemeralStorage (); Type: org.cdk8s.plus23.EphemeralStorageResources memory Optional \u00b6 public MemoryResources getMemory (); Type: org.cdk8s.plus23.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import org.cdk8s.plus23.ContainerSecurityContextProps ; ContainerSecurityContextProps . builder () // .allowPrivilegeEscalation(java.lang.Boolean) // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); allowPrivilegeEscalation Optional \u00b6 public java . lang . Boolean getAllowPrivilegeEscalation (); Type: java.lang.Boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import org.cdk8s.plus23.CpuResources ; CpuResources . builder () // .limit(Cpu) // .request(Cpu) . build (); limit Optional \u00b6 public Cpu getLimit (); Type: org.cdk8s.plus23.Cpu request Optional \u00b6 public Cpu getRequest (); Type: org.cdk8s.plus23.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import org.cdk8s.plus23.CronJobProps ; CronJobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . schedule ( Cron ) // .concurrencyPolicy(ConcurrencyPolicy) // .failedJobsRetained(java.lang.Number) // .startingDeadline(Duration) // .successfulJobsRetained(java.lang.Number) // .suspend(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 public Cron getSchedule (); Type: org.cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 public ConcurrencyPolicy getConcurrencyPolicy (); Type: org.cdk8s.plus23.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 public java . lang . Number getFailedJobsRetained (); Type: java.lang.Number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 public Duration getStartingDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 public java . lang . Number getSuccessfulJobsRetained (); Type: java.lang.Number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 public java . lang . Boolean getSuspend (); Type: java.lang.Boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import org.cdk8s.plus23.DaemonSetProps ; DaemonSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import org.cdk8s.plus23.DeploymentExposeViaServiceOptions ; DeploymentExposeViaServiceOptions . builder () // .name(java.lang.String) // .ports(java.util.List<ServicePort>) // .serviceType(ServiceType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus23.ServicePort > Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus23.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import org.cdk8s.plus23.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 2 Number of desired pods. strategy Optional \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus23.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus23.DeploymentStrategyRollingUpdateOptions ; DeploymentStrategyRollingUpdateOptions . builder () // .maxSurge(PercentOrAbsolute) // .maxUnavailable(PercentOrAbsolute) . build (); maxSurge Optional \u00b6 public PercentOrAbsolute getMaxSurge (); Type: org.cdk8s.plus23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public PercentOrAbsolute getMaxUnavailable (); Type: org.cdk8s.plus23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import org.cdk8s.plus23.DnsOption ; DnsOption . builder () . name ( java . lang . String ) // .value(java.lang.String) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Option name. value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import org.cdk8s.plus23.DockerConfigSecretProps ; DockerConfigSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getData (); Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus23.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus23.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus23.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import org.cdk8s.plus23.EnvValueFromFieldRefOptions ; EnvValueFromFieldRefOptions . builder () // .apiVersion(java.lang.String) // .key(java.lang.String) . build (); apiVersion Optional \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus23.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import org.cdk8s.plus23.EnvValueFromResourceOptions ; EnvValueFromResourceOptions . builder () // .container(Container) // .divisor(java.lang.String) . build (); container Optional \u00b6 public Container getContainer (); Type: org.cdk8s.plus23.Container The container to select the value from. divisor Optional \u00b6 public java . lang . String getDivisor (); Type: java.lang.String The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus23.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import org.cdk8s.plus23.EphemeralStorageResources ; EphemeralStorageResources . builder () // .limit(Size) // .request(Size) . build (); limit Optional \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Optional \u00b6 public Size getRequest (); Type: org.cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus23.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .ports(java.util.List<ServicePort>) // .serviceType(ServiceType) // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus23.ServicePort > Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus23.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus23.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus23.GCEPersistentDiskPersistentVolumeProps ; GCEPersistentDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import org.cdk8s.plus23.GCEPersistentDiskVolumeOptions ; GCEPersistentDiskVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import org.cdk8s.plus23.HandlerFromHttpGetOptions ; HandlerFromHttpGetOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import org.cdk8s.plus23.HandlerFromTcpSocketOptions ; HandlerFromTcpSocketOptions . builder () // .host(java.lang.String) // .port(java.lang.Number) . build (); host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import org.cdk8s.plus23.HostAlias ; HostAlias . builder () . hostnames ( java . util . List < java . lang . String > ) . ip ( java . lang . String ) . build (); hostnames Required \u00b6 public java . util . List < java . lang . String > getHostnames (); Type: java.util.List< java.lang.String > Hostnames for the chosen IP address. ip Required \u00b6 public java . lang . String getIp (); Type: java.lang.String IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import org.cdk8s.plus23.HostPathVolumeOptions ; HostPathVolumeOptions . builder () . path ( java . lang . String ) // .type(HostPathVolumeType) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The path of the directory on the host. type Optional \u00b6 public HostPathVolumeType getType (); Type: org.cdk8s.plus23.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus23.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) // .scheme(ConnectionScheme) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 public ConnectionScheme getScheme (); Type: org.cdk8s.plus23.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus23.IngressProps ; IngressProps . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressBackend getDefaultBackend (); Type: org.cdk8s.plus23.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressRule > getRules (); Type: java.util.List< org.cdk8s.plus23.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressTls > getTls (); Type: java.util.List< org.cdk8s.plus23.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus23.IngressRule ; IngressRule . builder () . backend ( IngressBackend ) // .host(java.lang.String) // .path(java.lang.String) // .pathType(HttpIngressPathType) . build (); backend Required \u00b6 public IngressBackend getBackend (); Type: org.cdk8s.plus23.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus23.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus23.IngressTls ; IngressTls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus23.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import org.cdk8s.plus23.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import org.cdk8s.plus23.LabelSelectorOptions ; LabelSelectorOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus23.LabelExpression > Expression based label matchers. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import org.cdk8s.plus23.LabelSelectorRequirement ; LabelSelectorRequirement . builder () . key ( java . lang . String ) . operator ( java . lang . String ) // .values(java.util.List<java.lang.String>) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The label key that the selector applies to. operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import org.cdk8s.plus23.MemoryResources ; MemoryResources . builder () // .limit(Size) // .request(Size) . build (); limit Optional \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Optional \u00b6 public Size getRequest (); Type: org.cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus23.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import org.cdk8s.plus23.NamespaceProps ; NamespaceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import org.cdk8s.plus23.NamespaceSelectorConfig ; NamespaceSelectorConfig . builder () // .labelSelector(LabelSelector) // .names(java.util.List<java.lang.String>) . build (); labelSelector Optional \u00b6 public LabelSelector getLabelSelector (); Type: org.cdk8s.plus23.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 public java . util . List < java . lang . String > getNames (); Type: java.util.List< java.lang.String > A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import org.cdk8s.plus23.NamespacesSelectOptions ; NamespacesSelectOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .names(java.util.List<java.lang.String>) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus23.LabelExpression > Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 public java . util . List < java . lang . String > getNames (); Type: java.util.List< java.lang.String > Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import org.cdk8s.plus23.NetworkPolicyAddEgressRuleOptions ; NetworkPolicyAddEgressRuleOptions . builder () // .ports(java.util.List<NetworkPolicyPort>) . build (); ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus23.NetworkPolicyPort > Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import org.cdk8s.plus23.NetworkPolicyPeerConfig ; NetworkPolicyPeerConfig . builder () // .ipBlock(NetworkPolicyIpBlock) // .podSelector(PodSelectorConfig) . build (); ipBlock Optional \u00b6 public NetworkPolicyIpBlock getIpBlock (); Type: org.cdk8s.plus23.NetworkPolicyIpBlock The ip block this peer represents. podSelector Optional \u00b6 public PodSelectorConfig getPodSelector (); Type: org.cdk8s.plus23.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import org.cdk8s.plus23.NetworkPolicyPortProps ; NetworkPolicyPortProps . builder () // .endPort(java.lang.Number) // .port(java.lang.Number) // .protocol(NetworkProtocol) . build (); endPort Optional \u00b6 public java . lang . Number getEndPort (); Type: java.lang.Number Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: all ports are allowed. Specific port number. protocol Optional \u00b6 public NetworkProtocol getProtocol (); Type: org.cdk8s.plus23.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import org.cdk8s.plus23.NetworkPolicyProps ; NetworkPolicyProps . builder () // .metadata(ApiObjectMetadata) // .egress(NetworkPolicyTraffic) // .ingress(NetworkPolicyTraffic) // .selector(IPodSelector) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 public NetworkPolicyTraffic getEgress (); Type: org.cdk8s.plus23.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 public NetworkPolicyTraffic getIngress (); Type: org.cdk8s.plus23.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 public IPodSelector getSelector (); Type: org.cdk8s.plus23.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import org.cdk8s.plus23.NetworkPolicyRule ; NetworkPolicyRule . builder () . peer ( INetworkPolicyPeer ) // .ports(java.util.List<NetworkPolicyPort>) . build (); peer Required \u00b6 public INetworkPolicyPeer getPeer (); Type: org.cdk8s.plus23.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus23.NetworkPolicyPort > Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import org.cdk8s.plus23.NetworkPolicyTraffic ; NetworkPolicyTraffic . builder () // .default(NetworkPolicyTrafficDefault) // .rules(java.util.List<NetworkPolicyRule>) . build (); default Optional \u00b6 public NetworkPolicyTrafficDefault getDefault (); Type: org.cdk8s.plus23.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 public java . util . List < NetworkPolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus23.NetworkPolicyRule > Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import org.cdk8s.plus23.NodeTaintQueryOptions ; NodeTaintQueryOptions . builder () // .effect(TaintEffect) // .evictAfter(Duration) . build (); effect Optional \u00b6 public TaintEffect getEffect (); Type: org.cdk8s.plus23.TaintEffect Default: all effects are matched. The taint effect to match. evictAfter Optional \u00b6 public Duration getEvictAfter (); Type: org.cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus23.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import org.cdk8s.plus23.PersistentVolumeClaimProps ; PersistentVolumeClaimProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus23.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import org.cdk8s.plus23.PersistentVolumeClaimVolumeOptions ; PersistentVolumeClaimVolumeOptions . builder () // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import org.cdk8s.plus23.PersistentVolumeProps ; PersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus23.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import org.cdk8s.plus23.PodConnectionsAllowFromOptions ; PodConnectionsAllowFromOptions . builder () // .isolation(PodConnectionsIsolation) // .ports(java.util.List<NetworkPolicyPort>) . build (); isolation Optional \u00b6 public PodConnectionsIsolation getIsolation (); Type: org.cdk8s.plus23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus23.NetworkPolicyPort > Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import org.cdk8s.plus23.PodConnectionsAllowToOptions ; PodConnectionsAllowToOptions . builder () // .isolation(PodConnectionsIsolation) // .ports(java.util.List<NetworkPolicyPort>) . build (); isolation Optional \u00b6 public PodConnectionsIsolation getIsolation (); Type: org.cdk8s.plus23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus23.NetworkPolicyPort > Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import org.cdk8s.plus23.PodDnsProps ; PodDnsProps . builder () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus23.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus23.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import org.cdk8s.plus23.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import org.cdk8s.plus23.PodsAllOptions ; PodsAllOptions . builder () // .namespaces(Namespaces) . build (); namespaces Optional \u00b6 public Namespaces getNamespaces (); Type: org.cdk8s.plus23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import org.cdk8s.plus23.PodSchedulingAttractOptions ; PodSchedulingAttractOptions . builder () // .weight(java.lang.Number) . build (); weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import org.cdk8s.plus23.PodSchedulingColocateOptions ; PodSchedulingColocateOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus23.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import org.cdk8s.plus23.PodSchedulingSeparateOptions ; PodSchedulingSeparateOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus23.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import org.cdk8s.plus23.PodSecurityContextProps ; PodSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus23.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus23.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import org.cdk8s.plus23.PodSelectorConfig ; PodSelectorConfig . builder () . labelSelector ( LabelSelector ) // .namespaces(NamespaceSelectorConfig) . build (); labelSelector Required \u00b6 public LabelSelector getLabelSelector (); Type: org.cdk8s.plus23.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 public NamespaceSelectorConfig getNamespaces (); Type: org.cdk8s.plus23.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import org.cdk8s.plus23.PodsSelectOptions ; PodsSelectOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespaces(Namespaces) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus23.LabelExpression > Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 public Namespaces getNamespaces (); Type: org.cdk8s.plus23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus23.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus23.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import org.cdk8s.plus23.RoleBindingProps ; RoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus23.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import org.cdk8s.plus23.RolePolicyRule ; RolePolicyRule . builder () . resources ( java . util . List < IApiResource > ) . verbs ( java . util . List < java . lang . String > ) . build (); resources Required \u00b6 public java . util . List < IApiResource > getResources (); Type: java.util.List< org.cdk8s.plus23.IApiResource > Resources this rule applies to. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import org.cdk8s.plus23.RoleProps ; RoleProps . builder () // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus23.RolePolicyRule > Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import org.cdk8s.plus23.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus23.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus23.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import org.cdk8s.plus23.SecretVolumeOptions ; SecretVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:10036\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus23.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus23.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import org.cdk8s.plus23.ServiceAccountTokenSecretProps ; ServiceAccountTokenSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import org.cdk8s.plus23.ServiceBindOptions ; ServiceBindOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus23.ServiceIngressBackendOptions ; ServiceIngressBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus23.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import org.cdk8s.plus23.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .selector(IPodSelector) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus23.ServicePort > Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 public IPodSelector getSelector (); Type: org.cdk8s.plus23.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus23.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import org.cdk8s.plus23.SshAuthSecretProps ; SshAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public java . lang . String getSshPrivateKey (); Type: java.lang.String The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus23.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 public Service getService (); Type: org.cdk8s.plus23.Service Service to associate with the statefulset. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus23.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus23.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus23.StatefulSetUpdateStrategyRollingUpdateOptions ; StatefulSetUpdateStrategyRollingUpdateOptions . builder () // .partition(java.lang.Number) . build (); partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import org.cdk8s.plus23.SubjectConfiguration ; SubjectConfiguration . builder () . kind ( java . lang . String ) . name ( java . lang . String ) // .apiGroup(java.lang.String) // .namespace(java.lang.String) . build (); kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import org.cdk8s.plus23.Sysctl ; Sysctl . builder () . name ( java . lang . String ) . value ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of a property to set. value Required \u00b6 public java . lang . String getValue (); Type: java.lang.String Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import org.cdk8s.plus23.TcpSocketProbeOptions ; TcpSocketProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .host(java.lang.String) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import org.cdk8s.plus23.TlsSecretProps ; TlsSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public java . lang . String getTlsCert (); Type: java.lang.String The TLS cert. tlsKey Required \u00b6 public java . lang . String getTlsKey (); Type: java.lang.String The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus23.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus23.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import org.cdk8s.plus23.WorkloadProps ; WorkloadProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus23.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus23.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus23.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import org.cdk8s.plus23.WorkloadSchedulingSpreadOptions ; WorkloadSchedulingSpreadOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus23.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: org.cdk8s.plus23.IApiResource , org.cdk8s.plus23.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus23.ApiResource ; ApiResource . custom ( ApiResourceOptions options ) options Required \u00b6 Type: org.cdk8s.plus23.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Ingress. JOBS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Job. LEASES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: org.cdk8s.plus23.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus23.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .envFrom(java.util.List<EnvFrom>) // .envVariables(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .portNumber(java.lang.Number) // .ports(java.util.List<ContainerPort>) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.EnvFrom > Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 Type: java.util.Map \u0002klzzwxh:9556\u0003 > Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: org.cdk8s.plus23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: org.cdk8s.plus23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: java.lang.Number portNumber Optional \u00b6 Type: java.lang.Number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.ContainerPort > Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: org.cdk8s.plus23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: org.cdk8s.plus23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 Type: org.cdk8s.plus23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: org.cdk8s.plus23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addPort \u00b6 public addPort ( ContainerPort port ) port Required \u00b6 Type: org.cdk8s.plus23.ContainerPort mount \u00b6 public mount ( java . lang . String path , IStorage storage ) public mount ( java . lang . String path , IStorage storage , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. storage Required \u00b6 Type: org.cdk8s.plus23.IStorage The storage to mount. options Optional \u00b6 Type: org.cdk8s.plus23.MountOptions Properties \u00b6 env Required \u00b6 public Env getEnv (); Type: org.cdk8s.plus23.Env The environment of the container. image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus23.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus23.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. ports Required \u00b6 public java . util . List < ContainerPort > getPorts (); Type: java.util.List< org.cdk8s.plus23.ContainerPort > Ports exposed by this containers. Returns a copy, use addPort to modify. securityContext Required \u00b6 public ContainerSecurityContext getSecurityContext (); Type: org.cdk8s.plus23.ContainerSecurityContext The security context of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public java . lang . Number getPort (); Type: java.lang.Number portNumber Optional \u00b6 public java . lang . Number getPortNumber (); Type: java.lang.Number The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus23.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import org.cdk8s.plus23.ContainerSecurityContext ; ContainerSecurityContext . Builder . create () // .allowPrivilegeEscalation(java.lang.Boolean) // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); allowPrivilegeEscalation Optional \u00b6 Type: java.lang.Boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: java.lang.Number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 Type: java.lang.Boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 Type: java.lang.Number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean privileged Required \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean readOnlyRootFilesystem Required \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean allowPrivilegeEscalation Optional \u00b6 public java . lang . Boolean getAllowPrivilegeEscalation (); Type: java.lang.Boolean group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import org.cdk8s.plus23.Cpu ; Cpu . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number units \u00b6 import org.cdk8s.plus23.Cpu ; Cpu . units ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Properties \u00b6 amount Required \u00b6 public java . lang . String getAmount (); Type: java.lang.String DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import org.cdk8s.plus23.DeploymentStrategy ; DeploymentStrategy . recreate () rollingUpdate \u00b6 import org.cdk8s.plus23.DeploymentStrategy ; DeploymentStrategy . rollingUpdate () DeploymentStrategy . rollingUpdate ( DeploymentStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.DeploymentStrategyRollingUpdateOptions Env \u00b6 Container environment variables. Initializers \u00b6 import org.cdk8s.plus23.Env ; new Env ( java . util . List < EnvFrom > sources , java . util . Map < java . lang . String , EnvValue > variables ); sources Required \u00b6 Type: java.util.List< org.cdk8s.plus23.EnvFrom > variables Required \u00b6 Type: java.util.Map \u0002klzzwxh:9416\u0003 > Methods \u00b6 addVariable \u00b6 public addVariable ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String value Required \u00b6 Type: org.cdk8s.plus23.EnvValue copyFrom \u00b6 public copyFrom ( EnvFrom from ) from Required \u00b6 Type: org.cdk8s.plus23.EnvFrom Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus23.Env ; Env . fromConfigMap ( IConfigMap configMap ) Env . fromConfigMap ( IConfigMap configMap , java . lang . String prefix ) configMap Required \u00b6 Type: org.cdk8s.plus23.IConfigMap prefix Optional \u00b6 Type: java.lang.String fromSecret \u00b6 import org.cdk8s.plus23.Env ; Env . fromSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus23.ISecret Properties \u00b6 sources Required \u00b6 public java . util . List < EnvFrom > getSources (); Type: java.util.List< org.cdk8s.plus23.EnvFrom > The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getVariables (); Type: java.util.Map \u0002klzzwxh:9393\u0003 > The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import org.cdk8s.plus23.EnvFrom ; new EnvFrom (); new EnvFrom ( IConfigMap configMap ); new EnvFrom ( IConfigMap configMap , java . lang . String prefix ); new EnvFrom ( IConfigMap configMap , java . lang . String prefix , ISecret sec ); configMap Optional \u00b6 Type: org.cdk8s.plus23.IConfigMap prefix Optional \u00b6 Type: java.lang.String sec Optional \u00b6 Type: org.cdk8s.plus23.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus23.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus23.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus23.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import org.cdk8s.plus23.EnvValue ; EnvValue . fromFieldRef ( EnvFieldPaths fieldPath ) EnvValue . fromFieldRef ( EnvFieldPaths fieldPath , EnvValueFromFieldRefOptions options ) fieldPath Required \u00b6 Type: org.cdk8s.plus23.EnvFieldPaths : The field reference. options Optional \u00b6 Type: org.cdk8s.plus23.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import org.cdk8s.plus23.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus23.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import org.cdk8s.plus23.EnvValue ; EnvValue . fromResource ( ResourceFieldPaths resource ) EnvValue . fromResource ( ResourceFieldPaths resource , EnvValueFromResourceOptions options ) resource Required \u00b6 Type: org.cdk8s.plus23.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: org.cdk8s.plus23.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import org.cdk8s.plus23.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus23.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus23.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus23.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus23.Handler ; Handler . fromCommand ( java . util . List < java . lang . String > command ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. fromHttpGet \u00b6 import org.cdk8s.plus23.Handler ; Handler . fromHttpGet ( java . lang . String path ) Handler . fromHttpGet ( java . lang . String path , HandlerFromHttpGetOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus23.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus23.Handler ; Handler . fromTcpSocket () Handler . fromTcpSocket ( HandlerFromTcpSocketOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromResource \u00b6 import org.cdk8s.plus23.IngressBackend ; IngressBackend . fromResource ( IResource resource ) resource Required \u00b6 Type: org.cdk8s.plus23.IResource fromService \u00b6 import org.cdk8s.plus23.IngressBackend ; IngressBackend . fromService ( Service serv ) IngressBackend . fromService ( Service serv , ServiceIngressBackendOptions options ) serv Required \u00b6 Type: org.cdk8s.plus23.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus23.ServiceIngressBackendOptions LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import org.cdk8s.plus23.LabeledNode ; new LabeledNode ( java . util . List < NodeLabelQuery > labelSelector ); labelSelector Required \u00b6 Type: java.util.List< org.cdk8s.plus23.NodeLabelQuery > Properties \u00b6 labelSelector Required \u00b6 public java . util . List < NodeLabelQuery > getLabelSelector (); Type: java.util.List< org.cdk8s.plus23.NodeLabelQuery > LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus23.LabelExpression ; LabelExpression . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus23.LabelExpression ; LabelExpression . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String in \u00b6 import org.cdk8s.plus23.LabelExpression ; LabelExpression . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > notIn \u00b6 import org.cdk8s.plus23.LabelExpression ; LabelExpression . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 isEmpty \u00b6 public isEmpty () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus23.LabelSelector ; LabelSelector . of () LabelSelector . of ( LabelSelectorOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.LabelSelectorOptions NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import org.cdk8s.plus23.NamedNode ; new NamedNode ( java . lang . String name ); name Required \u00b6 Type: java.lang.String Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 allTcp \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . allTcp () allUdp \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . allUdp () of \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . of ( NetworkPolicyPortProps props ) props Required \u00b6 Type: org.cdk8s.plus23.NetworkPolicyPortProps tcp \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . tcp ( java . lang . Number port ) port Required \u00b6 Type: java.lang.Number tcpRange \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . tcpRange ( java . lang . Number startPort , java . lang . Number endPort ) startPort Required \u00b6 Type: java.lang.Number endPort Required \u00b6 Type: java.lang.Number udp \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . udp ( java . lang . Number port ) port Required \u00b6 Type: java.lang.Number udpRange \u00b6 import org.cdk8s.plus23.NetworkPolicyPort ; NetworkPolicyPort . udpRange ( java . lang . Number startPort , java . lang . Number endPort ) startPort Required \u00b6 Type: java.lang.Number endPort Required \u00b6 Type: java.lang.Number Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import org.cdk8s.plus23.Node ; new Node (); Static Functions \u00b6 labeled \u00b6 import org.cdk8s.plus23.Node ; Node . labeled ( NodeLabelQuery labelSelector ) labelSelector Required \u00b6 Type: org.cdk8s.plus23.NodeLabelQuery named \u00b6 import org.cdk8s.plus23.Node ; Node . named ( java . lang . String nodeName ) nodeName Required \u00b6 Type: java.lang.String tainted \u00b6 import org.cdk8s.plus23.Node ; Node . tainted ( NodeTaintQuery taintSelector ) taintSelector Required \u00b6 Type: org.cdk8s.plus23.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String gt \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . gt ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > in \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > is \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . is ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String lt \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . lt ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > notIn \u00b6 import org.cdk8s.plus23.NodeLabelQuery ; NodeLabelQuery . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import org.cdk8s.plus23.NodeTaintQuery ; NodeTaintQuery . any () exists \u00b6 import org.cdk8s.plus23.NodeTaintQuery ; NodeTaintQuery . exists ( java . lang . String key ) NodeTaintQuery . exists ( java . lang . String key , NodeTaintQueryOptions options ) key Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.NodeTaintQueryOptions is \u00b6 import org.cdk8s.plus23.NodeTaintQuery ; NodeTaintQuery . is ( java . lang . String key , java . lang . String value ) NodeTaintQuery . is ( java . lang . String key , java . lang . String value , NodeTaintQueryOptions options ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus23.NodeTaintQueryOptions NonApiResource \u00b6 Implements: org.cdk8s.plus23.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus23.NonApiResource ; NonApiResource . of ( java . lang . String url ) url Required \u00b6 Type: java.lang.String PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import org.cdk8s.plus23.PercentOrAbsolute ; PercentOrAbsolute . absolute ( java . lang . Number num ) num Required \u00b6 Type: java.lang.Number percent \u00b6 import org.cdk8s.plus23.PercentOrAbsolute ; PercentOrAbsolute . percent ( java . lang . Number percent ) percent Required \u00b6 Type: java.lang.Number Properties \u00b6 value Required \u00b6 public java . lang . Object getValue (); Type: java.lang.Object PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import org.cdk8s.plus23.PodConnections ; new PodConnections ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus23.AbstractPod Methods \u00b6 allowFrom \u00b6 public allowFrom ( INetworkPolicyPeer peer ) public allowFrom ( INetworkPolicyPeer peer , PodConnectionsAllowFromOptions options ) peer Required \u00b6 Type: org.cdk8s.plus23.INetworkPolicyPeer options Optional \u00b6 Type: org.cdk8s.plus23.PodConnectionsAllowFromOptions allowTo \u00b6 public allowTo ( INetworkPolicyPeer peer ) public allowTo ( INetworkPolicyPeer peer , PodConnectionsAllowToOptions options ) peer Required \u00b6 Type: org.cdk8s.plus23.INetworkPolicyPeer options Optional \u00b6 Type: org.cdk8s.plus23.PodConnectionsAllowToOptions PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import org.cdk8s.plus23.PodDns ; PodDns . Builder . create () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: org.cdk8s.plus23.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 addNameserver \u00b6 public addNameserver ( java . lang . String nameservers ) nameservers Required \u00b6 Type: java.lang.String addOption \u00b6 public addOption ( DnsOption options ) options Required \u00b6 Type: org.cdk8s.plus23.DnsOption addSearch \u00b6 public addSearch ( java . lang . String searches ) searches Required \u00b6 Type: java.lang.String Properties \u00b6 hostnameAsFQDN Required \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > Nameservers defined for this pod. options Required \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus23.DnsOption > Custom dns options defined for this pod. policy Required \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus23.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > Search domains defined for this pod. hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import org.cdk8s.plus23.PodScheduling ; new PodScheduling ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus23.AbstractPod Methods \u00b6 assign \u00b6 public assign ( NamedNode node ) node Required \u00b6 Type: org.cdk8s.plus23.NamedNode attract \u00b6 public attract ( LabeledNode node ) public attract ( LabeledNode node , PodSchedulingAttractOptions options ) node Required \u00b6 Type: org.cdk8s.plus23.LabeledNode options Optional \u00b6 Type: org.cdk8s.plus23.PodSchedulingAttractOptions colocate \u00b6 public colocate ( IPodSelector selector ) public colocate ( IPodSelector selector , PodSchedulingColocateOptions options ) selector Required \u00b6 Type: org.cdk8s.plus23.IPodSelector options Optional \u00b6 Type: org.cdk8s.plus23.PodSchedulingColocateOptions separate \u00b6 public separate ( IPodSelector selector ) public separate ( IPodSelector selector , PodSchedulingSeparateOptions options ) selector Required \u00b6 Type: org.cdk8s.plus23.IPodSelector options Optional \u00b6 Type: org.cdk8s.plus23.PodSchedulingSeparateOptions tolerate \u00b6 public tolerate ( TaintedNode node ) node Required \u00b6 Type: org.cdk8s.plus23.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import org.cdk8s.plus23.PodSecurityContext ; PodSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 Type: org.cdk8s.plus23.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: java.util.List< org.cdk8s.plus23.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean fsGroupChangePolicy Required \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus23.FsGroupChangePolicy sysctls Required \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus23.Sysctl > fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus23.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus23.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus23.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus23.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus23.Probe ; Probe . fromTcpSocket () Probe . fromTcpSocket ( TcpSocketProbeOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.TcpSocketProbeOptions Options. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import org.cdk8s.plus23.ResourcePermissions ; new ResourcePermissions ( Resource instance ); instance Required \u00b6 Type: org.cdk8s.plus23.Resource Methods \u00b6 grantRead \u00b6 public grantRead ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject grantReadWrite \u00b6 public grantReadWrite ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus23.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import org.cdk8s.plus23.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import org.cdk8s.plus23.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . rollingUpdate () StatefulSetUpdateStrategy . rollingUpdate ( StatefulSetUpdateStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.StatefulSetUpdateStrategyRollingUpdateOptions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import org.cdk8s.plus23.TaintedNode ; new TaintedNode ( java . util . List < NodeTaintQuery > taintSelector ); taintSelector Required \u00b6 Type: java.util.List< org.cdk8s.plus23.NodeTaintQuery > Properties \u00b6 taintSelector Required \u00b6 public java . util . List < NodeTaintQuery > getTaintSelector (); Type: java.util.List< org.cdk8s.plus23.NodeTaintQuery > Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus23.Topology ; Topology . custom ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String Constants \u00b6 HOSTNAME \u00b6 Type: org.cdk8s.plus23.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: org.cdk8s.plus23.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: org.cdk8s.plus23.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import org.cdk8s.plus23.WorkloadScheduling ; new WorkloadScheduling ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus23.AbstractPod Methods \u00b6 spread \u00b6 public spread () public spread ( WorkloadSchedulingSpreadOptions options ) options Optional \u00b6 Type: org.cdk8s.plus23.WorkloadSchedulingSpreadOptions Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.ApiResource , org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.ClusterRoleBinding , org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.Ingress , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.NetworkPolicy , org.cdk8s.plus23.NonApiResource , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Resource , org.cdk8s.plus23.Role , org.cdk8s.plus23.RoleBinding , org.cdk8s.plus23.Secret , org.cdk8s.plus23.Service , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.ApiResource , org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.ClusterRoleBinding , org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.Ingress , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.NetworkPolicy , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Resource , org.cdk8s.plus23.Role , org.cdk8s.plus23.RoleBinding , org.cdk8s.plus23.Secret , org.cdk8s.plus23.Service , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IConfigMap \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.Namespace , org.cdk8s.plus23.Namespaces , org.cdk8s.plus23.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.Namespaces , org.cdk8s.plus23.NetworkPolicyIpBlock , org.cdk8s.plus23.Pod , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.Workload , org.cdk8s.plus23.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. IPersistentVolume \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSelector \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.Job , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Pods , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IPodSelector Represents an object that can select pods. Methods \u00b6 toPodSelectorConfig \u00b6 public toPodSelectorConfig () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. IResource \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.ClusterRoleBinding , org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.Ingress , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.NetworkPolicy , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Resource , org.cdk8s.plus23.Role , org.cdk8s.plus23.RoleBinding , org.cdk8s.plus23.Secret , org.cdk8s.plus23.Service , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IClusterRole , org.cdk8s.plus23.IConfigMap , org.cdk8s.plus23.IPersistentVolume , org.cdk8s.plus23.IPersistentVolumeClaim , org.cdk8s.plus23.IResource , org.cdk8s.plus23.IRole , org.cdk8s.plus23.ISecret , org.cdk8s.plus23.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IRole \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.Role , org.cdk8s.plus23.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.Secret , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.ISecret Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.IServiceAccount Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IStorage \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.Volume , org.cdk8s.plus23.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. ISubject \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.Group , org.cdk8s.plus23.Job , org.cdk8s.plus23.Pod , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.User , org.cdk8s.plus23.Workload , org.cdk8s.plus23.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. Pods that tolerate the taint without specifying duration remain bound forever. Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"Java"},{"location":"reference/cdk8s-plus-23/java/#cdk8s-plus-23-java","text":"","title":"cdk8s-plus-23 (Java) "},{"location":"reference/cdk8s-plus-23/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-23/java/#abstractpod","text":"Implements: org.cdk8s.plus23.IPodSelector , org.cdk8s.plus23.INetworkPolicyPeer , org.cdk8s.plus23.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-23/java/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-23/java/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-23/java/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-23/java/#clusterrole","text":"Implements: org.cdk8s.plus23.IClusterRole , org.cdk8s.plus23.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-23/java/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-23/java/#configmap","text":"Implements: org.cdk8s.plus23.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-23/java/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-23/java/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-23/java/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-23/java/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-23/java/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-23/java/#group","text":"Implements: org.cdk8s.plus23.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-23/java/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-23/java/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-23/java/#namespace","text":"Implements: org.cdk8s.plus23.INamespaceSelector , org.cdk8s.plus23.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-23/java/#namespaces","text":"Implements: org.cdk8s.plus23.INamespaceSelector , org.cdk8s.plus23.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-23/java/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-23/java/#networkpolicyipblock","text":"Implements: org.cdk8s.plus23.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-23/java/#persistentvolume","text":"Implements: org.cdk8s.plus23.IPersistentVolume , org.cdk8s.plus23.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumeclaim","text":"Implements: org.cdk8s.plus23.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-23/java/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-23/java/#pods","text":"Implements: org.cdk8s.plus23.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-23/java/#resource","text":"Implements: org.cdk8s.plus23.IResource , org.cdk8s.plus23.IApiResource , org.cdk8s.plus23.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-23/java/#role","text":"Implements: org.cdk8s.plus23.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-23/java/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-23/java/#secret","text":"Implements: org.cdk8s.plus23.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-23/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-23/java/#serviceaccount","text":"Implements: org.cdk8s.plus23.IServiceAccount , org.cdk8s.plus23.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-23/java/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-23/java/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-23/java/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-23/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-23/java/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-23/java/#user","text":"Implements: org.cdk8s.plus23.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-23/java/#volume","text":"Implements: org.cdk8s.plus23.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-23/java/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-23/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-23/java/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-23/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-23/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-23/java/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-23/java/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/java/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/java/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-23/java/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-23/java/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-23/java/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-23/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-23/java/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-23/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-23/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-23/java/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-23/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-23/java/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-23/java/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-23/java/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-23/java/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-23/java/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-23/java/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-23/java/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-23/java/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-23/java/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-23/java/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-23/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-23/java/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-23/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-23/java/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-23/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-23/java/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-23/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-23/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-23/java/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/java/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-23/java/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-23/java/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-23/java/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-23/java/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-23/java/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-23/java/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-23/java/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-23/java/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-23/java/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-23/java/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-23/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-23/java/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-23/java/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-23/java/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-23/java/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-23/java/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-23/java/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-23/java/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-23/java/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-23/java/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-23/java/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-23/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/java/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-23/java/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-23/java/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-23/java/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-23/java/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-23/java/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-23/java/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-23/java/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-23/java/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-23/java/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-23/java/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-23/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-23/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-23/java/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-23/java/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-23/java/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-23/java/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-23/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-23/java/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-23/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-23/java/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-23/java/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-23/java/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-23/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-23/java/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-23/java/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-23/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-23/java/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-23/java/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-23/java/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-23/java/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-23/java/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-23/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-23/java/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-23/java/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-23/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-23/java/#apiresource","text":"Implements: org.cdk8s.plus23.IApiResource , org.cdk8s.plus23.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-23/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-23/java/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-23/java/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-23/java/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-23/java/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-23/java/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-23/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-23/java/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-23/java/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-23/java/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-23/java/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-23/java/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-23/java/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-23/java/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-23/java/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-23/java/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-23/java/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-23/java/#nonapiresource","text":"Implements: org.cdk8s.plus23.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-23/java/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-23/java/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-23/java/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-23/java/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-23/java/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-23/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-23/java/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-23/java/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-23/java/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-23/java/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-23/java/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-23/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-23/java/#iapiendpoint","text":"Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.ApiResource , org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.ClusterRoleBinding , org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.Ingress , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.NetworkPolicy , org.cdk8s.plus23.NonApiResource , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Resource , org.cdk8s.plus23.Role , org.cdk8s.plus23.RoleBinding , org.cdk8s.plus23.Secret , org.cdk8s.plus23.Service , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-23/java/#iapiresource","text":"Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.ApiResource , org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.ClusterRoleBinding , org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.Ingress , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.NetworkPolicy , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Resource , org.cdk8s.plus23.Role , org.cdk8s.plus23.RoleBinding , org.cdk8s.plus23.Secret , org.cdk8s.plus23.Service , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-23/java/#iclusterrole","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-23/java/#iconfigmap","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-23/java/#inamespaceselector","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.Namespace , org.cdk8s.plus23.Namespaces , org.cdk8s.plus23.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-23/java/#inetworkpolicypeer","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.Namespaces , org.cdk8s.plus23.NetworkPolicyIpBlock , org.cdk8s.plus23.Pod , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.Workload , org.cdk8s.plus23.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-23/java/#ipersistentvolume","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-23/java/#ipersistentvolumeclaim","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-23/java/#ipodselector","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.Job , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Pods , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-23/java/#iresource","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.ClusterRoleBinding , org.cdk8s.plus23.ConfigMap , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.Ingress , org.cdk8s.plus23.Job , org.cdk8s.plus23.Namespace , org.cdk8s.plus23.NetworkPolicy , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.PersistentVolumeClaim , org.cdk8s.plus23.Pod , org.cdk8s.plus23.Resource , org.cdk8s.plus23.Role , org.cdk8s.plus23.RoleBinding , org.cdk8s.plus23.Secret , org.cdk8s.plus23.Service , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.Workload , org.cdk8s.plus23.IClusterRole , org.cdk8s.plus23.IConfigMap , org.cdk8s.plus23.IPersistentVolume , org.cdk8s.plus23.IPersistentVolumeClaim , org.cdk8s.plus23.IResource , org.cdk8s.plus23.IRole , org.cdk8s.plus23.ISecret , org.cdk8s.plus23.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-23/java/#irole","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ClusterRole , org.cdk8s.plus23.Role , org.cdk8s.plus23.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-23/java/#isecret","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.BasicAuthSecret , org.cdk8s.plus23.DockerConfigSecret , org.cdk8s.plus23.Secret , org.cdk8s.plus23.ServiceAccountTokenSecret , org.cdk8s.plus23.SshAuthSecret , org.cdk8s.plus23.TlsSecret , org.cdk8s.plus23.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-23/java/#iserviceaccount","text":"Extends: org.cdk8s.plus23.IResource Implemented By: org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-23/java/#istorage","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus23.AzureDiskPersistentVolume , org.cdk8s.plus23.GCEPersistentDiskPersistentVolume , org.cdk8s.plus23.PersistentVolume , org.cdk8s.plus23.Volume , org.cdk8s.plus23.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-23/java/#isubject","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus23.AbstractPod , org.cdk8s.plus23.CronJob , org.cdk8s.plus23.DaemonSet , org.cdk8s.plus23.Deployment , org.cdk8s.plus23.Group , org.cdk8s.plus23.Job , org.cdk8s.plus23.Pod , org.cdk8s.plus23.ServiceAccount , org.cdk8s.plus23.StatefulSet , org.cdk8s.plus23.User , org.cdk8s.plus23.Workload , org.cdk8s.plus23.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-23/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-23/java/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-23/java/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-23/java/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-23/java/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-23/java/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-23/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-23/java/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-23/java/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-23/java/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-23/java/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-23/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-23/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-23/java/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-23/java/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-23/java/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-23/java/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-23/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-23/java/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-23/java/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-23/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-23/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-23/java/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-23/python/","text":"cdk8s-plus-23 (Python) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: cdk8s_plus_23.IPodSelector , cdk8s_plus_23.INetworkPolicyPeer , cdk8s_plus_23.ISubject Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AbstractPod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_23.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_23.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_23.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_host_alias \u00b6 def add_host_alias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 Type: str IP address of the host file entry. add_init_container \u00b6 def add_init_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_23.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_23.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_23.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( vol : Volume ) vol Required \u00b6 Type: cdk8s_plus_23.Volume to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () to_pod_selector_config \u00b6 def to_pod_selector_config () to_subject_configuration \u00b6 def to_subject_configuration () Properties \u00b6 automount_service_account_token Required \u00b6 automount_service_account_token : bool Type: bool containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_23.Container ] dns Required \u00b6 dns : PodDns Type: cdk8s_plus_23.PodDns host_aliases Required \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] init_containers Required \u00b6 init_containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_23.Container ] pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition security_context Required \u00b6 security_context : PodSecurityContext Type: cdk8s_plus_23.PodSecurityContext volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AwsElasticBlockStorePersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. volume_id Required \u00b6 volume_id : str Type: str Volume id of this volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AzureDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 Type: cdk8s_plus_23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azure_kind Required \u00b6 azure_kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_23.AzureDiskPersistentVolumeKind Azure kind of this volume. caching_mode Required \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_23.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. disk_name Required \u00b6 disk_name : str Type: str Disk name of this volume. disk_uri Required \u00b6 disk_uri : str Type: str Disk URI of this volume. fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . BasicAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: str The password or token for authentication. username Required \u00b6 Type: str The user name for authentication. ClusterRole \u00b6 Implements: cdk8s_plus_23.IClusterRole , cdk8s_plus_23.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ClusterRole ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 def aggregate ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str allow \u00b6 def allow ( verbs : typing . List [ str ], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: typing.List[ str ] endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The endpoints(s) to apply to. allow_create \u00b6 def allow_create ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_get \u00b6 def allow_get ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_list \u00b6 def allow_list ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_read \u00b6 def allow_read ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_update \u00b6 def allow_update ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_23.IApiEndpoint The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_23.ISubject a list of subjects to bind to. bind_in_namespace \u00b6 def bind_in_namespace ( namespace : str , subjects : ISubject ) namespace Required \u00b6 Type: str the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s_plus_23.ISubject a list of subjects to bind to. combine \u00b6 def combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s_plus_23.ClusterRole Static Functions \u00b6 from_cluster_role_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ClusterRole . from_cluster_role_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_23.ClusterRolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ClusterRoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IClusterRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_23.IClusterRole The role to bind to. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_23.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_23.IClusterRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_23.ISubject ] ConfigMap \u00b6 Implements: cdk8s_plus_23.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ConfigMap . from_config_map_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 immutable : bool Type: bool Whether or not this config map is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . CronJob ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None , schedule : Cron , concurrency_policy : ConcurrencyPolicy = None , failed_jobs_retained : typing . Union [ int , float ] = None , starting_deadline : Duration = None , successful_jobs_retained : typing . Union [ int , float ] = None , suspend : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrency_policy Optional \u00b6 Type: cdk8s_plus_23.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failed_jobs_retained Optional \u00b6 Type: typing.Union[int, float] Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. starting_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successful_jobs_retained Optional \u00b6 Type: typing.Union[int, float] Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 Type: bool Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. Properties \u00b6 concurrency_policy Required \u00b6 concurrency_policy : str Type: str The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failed_jobs_retained Required \u00b6 failed_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] The number of failed jobs retained by this cron job. resource_type Required \u00b6 resource_type : str Type: str Represents the resource type. schedule Required \u00b6 schedule : Cron Type: cdk8s.Cron The schedule this cron job is scheduled to run in. starting_deadline Required \u00b6 starting_deadline : Duration Type: cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successful_jobs_retained Required \u00b6 successful_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] The number of successful jobs retained by this cron job. suspend Required \u00b6 suspend : bool Type: bool Whether or not the cron job is currently suspended or not. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DaemonSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready_seconds Optional \u00b6 Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 min_ready_seconds Required \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: typing.Union[int, float] Default: 2 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_23.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 Type: cdk8s_plus_23.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 Type: cdk8s_plus_23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. expose_via_service \u00b6 def expose_via_service ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None ) name Optional \u00b6 Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 Type: cdk8s_plus_23.ServiceType Default: ClusterIP. The type of the exposed service. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progress_deadline Required \u00b6 progress_deadline : Duration Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_23.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DockerConfigSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . GCEPersistentDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. pd_name Required \u00b6 pd_name : str Type: str PD resource in GCE of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. Group \u00b6 Implements: cdk8s_plus_23.ISubject Represents a group. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Group . from_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 kind Required \u00b6 kind : str Type: str name Required \u00b6 name : str Type: str api_group Optional \u00b6 api_group : str Type: str Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Ingress ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_23.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_23.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_23.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s_plus_23.IngressBackend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressBackend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_23.IngressBackend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_23.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_23.HttpIngressPathType How the path is matched against request paths. add_rule \u00b6 def add_rule ( path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_23.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_23.HttpIngressPathType How the path is matched against request paths. add_rules \u00b6 def add_rules ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 Type: cdk8s_plus_23.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 Type: cdk8s_plus_23.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types add_tls \u00b6 def add_tls ( tls : typing . List [ IngressTls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_23.IngressTls ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: cdk8s_plus_23.INamespaceSelector , cdk8s_plus_23.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Namespace ( scope : Construct , id : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: str https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: cdk8s_plus_23.INamespaceSelector , cdk8s_plus_23.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Namespaces ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , names : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_23.LabelExpression ] names Optional \u00b6 Type: typing.List[ str ] labels Optional \u00b6 Type: typing.Mapping[ str ] Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Static Functions \u00b6 all \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Namespaces . all ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str select \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Namespaces . select ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , names : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_23.LabelExpression ] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 Type: typing.List[ str ] Default: no name requirements. Namespaces names must be one of these. NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicy ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , egress : NetworkPolicyTraffic = None , ingress : NetworkPolicyTraffic = None , selector : IPodSelector = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 Type: cdk8s_plus_23.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 Type: cdk8s_plus_23.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 Type: cdk8s_plus_23.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that Methods \u00b6 add_egress_rule \u00b6 def add_egress_rule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_23.INetworkPolicyPeer ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] add_ingress_rule \u00b6 def add_ingress_rule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_23.INetworkPolicyPeer ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: cdk8s_plus_23.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Static Functions \u00b6 any_ipv4 \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyIpBlock . any_ipv4 ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str any_ipv6 \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyIpBlock . any_ipv6 ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str ipv4 \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyIpBlock . ipv4 ( scope : Construct , id : str , cidr_ip : str , except : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str cidr_ip Required \u00b6 Type: str except Optional \u00b6 Type: typing.List[ str ] ipv6 \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyIpBlock . ipv6 ( scope : Construct , id : str , cidr_ip : str , except : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str cidr_ip Required \u00b6 Type: str except Optional \u00b6 Type: typing.List[ str ] Properties \u00b6 cidr Required \u00b6 cidr : str Type: str A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 except : typing . List [ str ] Type: typing.List[ str ] A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: cdk8s_plus_23.IPersistentVolume , cdk8s_plus_23.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 as_volume \u00b6 def as_volume () bind \u00b6 def bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s_plus_23.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 def reserve () Static Functions \u00b6 from_persistent_volume_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolume . from_persistent_volume_name ( scope : Construct , id : str , volume_name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str volume_name Required \u00b6 Type: str Properties \u00b6 mode Required \u00b6 mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Volume mode of this volume. reclaim_policy Required \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Access modes requirement of this claim. claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_23.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Mount options of this volume. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage size of this volume. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s_plus_23.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolumeClaim ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: cdk8s_plus_23.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 def bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s_plus_23.IPersistentVolume The PV to bind to. Static Functions \u00b6 from_claim_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolumeClaim . from_claim_name ( scope : Construct , id : str , claim_name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str claim_name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. volume_mode Required \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Volume mode requirement of this claim. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Access modes requirement of this claim. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage requirement of this claim. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class requirment of this claim. volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_23.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 connections Required \u00b6 connections : PodConnections Type: cdk8s_plus_23.PodConnections pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 scheduling : PodScheduling Type: cdk8s_plus_23.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: str This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: cdk8s_plus_23.IPodSelector Represents a group of pods. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Pods ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : INamespaceSelector = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_23.LabelExpression ] labels Optional \u00b6 Type: typing.Mapping[ str ] namespaces Optional \u00b6 Type: cdk8s_plus_23.INamespaceSelector Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () to_pod_selector_config \u00b6 def to_pod_selector_config () Static Functions \u00b6 all \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Pods . all ( scope : Construct , id : str , namespaces : Namespaces = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str namespaces Optional \u00b6 Type: cdk8s_plus_23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. select \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Pods . select ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : Namespaces = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_23.LabelExpression ] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 Type: cdk8s_plus_23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. Resource \u00b6 Implements: cdk8s_plus_23.IResource , cdk8s_plus_23.IApiResource , cdk8s_plus_23.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Resource ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. permissions Required \u00b6 permissions : ResourcePermissions Type: cdk8s_plus_23.ResourcePermissions resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s_plus_23.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Role ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_23.RolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 def allow ( verbs : typing . List [ str ], resources : IApiResource ) verbs Required \u00b6 Type: typing.List[ str ] resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_create \u00b6 def allow_create ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_get \u00b6 def allow_get ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_list \u00b6 def allow_list ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_read \u00b6 def allow_read ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_update \u00b6 def allow_update ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_23.IApiResource The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_23.ISubject a list of subjects to bind to. Static Functions \u00b6 from_role_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Role . from_role_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_23.RolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . RoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_23.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_23.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IRole Type: cdk8s_plus_23.IRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_23.ISubject ] Secret \u00b6 Implements: cdk8s_plus_23.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Secret . from_secret_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 immutable Required \u00b6 immutable : bool Type: bool Whether or not the secret is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , selector : IPodSelector = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ServicePort ] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 Type: cdk8s_plus_23.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 Type: cdk8s_plus_23.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 bind \u00b6 def bind ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. select \u00b6 def select ( selector : IPodSelector ) selector Required \u00b6 Type: cdk8s_plus_23.IPodSelector select_label \u00b6 def select_label ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_23.ServicePort ] Ports for this service. Use bind() to bind additional service ports. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 type : ServiceType Type: cdk8s_plus_23.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_23.IServiceAccount , cdk8s_plus_23.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 Type: bool Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_23.ISecret The secret. to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceAccount . from_service_account_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 automount_token Required \u00b6 automount_token : bool Type: bool Whether or not a token is automatically mounted for this service account. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_23.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceAccountTokenSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 Type: cdk8s_plus_23.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . SshAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 Type: str The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 Type: cdk8s_plus_23.Service Service to associate with the statefulset. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 Type: cdk8s_plus_23.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_23.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_23.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_23.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . TlsSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 Type: str The TLS cert. tls_key Required \u00b6 Type: str The TLS key. User \u00b6 Implements: cdk8s_plus_23.ISubject Represents a user. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_name \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . User . from_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 kind Required \u00b6 kind : str Type: str name Required \u00b6 name : str Type: str api_group Optional \u00b6 api_group : str Type: str Volume \u00b6 Implements: cdk8s_plus_23.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 as_volume \u00b6 def as_volume () Static Functions \u00b6 from_aws_elastic_block_store \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_aws_elastic_block_store ( scope : Construct , id : str , volume_id : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str volume_id Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_azure_disk \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_azure_disk ( scope : Construct , id : str , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str disk_name Required \u00b6 Type: str disk_uri Required \u00b6 Type: str caching_mode Optional \u00b6 Type: cdk8s_plus_23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 Type: str Default: auto-generated The volume name. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. from_config_map \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_config_map ( scope : Construct , id : str , config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str config_map Required \u00b6 Type: cdk8s_plus_23.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_23.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_empty_dir ( scope : Construct , id : str , name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_23.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. from_gce_persistent_disk \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_gce_persistent_disk ( scope : Construct , id : str , pd_name : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str pd_name Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_host_path \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_host_path ( scope : Construct , id : str , name : str , path : str , type : HostPathVolumeType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str path Required \u00b6 Type: str The path of the directory on the host. type Optional \u00b6 Type: cdk8s_plus_23.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. from_persistent_volume_claim \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_persistent_volume_claim ( scope : Construct , id : str , claim : IPersistentVolumeClaim , name : str = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str claim Required \u00b6 Type: cdk8s_plus_23.IPersistentVolumeClaim name Optional \u00b6 Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. from_secret \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Volume . from_secret ( scope : Construct , id : str , secr : ISecret , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str secr Required \u00b6 Type: cdk8s_plus_23.ISecret The secret to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_23.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the secret or its keys must be defined. Properties \u00b6 name Required \u00b6 name : str Type: str Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Workload ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints Methods \u00b6 select \u00b6 def select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s_plus_23.LabelSelector Properties \u00b6 connections Required \u00b6 connections : PodConnections Type: cdk8s_plus_23.PodConnections match_expressions Required \u00b6 match_expressions : typing . List [ LabelSelectorRequirement ] Type: typing.List[ cdk8s_plus_23.LabelSelectorRequirement ] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. match_labels Required \u00b6 match_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 scheduling : WorkloadScheduling Type: cdk8s_plus_23.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AbstractPodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ApiResourceOptions ( api_group : str , resource_type : str ) api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AwsElasticBlockStorePersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 volume_id : str Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AwsElasticBlockStoreVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AzureDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 disk_name : str Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 disk_uri : str Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . AzureDiskVolumeOptions ( caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . BasicAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 password : str Type: str The password or token for authentication. username Required \u00b6 username : str Type: str The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ClusterRoleBindingProps ( metadata : ApiObjectMetadata = None , role : IClusterRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_23.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ClusterRolePolicyRule ( endpoints : typing . List [ IApiEndpoint ], verbs : typing . List [ str ] ) endpoints Required \u00b6 endpoints : typing . List [ IApiEndpoint ] Type: typing.List[ cdk8s_plus_23.IApiEndpoint ] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ClusterRoleProps ( metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 aggregation_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_23.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . CommonSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_23.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ContainerLifecycle ( post_start : Handler = None , pre_stop : Handler = None ) post_start Optional \u00b6 post_start : Handler Type: cdk8s_plus_23.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. pre_stop Optional \u00b6 pre_stop : Handler Type: cdk8s_plus_23.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ContainerPort ( number : typing . Union [ int , float ], host_ip : str = None , host_port : typing . Union [ int , float ] = None , name : str = None , protocol : Protocol = None ) number Required \u00b6 number : typing . Union [ int , float ] Type: typing.Union[int, float] Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. host_ip Optional \u00b6 host_ip : str Type: str Default: 127.0.0.1. What host IP to bind the external port to. host_port Optional \u00b6 host_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 name : str Type: str Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_23.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 env_from : typing . List [ EnvFrom ] Type: typing.List[ cdk8s_plus_23.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 env_variables : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_23.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 lifecycle : ContainerLifecycle Type: cdk8s_plus_23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . port : typing . Union [ int , float ] Type: typing.Union[int, float] port_number Optional \u00b6 port_number : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 ports : typing . List [ ContainerPort ] Type: typing.List[ cdk8s_plus_23.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 security_context : ContainerSecurityContextProps Type: cdk8s_plus_23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 startup : Probe Type: cdk8s_plus_23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_23.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ContainerResources ( cpu : CpuResources = None , ephemeral_storage : EphemeralStorageResources = None , memory : MemoryResources = None ) cpu Optional \u00b6 cpu : CpuResources Type: cdk8s_plus_23.CpuResources ephemeral_storage Optional \u00b6 ephemeral_storage : EphemeralStorageResources Type: cdk8s_plus_23.EphemeralStorageResources memory Optional \u00b6 memory : MemoryResources Type: cdk8s_plus_23.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ContainerSecurityContextProps ( allow_privilege_escalation : bool = None , ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) allow_privilege_escalation Optional \u00b6 allow_privilege_escalation : bool Type: bool Default: false Whether a process can gain more privileges than its parent process. ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 privileged : bool Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 read_only_root_filesystem : bool Type: bool Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . CpuResources ( limit : Cpu = None , request : Cpu = None ) limit Optional \u00b6 limit : Cpu Type: cdk8s_plus_23.Cpu request Optional \u00b6 request : Cpu Type: cdk8s_plus_23.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . CronJobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None , schedule : Cron , concurrency_policy : ConcurrencyPolicy = None , failed_jobs_retained : typing . Union [ int , float ] = None , starting_deadline : Duration = None , successful_jobs_retained : typing . Union [ int , float ] = None , suspend : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 schedule : Cron Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrency_policy Optional \u00b6 concurrency_policy : ConcurrencyPolicy Type: cdk8s_plus_23.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failed_jobs_retained Optional \u00b6 failed_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. starting_deadline Optional \u00b6 starting_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successful_jobs_retained Optional \u00b6 successful_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 suspend : bool Type: bool Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DaemonSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready_seconds Optional \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DeploymentExposeViaServiceOptions ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None ) name Optional \u00b6 name : str Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_23.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_23.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DeploymentProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 progress_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 2 Number of desired pods. strategy Optional \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_23.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DeploymentStrategyRollingUpdateOptions ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 max_surge : PercentOrAbsolute Type: cdk8s_plus_23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 max_unavailable : PercentOrAbsolute Type: cdk8s_plus_23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DnsOption ( name : str , value : str = None ) name Required \u00b6 name : str Type: str Option name. value Optional \u00b6 value : str Type: str Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DockerConfigSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 data : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_23.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValueFromFieldRefOptions ( api_version : str = None , key : str = None ) api_version Optional \u00b6 api_version : str Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 key : str Type: str The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValueFromResourceOptions ( container : Container = None , divisor : str = None ) container Optional \u00b6 container : Container Type: cdk8s_plus_23.Container The container to select the value from. divisor Optional \u00b6 divisor : str Type: str The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EphemeralStorageResources ( limit : Size = None , request : Size = None ) limit Optional \u00b6 limit : Size Type: cdk8s.Size request Optional \u00b6 request : Size Type: cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ExposeDeploymentViaIngressOptions ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) name Optional \u00b6 name : str Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_23.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_23.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ExposeServiceViaIngressOptions ( ingress : Ingress = None , path_type : HttpIngressPathType = None ) ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . GCEPersistentDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 pd_name : str Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . GCEPersistentDiskVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . HandlerFromHttpGetOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . HandlerFromTcpSocketOptions ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . HostAlias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 hostnames : typing . List [ str ] Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 ip : str Type: str IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . HostPathVolumeOptions ( path : str , type : HostPathVolumeType = None ) path Required \u00b6 path : str Type: str The path of the directory on the host. type Optional \u00b6 type : HostPathVolumeType Type: cdk8s_plus_23.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None , scheme : ConnectionScheme = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 scheme : ConnectionScheme Type: cdk8s_plus_23.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . IngressProps ( metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressBackend Type: cdk8s_plus_23.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressRule ] Type: typing.List[ cdk8s_plus_23.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressTls ] Type: typing.List[ cdk8s_plus_23.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . IngressRule ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 backend : IngressBackend Type: cdk8s_plus_23.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_23.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . IngressTls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_23.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . JobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelSelectorOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_23.LabelExpression ] Expression based label matchers. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelSelectorRequirement ( key : str , operator : str , values : typing . List [ str ] = None ) key Required \u00b6 key : str Type: str The label key that the selector applies to. operator Required \u00b6 operator : str Type: str Represents a key\u2019s relationship to a set of values. values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . MemoryResources ( limit : Size = None , request : Size = None ) limit Optional \u00b6 limit : Size Type: cdk8s.Size request Optional \u00b6 request : Size Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NamespaceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NamespaceSelectorConfig ( label_selector : LabelSelector = None , names : typing . List [ str ] = None ) label_selector Optional \u00b6 label_selector : LabelSelector Type: cdk8s_plus_23.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 names : typing . List [ str ] Type: typing.List[ str ] A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NamespacesSelectOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , names : typing . List [ str ] = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_23.LabelExpression ] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 names : typing . List [ str ] Type: typing.List[ str ] Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyAddEgressRuleOptions ( ports : typing . List [ NetworkPolicyPort ] = None ) ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPeerConfig ( ip_block : NetworkPolicyIpBlock = None , pod_selector : PodSelectorConfig = None ) ip_block Optional \u00b6 ip_block : NetworkPolicyIpBlock Type: cdk8s_plus_23.NetworkPolicyIpBlock The ip block this peer represents. pod_selector Optional \u00b6 pod_selector : PodSelectorConfig Type: cdk8s_plus_23.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPortProps ( end_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None , protocol : NetworkProtocol = None ) end_port Optional \u00b6 end_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: all ports are allowed. Specific port number. protocol Optional \u00b6 protocol : NetworkProtocol Type: cdk8s_plus_23.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyProps ( metadata : ApiObjectMetadata = None , egress : NetworkPolicyTraffic = None , ingress : NetworkPolicyTraffic = None , selector : IPodSelector = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 egress : NetworkPolicyTraffic Type: cdk8s_plus_23.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 ingress : NetworkPolicyTraffic Type: cdk8s_plus_23.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 selector : IPodSelector Type: cdk8s_plus_23.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyRule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 peer : INetworkPolicyPeer Type: cdk8s_plus_23.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyTraffic ( default : NetworkPolicyTrafficDefault = None , rules : typing . List [ NetworkPolicyRule ] = None ) default Optional \u00b6 default : NetworkPolicyTrafficDefault Type: cdk8s_plus_23.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 rules : typing . List [ NetworkPolicyRule ] Type: typing.List[ cdk8s_plus_23.NetworkPolicyRule ] Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeTaintQueryOptions ( effect : TaintEffect = None , evict_after : Duration = None ) effect Optional \u00b6 effect : TaintEffect Type: cdk8s_plus_23.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 evict_after : Duration Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolumeClaimProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_23.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolumeClaimVolumeOptions ( name : str = None , read_only : bool = None ) name Optional \u00b6 name : str Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_23.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodConnectionsAllowFromOptions ( isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) isolation Optional \u00b6 isolation : PodConnectionsIsolation Type: cdk8s_plus_23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodConnectionsAllowToOptions ( isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) isolation Optional \u00b6 isolation : PodConnectionsIsolation Type: cdk8s_plus_23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodDnsProps ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 hostname : str Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 hostname_as_fqd_n : bool Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_23.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 policy : DnsPolicy Type: cdk8s_plus_23.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 subdomain : str Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodsAllOptions ( namespaces : Namespaces = None ) namespaces Optional \u00b6 namespaces : Namespaces Type: cdk8s_plus_23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodSchedulingAttractOptions ( weight : typing . Union [ int , float ] = None ) weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodSchedulingColocateOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_23.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodSchedulingSeparateOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_23.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodSecurityContextProps ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_23.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_23.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodSelectorConfig ( label_selector : LabelSelector , namespaces : NamespaceSelectorConfig = None ) label_selector Required \u00b6 label_selector : LabelSelector Type: cdk8s_plus_23.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 namespaces : NamespaceSelectorConfig Type: cdk8s_plus_23.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodsSelectOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : Namespaces = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_23.LabelExpression ] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 namespaces : Namespaces Type: cdk8s_plus_23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . RoleBindingProps ( metadata : ApiObjectMetadata = None , role : IRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IRole Type: cdk8s_plus_23.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . RolePolicyRule ( resources : typing . List [ IApiResource ], verbs : typing . List [ str ] ) resources Required \u00b6 resources : typing . List [ IApiResource ] Type: typing.List[ cdk8s_plus_23.IApiResource ] Resources this rule applies to. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . RoleProps ( metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_23.RolePolicyRule ] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . SecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_23.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . SecretVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_23.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 automount_token : bool Type: bool Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_23.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceAccountTokenSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceBindOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceIngressBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , selector : IPodSelector = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_23.ServicePort ] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 selector : IPodSelector Type: cdk8s_plus_23.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 type : ServiceType Type: cdk8s_plus_23.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . SshAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 ssh_private_key : str Type: str The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . StatefulSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 service : Service Type: cdk8s_plus_23.Service Service to associate with the statefulset. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_23.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_23.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . StatefulSetUpdateStrategyRollingUpdateOptions ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . SubjectConfiguration ( kind : str , name : str , api_group : str = None , namespace : str = None ) kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 namespace : str Type: str Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Sysctl ( name : str , value : str ) name Required \u00b6 name : str Type: str Name of a property to set. value Required \u00b6 value : str Type: str Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . TcpSocketProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . TlsSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 tls_cert : str Type: str The TLS cert. tls_key Required \u00b6 tls_key : str Type: str The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_23.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . WorkloadProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_23.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_23.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_23.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . WorkloadSchedulingSpreadOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_23.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s_plus_23.IApiResource , cdk8s_plus_23.IApiEndpoint Represents information about an API resource type. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 custom \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ApiResource . custom ( api_group : str , resource_type : str ) api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s_plus_23.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_23.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_23.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_23.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_port \u00b6 def add_port ( number : typing . Union [ int , float ], host_ip : str = None , host_port : typing . Union [ int , float ] = None , name : str = None , protocol : Protocol = None ) number Required \u00b6 Type: typing.Union[int, float] Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. host_ip Optional \u00b6 Type: str Default: 127.0.0.1. What host IP to bind the external port to. host_port Optional \u00b6 Type: typing.Union[int, float] Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 Type: str Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 Type: cdk8s_plus_23.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. mount \u00b6 def mount ( path : str , storage : IStorage , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. storage Required \u00b6 Type: cdk8s_plus_23.IStorage The storage to mount. propagation Optional \u00b6 Type: cdk8s_plus_23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. Properties \u00b6 env Required \u00b6 env : Env Type: cdk8s_plus_23.Env The environment of the container. image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_23.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_23.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. ports Required \u00b6 ports : typing . List [ ContainerPort ] Type: typing.List[ cdk8s_plus_23.ContainerPort ] Ports exposed by this containers. Returns a copy, use addPort to modify. security_context Required \u00b6 security_context : ContainerSecurityContext Type: cdk8s_plus_23.ContainerSecurityContext The security context of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . port : typing . Union [ int , float ] Type: typing.Union[int, float] port_number Optional \u00b6 port_number : typing . Union [ int , float ] Type: typing.Union[int, float] The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_23.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ContainerSecurityContext ( allow_privilege_escalation : bool = None , ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) allow_privilege_escalation Optional \u00b6 Type: bool Default: false Whether a process can gain more privileges than its parent process. ensure_non_root Optional \u00b6 Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: typing.Union[int, float] Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 Type: bool Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 Type: typing.Union[int, float] Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool privileged Required \u00b6 privileged : bool Type: bool read_only_root_filesystem Required \u00b6 read_only_root_filesystem : bool Type: bool allow_privilege_escalation Optional \u00b6 allow_privilege_escalation : bool Type: bool group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Cpu . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] units \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Cpu . units ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 amount Required \u00b6 amount : str Type: str DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DeploymentStrategy . recreate () rolling_update \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . DeploymentStrategy . rolling_update ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 Type: cdk8s_plus_23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 Type: cdk8s_plus_23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. Env \u00b6 Container environment variables. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Env ( sources : typing . List [ EnvFrom ], variables : typing . Mapping [ EnvValue ] ) sources Required \u00b6 Type: typing.List[ cdk8s_plus_23.EnvFrom ] variables Required \u00b6 Type: typing.Mapping[ cdk8s_plus_23.EnvValue ] Methods \u00b6 add_variable \u00b6 def add_variable ( name : str , value : EnvValue ) name Required \u00b6 Type: str value Required \u00b6 Type: cdk8s_plus_23.EnvValue copy_from \u00b6 def copy_from ( from : EnvFrom ) from Required \u00b6 Type: cdk8s_plus_23.EnvFrom Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Env . from_config_map ( config_map : IConfigMap , prefix : str = None ) config_map Required \u00b6 Type: cdk8s_plus_23.IConfigMap prefix Optional \u00b6 Type: str from_secret \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Env . from_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_23.ISecret Properties \u00b6 sources Required \u00b6 sources : typing . List [ EnvFrom ] Type: typing.List[ cdk8s_plus_23.EnvFrom ] The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 variables : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_23.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvFrom ( config_map : IConfigMap = None , prefix : str = None , sec : ISecret = None ) config_map Optional \u00b6 Type: cdk8s_plus_23.IConfigMap prefix Optional \u00b6 Type: str sec Optional \u00b6 Type: cdk8s_plus_23.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_23.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_field_ref \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValue . from_field_ref ( field_path : EnvFieldPaths , api_version : str = None , key : str = None ) field_path Required \u00b6 Type: cdk8s_plus_23.EnvFieldPaths : The field reference. api_version Optional \u00b6 Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 Type: str The key to select the pod label or annotation. from_process \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_resource \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValue . from_resource ( resource : ResourceFieldPaths , container : Container = None , divisor : str = None ) resource Required \u00b6 Type: cdk8s_plus_23.ResourceFieldPaths : Resource to select the value from. container Optional \u00b6 Type: cdk8s_plus_23.Container The container to select the value from. divisor Optional \u00b6 Type: str The output format of the exposed resource. from_secret_value \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_23.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Handler . from_command ( command : typing . List [ str ] ) command Required \u00b6 Type: typing.List[ str ] The command to execute. from_http_get \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Handler . from_http_get ( path : str , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Handler . from_tcp_socket ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_resource \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . IngressBackend . from_resource ( resource : IResource ) resource Required \u00b6 Type: cdk8s_plus_23.IResource from_service \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . IngressBackend . from_service ( serv : Service , port : typing . Union [ int , float ] = None ) serv Required \u00b6 Type: cdk8s_plus_23.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabeledNode ( label_selector : typing . List [ NodeLabelQuery ] ) label_selector Required \u00b6 Type: typing.List[ cdk8s_plus_23.NodeLabelQuery ] Properties \u00b6 label_selector Required \u00b6 label_selector : typing . List [ NodeLabelQuery ] Type: typing.List[ cdk8s_plus_23.NodeLabelQuery ] LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelExpression . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelExpression . exists ( key : str ) key Required \u00b6 Type: str in \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelExpression . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] not_in \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelExpression . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 key Required \u00b6 key : str Type: str operator Required \u00b6 operator : str Type: str values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 is_empty \u00b6 def is_empty () Static Functions \u00b6 of \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . LabelSelector . of ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None ) expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_23.LabelExpression ] Expression based label matchers. labels Optional \u00b6 Type: typing.Mapping[ str ] Strict label matchers. NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NamedNode ( name : str ) name Required \u00b6 Type: str Properties \u00b6 name Required \u00b6 name : str Type: str NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 all_tcp \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . all_tcp () all_udp \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . all_udp () of \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . of ( end_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None , protocol : NetworkProtocol = None ) end_port Optional \u00b6 Type: typing.Union[int, float] Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 Type: typing.Union[int, float] Default: all ports are allowed. Specific port number. protocol Optional \u00b6 Type: cdk8s_plus_23.NetworkProtocol Default: NetworkProtocol.TCP Protocol. tcp \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . tcp ( port : typing . Union [ int , float ] ) port Required \u00b6 Type: typing.Union[int, float] tcp_range \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . tcp_range ( start_port : typing . Union [ int , float ], end_port : typing . Union [ int , float ] ) start_port Required \u00b6 Type: typing.Union[int, float] end_port Required \u00b6 Type: typing.Union[int, float] udp \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . udp ( port : typing . Union [ int , float ] ) port Required \u00b6 Type: typing.Union[int, float] udp_range \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NetworkPolicyPort . udp_range ( start_port : typing . Union [ int , float ], end_port : typing . Union [ int , float ] ) start_port Required \u00b6 Type: typing.Union[int, float] end_port Required \u00b6 Type: typing.Union[int, float] Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Node () Static Functions \u00b6 labeled \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Node . labeled ( label_selector : NodeLabelQuery ) label_selector Required \u00b6 Type: cdk8s_plus_23.NodeLabelQuery named \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Node . named ( node_name : str ) node_name Required \u00b6 Type: str tainted \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Node . tainted ( taint_selector : NodeTaintQuery ) taint_selector Required \u00b6 Type: cdk8s_plus_23.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . exists ( key : str ) key Required \u00b6 Type: str gt \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . gt ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] in \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] is \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . is ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str lt \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . lt ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] not_in \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeLabelQuery . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeTaintQuery . any () exists \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeTaintQuery . exists ( key : str , effect : TaintEffect = None , evict_after : Duration = None ) key Required \u00b6 Type: str effect Optional \u00b6 Type: cdk8s_plus_23.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. is \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NodeTaintQuery . is ( key : str , value : str , effect : TaintEffect = None , evict_after : Duration = None ) key Required \u00b6 Type: str value Required \u00b6 Type: str effect Optional \u00b6 Type: cdk8s_plus_23.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. NonApiResource \u00b6 Implements: cdk8s_plus_23.IApiEndpoint Factory for creating non api resources. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 of \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . NonApiResource . of ( url : str ) url Required \u00b6 Type: str PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 is_zero \u00b6 def is_zero () Static Functions \u00b6 absolute \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PercentOrAbsolute . absolute ( num : typing . Union [ int , float ] ) num Required \u00b6 Type: typing.Union[int, float] percent \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PercentOrAbsolute . percent ( percent : typing . Union [ int , float ] ) percent Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 value Required \u00b6 value : typing . Any Type: typing.Any PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodConnections ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_23.AbstractPod Methods \u00b6 allow_from \u00b6 def allow_from ( peer : INetworkPolicyPeer , isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_23.INetworkPolicyPeer isolation Optional \u00b6 Type: cdk8s_plus_23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Default: The pod ports. Ports to allow incoming traffic to. allow_to \u00b6 def allow_to ( peer : INetworkPolicyPeer , isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_23.INetworkPolicyPeer isolation Optional \u00b6 Type: cdk8s_plus_23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_23.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodDns ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: typing.List[ cdk8s_plus_23.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: cdk8s_plus_23.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 add_nameserver \u00b6 def add_nameserver ( nameservers : str ) nameservers Required \u00b6 Type: str add_option \u00b6 def add_option ( name : str , value : str = None ) name Required \u00b6 Type: str Option name. value Optional \u00b6 Type: str Default: No value. Option value. add_search \u00b6 def add_search ( searches : str ) searches Required \u00b6 Type: str Properties \u00b6 hostname_as_fqd_n Required \u00b6 hostname_as_fqd_n : bool Type: bool Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] Nameservers defined for this pod. options Required \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_23.DnsOption ] Custom dns options defined for this pod. policy Required \u00b6 policy : DnsPolicy Type: cdk8s_plus_23.DnsPolicy The DNS policy of this pod. searches Required \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] Search domains defined for this pod. hostname Optional \u00b6 hostname : str Type: str The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 subdomain : str Type: str The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_23.AbstractPod Methods \u00b6 assign \u00b6 def assign ( node : NamedNode ) node Required \u00b6 Type: cdk8s_plus_23.NamedNode attract \u00b6 def attract ( node : LabeledNode , weight : typing . Union [ int , float ] = None ) node Required \u00b6 Type: cdk8s_plus_23.LabeledNode weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. colocate \u00b6 def colocate ( selector : IPodSelector , topology : Topology = None , weight : typing . Union [ int , float ] = None ) selector Required \u00b6 Type: cdk8s_plus_23.IPodSelector topology Optional \u00b6 Type: cdk8s_plus_23.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. separate \u00b6 def separate ( selector : IPodSelector , topology : Topology = None , weight : typing . Union [ int , float ] = None ) selector Required \u00b6 Type: cdk8s_plus_23.IPodSelector topology Optional \u00b6 Type: cdk8s_plus_23.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. tolerate \u00b6 def tolerate ( node : TaintedNode ) node Required \u00b6 Type: cdk8s_plus_23.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . PodSecurityContext ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 Type: cdk8s_plus_23.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: typing.List[ cdk8s_plus_23.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool fs_group_change_policy Required \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_23.FsGroupChangePolicy sysctls Required \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_23.Sysctl ] fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None , scheme : ConnectionScheme = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 Type: cdk8s_plus_23.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). from_tcp_socket \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Probe . from_tcp_socket ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . ResourcePermissions ( instance : Resource ) instance Required \u00b6 Type: cdk8s_plus_23.Resource Methods \u00b6 grant_read \u00b6 def grant_read ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_23.ISubject grant_read_write \u00b6 def grant_read_write ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_23.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 on_delete \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . StatefulSetUpdateStrategy . on_delete () rolling_update \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . StatefulSetUpdateStrategy . rolling_update ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . TaintedNode ( taint_selector : typing . List [ NodeTaintQuery ] ) taint_selector Required \u00b6 Type: typing.List[ cdk8s_plus_23.NodeTaintQuery ] Properties \u00b6 taint_selector Required \u00b6 taint_selector : typing . List [ NodeTaintQuery ] Type: typing.List[ cdk8s_plus_23.NodeTaintQuery ] Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . Topology . custom ( key : str ) key Required \u00b6 Type: str Properties \u00b6 key Required \u00b6 key : str Type: str Constants \u00b6 HOSTNAME \u00b6 Type: cdk8s_plus_23.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: cdk8s_plus_23.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: cdk8s_plus_23.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import cdk8s_plus_23 cdk8s_plus_23 . WorkloadScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_23.AbstractPod Methods \u00b6 spread \u00b6 def spread ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 Type: cdk8s_plus_23.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.ApiResource , cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.ClusterRole , cdk8s_plus_23.ClusterRoleBinding , cdk8s_plus_23.ConfigMap , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.Ingress , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.NetworkPolicy , cdk8s_plus_23.NonApiResource , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.Pod , cdk8s_plus_23.Resource , cdk8s_plus_23.Role , cdk8s_plus_23.RoleBinding , cdk8s_plus_23.Secret , cdk8s_plus_23.Service , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.Workload , cdk8s_plus_23.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () IApiResource \u00b6 Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.ApiResource , cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.ClusterRole , cdk8s_plus_23.ClusterRoleBinding , cdk8s_plus_23.ConfigMap , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.Ingress , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.NetworkPolicy , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.Pod , cdk8s_plus_23.Resource , cdk8s_plus_23.Role , cdk8s_plus_23.RoleBinding , cdk8s_plus_23.Secret , cdk8s_plus_23.Service , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.Workload , cdk8s_plus_23.IApiResource Represents a resource or collection of resources. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ClusterRole , cdk8s_plus_23.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ConfigMap , cdk8s_plus_23.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.Namespace , cdk8s_plus_23.Namespaces , cdk8s_plus_23.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.Namespaces , cdk8s_plus_23.NetworkPolicyIpBlock , cdk8s_plus_23.Pod , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.Workload , cdk8s_plus_23.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. IPersistentVolume \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.Job , cdk8s_plus_23.Pod , cdk8s_plus_23.Pods , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.Workload , cdk8s_plus_23.IPodSelector Represents an object that can select pods. Methods \u00b6 to_pod_selector_config \u00b6 def to_pod_selector_config () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. IResource \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.ClusterRole , cdk8s_plus_23.ClusterRoleBinding , cdk8s_plus_23.ConfigMap , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.Ingress , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.NetworkPolicy , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.Pod , cdk8s_plus_23.Resource , cdk8s_plus_23.Role , cdk8s_plus_23.RoleBinding , cdk8s_plus_23.Secret , cdk8s_plus_23.Service , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.Workload , cdk8s_plus_23.IClusterRole , cdk8s_plus_23.IConfigMap , cdk8s_plus_23.IPersistentVolume , cdk8s_plus_23.IPersistentVolumeClaim , cdk8s_plus_23.IResource , cdk8s_plus_23.IRole , cdk8s_plus_23.ISecret , cdk8s_plus_23.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ClusterRole , cdk8s_plus_23.Role , cdk8s_plus_23.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.Secret , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.ISecret Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.IServiceAccount Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IStorage \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.Volume , cdk8s_plus_23.IStorage Represents a piece of storage in the cluster. Methods \u00b6 as_volume \u00b6 def as_volume () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. ISubject \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.Group , cdk8s_plus_23.Job , cdk8s_plus_23.Pod , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.User , cdk8s_plus_23.Workload , cdk8s_plus_23.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. Pods that tolerate the taint without specifying duration remain bound forever. Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"Python"},{"location":"reference/cdk8s-plus-23/python/#cdk8s-plus-23-python","text":"","title":"cdk8s-plus-23 (Python) "},{"location":"reference/cdk8s-plus-23/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-23/python/#abstractpod","text":"Implements: cdk8s_plus_23.IPodSelector , cdk8s_plus_23.INetworkPolicyPeer , cdk8s_plus_23.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-23/python/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-23/python/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-23/python/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-23/python/#clusterrole","text":"Implements: cdk8s_plus_23.IClusterRole , cdk8s_plus_23.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-23/python/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-23/python/#configmap","text":"Implements: cdk8s_plus_23.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-23/python/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-23/python/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-23/python/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-23/python/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-23/python/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-23/python/#group","text":"Implements: cdk8s_plus_23.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-23/python/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-23/python/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-23/python/#namespace","text":"Implements: cdk8s_plus_23.INamespaceSelector , cdk8s_plus_23.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-23/python/#namespaces","text":"Implements: cdk8s_plus_23.INamespaceSelector , cdk8s_plus_23.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-23/python/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-23/python/#networkpolicyipblock","text":"Implements: cdk8s_plus_23.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-23/python/#persistentvolume","text":"Implements: cdk8s_plus_23.IPersistentVolume , cdk8s_plus_23.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumeclaim","text":"Implements: cdk8s_plus_23.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-23/python/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-23/python/#pods","text":"Implements: cdk8s_plus_23.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-23/python/#resource","text":"Implements: cdk8s_plus_23.IResource , cdk8s_plus_23.IApiResource , cdk8s_plus_23.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-23/python/#role","text":"Implements: cdk8s_plus_23.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-23/python/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-23/python/#secret","text":"Implements: cdk8s_plus_23.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-23/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-23/python/#serviceaccount","text":"Implements: cdk8s_plus_23.IServiceAccount , cdk8s_plus_23.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-23/python/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-23/python/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-23/python/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-23/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-23/python/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-23/python/#user","text":"Implements: cdk8s_plus_23.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-23/python/#volume","text":"Implements: cdk8s_plus_23.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-23/python/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-23/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-23/python/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-23/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-23/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-23/python/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-23/python/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/python/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/python/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-23/python/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-23/python/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-23/python/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-23/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-23/python/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-23/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-23/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-23/python/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-23/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-23/python/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-23/python/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-23/python/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-23/python/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-23/python/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-23/python/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-23/python/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-23/python/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-23/python/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-23/python/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-23/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-23/python/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-23/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-23/python/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-23/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-23/python/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-23/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-23/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-23/python/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/python/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-23/python/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-23/python/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-23/python/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-23/python/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-23/python/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-23/python/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-23/python/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-23/python/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-23/python/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-23/python/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-23/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-23/python/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-23/python/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-23/python/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-23/python/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-23/python/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-23/python/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-23/python/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-23/python/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-23/python/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-23/python/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-23/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/python/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-23/python/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-23/python/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-23/python/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-23/python/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-23/python/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-23/python/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-23/python/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-23/python/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-23/python/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-23/python/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-23/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-23/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-23/python/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-23/python/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-23/python/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-23/python/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-23/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-23/python/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-23/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-23/python/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-23/python/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-23/python/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-23/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-23/python/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-23/python/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-23/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-23/python/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-23/python/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-23/python/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-23/python/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-23/python/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-23/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-23/python/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-23/python/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-23/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-23/python/#apiresource","text":"Implements: cdk8s_plus_23.IApiResource , cdk8s_plus_23.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-23/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-23/python/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-23/python/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-23/python/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-23/python/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-23/python/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-23/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-23/python/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-23/python/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-23/python/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-23/python/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-23/python/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-23/python/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-23/python/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-23/python/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-23/python/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-23/python/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-23/python/#nonapiresource","text":"Implements: cdk8s_plus_23.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-23/python/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-23/python/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-23/python/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-23/python/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-23/python/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-23/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-23/python/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-23/python/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-23/python/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-23/python/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-23/python/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-23/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-23/python/#iapiendpoint","text":"Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.ApiResource , cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.ClusterRole , cdk8s_plus_23.ClusterRoleBinding , cdk8s_plus_23.ConfigMap , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.Ingress , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.NetworkPolicy , cdk8s_plus_23.NonApiResource , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.Pod , cdk8s_plus_23.Resource , cdk8s_plus_23.Role , cdk8s_plus_23.RoleBinding , cdk8s_plus_23.Secret , cdk8s_plus_23.Service , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.Workload , cdk8s_plus_23.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-23/python/#iapiresource","text":"Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.ApiResource , cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.ClusterRole , cdk8s_plus_23.ClusterRoleBinding , cdk8s_plus_23.ConfigMap , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.Ingress , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.NetworkPolicy , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.Pod , cdk8s_plus_23.Resource , cdk8s_plus_23.Role , cdk8s_plus_23.RoleBinding , cdk8s_plus_23.Secret , cdk8s_plus_23.Service , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.Workload , cdk8s_plus_23.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-23/python/#iclusterrole","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ClusterRole , cdk8s_plus_23.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-23/python/#iconfigmap","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ConfigMap , cdk8s_plus_23.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-23/python/#inamespaceselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.Namespace , cdk8s_plus_23.Namespaces , cdk8s_plus_23.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-23/python/#inetworkpolicypeer","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.Namespaces , cdk8s_plus_23.NetworkPolicyIpBlock , cdk8s_plus_23.Pod , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.Workload , cdk8s_plus_23.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-23/python/#ipersistentvolume","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-23/python/#ipersistentvolumeclaim","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-23/python/#ipodselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.Job , cdk8s_plus_23.Pod , cdk8s_plus_23.Pods , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.Workload , cdk8s_plus_23.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-23/python/#iresource","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.ClusterRole , cdk8s_plus_23.ClusterRoleBinding , cdk8s_plus_23.ConfigMap , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.Ingress , cdk8s_plus_23.Job , cdk8s_plus_23.Namespace , cdk8s_plus_23.NetworkPolicy , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.PersistentVolumeClaim , cdk8s_plus_23.Pod , cdk8s_plus_23.Resource , cdk8s_plus_23.Role , cdk8s_plus_23.RoleBinding , cdk8s_plus_23.Secret , cdk8s_plus_23.Service , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.Workload , cdk8s_plus_23.IClusterRole , cdk8s_plus_23.IConfigMap , cdk8s_plus_23.IPersistentVolume , cdk8s_plus_23.IPersistentVolumeClaim , cdk8s_plus_23.IResource , cdk8s_plus_23.IRole , cdk8s_plus_23.ISecret , cdk8s_plus_23.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-23/python/#irole","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ClusterRole , cdk8s_plus_23.Role , cdk8s_plus_23.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-23/python/#isecret","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.BasicAuthSecret , cdk8s_plus_23.DockerConfigSecret , cdk8s_plus_23.Secret , cdk8s_plus_23.ServiceAccountTokenSecret , cdk8s_plus_23.SshAuthSecret , cdk8s_plus_23.TlsSecret , cdk8s_plus_23.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-23/python/#iserviceaccount","text":"Extends: cdk8s_plus_23.IResource Implemented By: cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-23/python/#istorage","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AwsElasticBlockStorePersistentVolume , cdk8s_plus_23.AzureDiskPersistentVolume , cdk8s_plus_23.GCEPersistentDiskPersistentVolume , cdk8s_plus_23.PersistentVolume , cdk8s_plus_23.Volume , cdk8s_plus_23.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-23/python/#isubject","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_23.AbstractPod , cdk8s_plus_23.CronJob , cdk8s_plus_23.DaemonSet , cdk8s_plus_23.Deployment , cdk8s_plus_23.Group , cdk8s_plus_23.Job , cdk8s_plus_23.Pod , cdk8s_plus_23.ServiceAccount , cdk8s_plus_23.StatefulSet , cdk8s_plus_23.User , cdk8s_plus_23.Workload , cdk8s_plus_23.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-23/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-23/python/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-23/python/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-23/python/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-23/python/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-23/python/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-23/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-23/python/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-23/python/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-23/python/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-23/python/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-23/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-23/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-23/python/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-23/python/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-23/python/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-23/python/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-23/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-23/python/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-23/python/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-23/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-23/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-23/python/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-23/typescript/","text":"cdk8s-plus-23 (TypeScript) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: cdk8s-plus-23.IPodSelector , cdk8s-plus-23.INetworkPolicyPeer , cdk8s-plus-23.ISubject Initializers \u00b6 import { AbstractPod } from 'cdk8s-plus-23' new AbstractPod ( scope : Construct , id : string , props? : AbstractPodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.AbstractPodProps Methods \u00b6 addContainer \u00b6 public addContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-23.ContainerProps addHostAlias \u00b6 public addHostAlias ( hostAlias : HostAlias ) hostAlias Required \u00b6 Type: cdk8s-plus-23.HostAlias addInitContainer \u00b6 public addInitContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-23.ContainerProps addVolume \u00b6 public addVolume ( vol : Volume ) vol Required \u00b6 Type: cdk8s-plus-23.Volume toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 automountServiceAccountToken Required \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-23.Container [] dns Required \u00b6 public readonly dns : PodDns ; Type: cdk8s-plus-23.PodDns hostAliases Required \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] initContainers Required \u00b6 public readonly initContainers : Container []; Type: cdk8s-plus-23.Container [] podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition securityContext Required \u00b6 public readonly securityContext : PodSecurityContext ; Type: cdk8s-plus-23.PodSecurityContext volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import { AwsElasticBlockStorePersistentVolume } from 'cdk8s-plus-23' new AwsElasticBlockStorePersistentVolume ( scope : Construct , id : string , props : AwsElasticBlockStorePersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.AwsElasticBlockStorePersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Volume id of this volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import { AzureDiskPersistentVolume } from 'cdk8s-plus-23' new AzureDiskPersistentVolume ( scope : Construct , id : string , props : AzureDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.AzureDiskPersistentVolumeProps Properties \u00b6 azureKind Required \u00b6 public readonly azureKind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-23.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-23.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public readonly diskName : string ; Type: string Disk name of this volume. diskUri Required \u00b6 public readonly diskUri : string ; Type: string Disk URI of this volume. fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import { BasicAuthSecret } from 'cdk8s-plus-23' new BasicAuthSecret ( scope : Construct , id : string , props : BasicAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.BasicAuthSecretProps ClusterRole \u00b6 Implements: cdk8s-plus-23.IClusterRole , cdk8s-plus-23.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import { ClusterRole } from 'cdk8s-plus-23' new ClusterRole ( scope : Construct , id : string , props? : ClusterRoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.ClusterRoleProps Methods \u00b6 aggregate \u00b6 public aggregate ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string allow \u00b6 public allow ( verbs : string [], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: string [] endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-23.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-23.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( namespace : string , subjects : ISubject ) namespace Required \u00b6 Type: string the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s-plus-23.ISubject a list of subjects to bind to. combine \u00b6 public combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s-plus-23.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import { ClusterRole } from 'cdk8s-plus-23' ClusterRole . fromClusterRoleName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-23.ClusterRolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import { ClusterRoleBinding } from 'cdk8s-plus-23' new ClusterRoleBinding ( scope : Construct , id : string , props : ClusterRoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.ClusterRoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-23.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-23.IClusterRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-23.ISubject [] ConfigMap \u00b6 Implements: cdk8s-plus-23.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-23' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-23.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-23' ConfigMap . fromConfigMapName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not this config map is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import { CronJob } from 'cdk8s-plus-23' new CronJob ( scope : Construct , id : string , props : CronJobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.CronJobProps Properties \u00b6 concurrencyPolicy Required \u00b6 public readonly concurrencyPolicy : string ; Type: string The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failedJobsRetained Required \u00b6 public readonly failedJobsRetained : number ; Type: number The number of failed jobs retained by this cron job. resourceType Required \u00b6 public readonly resourceType : string ; Type: string Represents the resource type. schedule Required \u00b6 public readonly schedule : Cron ; Type: cdk8s.Cron The schedule this cron job is scheduled to run in. startingDeadline Required \u00b6 public readonly startingDeadline : Duration ; Type: cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successfulJobsRetained Required \u00b6 public readonly successfulJobsRetained : number ; Type: number The number of successful jobs retained by this cron job. suspend Required \u00b6 public readonly suspend : boolean ; Type: boolean Whether or not the cron job is currently suspended or not. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import { DaemonSet } from 'cdk8s-plus-23' new DaemonSet ( scope : Construct , id : string , props? : DaemonSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.DaemonSetProps Properties \u00b6 minReadySeconds Required \u00b6 public readonly minReadySeconds : number ; Type: number resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-23' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.DeploymentProps Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-23.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : DeploymentExposeViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-23.DeploymentExposeViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-23.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import { DockerConfigSecret } from 'cdk8s-plus-23' new DockerConfigSecret ( scope : Construct , id : string , props : DockerConfigSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.DockerConfigSecretProps GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import { GCEPersistentDiskPersistentVolume } from 'cdk8s-plus-23' new GCEPersistentDiskPersistentVolume ( scope : Construct , id : string , props : GCEPersistentDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.GCEPersistentDiskPersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. pdName Required \u00b6 public readonly pdName : string ; Type: string PD resource in GCE of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. Group \u00b6 Implements: cdk8s-plus-23.ISubject Represents a group. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import { Group } from 'cdk8s-plus-23' Group . fromName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string name Required \u00b6 public readonly name : string ; Type: string apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { Ingress } from 'cdk8s-plus-23' new Ingress ( scope : Construct , id : string , props? : IngressProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.IngressProps Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s-plus-23.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressBackend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-23.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-23.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-23.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-23.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-23.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( rules : IngressRule ) rules Required \u00b6 Type: cdk8s-plus-23.IngressRule The rules to add. addTls \u00b6 public addTls ( tls : IngressTls []) tls Required \u00b6 Type: cdk8s-plus-23.IngressTls [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-23' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.JobProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: cdk8s-plus-23.INamespaceSelector , cdk8s-plus-23.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import { Namespace } from 'cdk8s-plus-23' new Namespace ( scope : Construct , id : string , props? : NamespaceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.NamespaceProps Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: string https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: cdk8s-plus-23.INamespaceSelector , cdk8s-plus-23.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import { Namespaces } from 'cdk8s-plus-23' new Namespaces ( scope : Construct , id : string , expressions? : LabelExpression [], names? : string [], labels ?: {[ key : string ] : string }) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string expressions Optional \u00b6 Type: cdk8s-plus-23.LabelExpression [] names Optional \u00b6 Type: string [] labels Optional \u00b6 Type: {[ key: string ]: string } Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 all \u00b6 import { Namespaces } from 'cdk8s-plus-23' Namespaces . all ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string select \u00b6 import { Namespaces } from 'cdk8s-plus-23' Namespaces . select ( scope : Construct , id : string , options : NamespacesSelectOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-23.NamespacesSelectOptions NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import { NetworkPolicy } from 'cdk8s-plus-23' new NetworkPolicy ( scope : Construct , id : string , props? : NetworkPolicyProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.NetworkPolicyProps Methods \u00b6 addEgressRule \u00b6 public addEgressRule ( peer : INetworkPolicyPeer , ports? : NetworkPolicyPort []) peer Required \u00b6 Type: cdk8s-plus-23.INetworkPolicyPeer ports Optional \u00b6 Type: cdk8s-plus-23.NetworkPolicyPort [] addIngressRule \u00b6 public addIngressRule ( peer : INetworkPolicyPeer , ports? : NetworkPolicyPort []) peer Required \u00b6 Type: cdk8s-plus-23.INetworkPolicyPeer ports Optional \u00b6 Type: cdk8s-plus-23.NetworkPolicyPort [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: cdk8s-plus-23.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 anyIpv4 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-23' NetworkPolicyIpBlock . anyIpv4 ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string anyIpv6 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-23' NetworkPolicyIpBlock . anyIpv6 ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string ipv4 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-23' NetworkPolicyIpBlock . ipv4 ( scope : Construct , id : string , cidrIp : string , except? : string []) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string cidrIp Required \u00b6 Type: string except Optional \u00b6 Type: string [] ipv6 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-23' NetworkPolicyIpBlock . ipv6 ( scope : Construct , id : string , cidrIp : string , except? : string []) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string cidrIp Required \u00b6 Type: string except Optional \u00b6 Type: string [] Properties \u00b6 cidr Required \u00b6 public readonly cidr : string ; Type: string A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 public readonly except : string []; Type: string [] A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: cdk8s-plus-23.IPersistentVolume , cdk8s-plus-23.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import { PersistentVolume } from 'cdk8s-plus-23' new PersistentVolume ( scope : Construct , id : string , props? : PersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.PersistentVolumeProps Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s-plus-23.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import { PersistentVolume } from 'cdk8s-plus-23' PersistentVolume . fromPersistentVolumeName ( scope : Construct , id : string , volumeName : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string volumeName Required \u00b6 Type: string Properties \u00b6 mode Required \u00b6 public readonly mode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-23.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Access modes requirement of this claim. claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-23.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Mount options of this volume. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s-plus-23.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-23' new PersistentVolumeClaim ( scope : Construct , id : string , props? : PersistentVolumeClaimProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.PersistentVolumeClaimProps Methods \u00b6 bind \u00b6 public bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s-plus-23.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-23' PersistentVolumeClaim . fromClaimName ( scope : Construct , id : string , claimName : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string claimName Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Access modes requirement of this claim. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class requirment of this claim. volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-23.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-23' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.PodProps Properties \u00b6 connections Required \u00b6 public readonly connections : PodConnections ; Type: cdk8s-plus-23.PodConnections podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 public readonly scheduling : PodScheduling ; Type: cdk8s-plus-23.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: string This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: cdk8s-plus-23.IPodSelector Represents a group of pods. Initializers \u00b6 import { Pods } from 'cdk8s-plus-23' new Pods ( scope : Construct , id : string , expressions? : LabelExpression [], labels ?: {[ key : string ] : string }, namespaces? : INamespaceSelector ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string expressions Optional \u00b6 Type: cdk8s-plus-23.LabelExpression [] labels Optional \u00b6 Type: {[ key: string ]: string } namespaces Optional \u00b6 Type: cdk8s-plus-23.INamespaceSelector Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () Static Functions \u00b6 all \u00b6 import { Pods } from 'cdk8s-plus-23' Pods . all ( scope : Construct , id : string , options? : PodsAllOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.PodsAllOptions select \u00b6 import { Pods } from 'cdk8s-plus-23' Pods . select ( scope : Construct , id : string , options : PodsSelectOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-23.PodsSelectOptions Resource \u00b6 Implements: cdk8s-plus-23.IResource , cdk8s-plus-23.IApiResource , cdk8s-plus-23.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-23' new Resource ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. permissions Required \u00b6 public readonly permissions : ResourcePermissions ; Type: cdk8s-plus-23.ResourcePermissions resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s-plus-23.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import { Role } from 'cdk8s-plus-23' new Role ( scope : Construct , id : string , props? : RoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.RoleProps Methods \u00b6 allow \u00b6 public allow ( verbs : string [], resources : IApiResource ) verbs Required \u00b6 Type: string [] resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-23.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-23.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import { Role } from 'cdk8s-plus-23' Role . fromRoleName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-23.RolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import { RoleBinding } from 'cdk8s-plus-23' new RoleBinding ( scope : Construct , id : string , props : RoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.RoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-23.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-23.IRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-23.ISubject [] Secret \u00b6 Implements: cdk8s-plus-23.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-23' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-23' Secret . fromSecretName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not the secret is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-23' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.ServiceProps Methods \u00b6 bind \u00b6 public bind ( port : number , options? : ServiceBindOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-23.ServiceBindOptions exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-23.ExposeServiceViaIngressOptions Additional options. select \u00b6 public select ( selector : IPodSelector ) selector Required \u00b6 Type: cdk8s-plus-23.IPodSelector selectLabel \u00b6 public selectLabel ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-23.ServicePort [] Ports for this service. Use bind() to bind additional service ports. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-23.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-23.IServiceAccount , cdk8s-plus-23.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-23' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-23.ISecret The secret. toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-23' ServiceAccount . fromServiceAccountName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public readonly automountToken : boolean ; Type: boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-23.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import { ServiceAccountTokenSecret } from 'cdk8s-plus-23' new ServiceAccountTokenSecret ( scope : Construct , id : string , props : ServiceAccountTokenSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.ServiceAccountTokenSecretProps SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import { SshAuthSecret } from 'cdk8s-plus-23' new SshAuthSecret ( scope : Construct , id : string , props : SshAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.SshAuthSecretProps StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-23' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.StatefulSetProps Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-23.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-23.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import { TlsSecret } from 'cdk8s-plus-23' new TlsSecret ( scope : Construct , id : string , props : TlsSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-23.TlsSecretProps User \u00b6 Implements: cdk8s-plus-23.ISubject Represents a user. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import { User } from 'cdk8s-plus-23' User . fromName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string name Required \u00b6 public readonly name : string ; Type: string apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string Volume \u00b6 Implements: cdk8s-plus-23.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromAwsElasticBlockStore ( scope : Construct , id : string , volumeId : string , options? : AwsElasticBlockStoreVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string volumeId Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromAzureDisk ( scope : Construct , id : string , diskName : string , diskUri : string , options? : AzureDiskVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string diskName Required \u00b6 Type: string diskUri Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.AzureDiskVolumeOptions fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromConfigMap ( scope : Construct , id : string , configMap : IConfigMap , options? : ConfigMapVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string configMap Required \u00b6 Type: cdk8s-plus-23.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-23.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromEmptyDir ( scope : Construct , id : string , name : string , options? : EmptyDirVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromGcePersistentDisk ( scope : Construct , id : string , pdName : string , options? : GCEPersistentDiskVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string pdName Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.GCEPersistentDiskVolumeOptions fromHostPath \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromHostPath ( scope : Construct , id : string , name : string , options : HostPathVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-23.HostPathVolumeOptions fromPersistentVolumeClaim \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromPersistentVolumeClaim ( scope : Construct , id : string , claim : IPersistentVolumeClaim , options? : PersistentVolumeClaimVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string claim Required \u00b6 Type: cdk8s-plus-23.IPersistentVolumeClaim options Optional \u00b6 Type: cdk8s-plus-23.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import { Volume } from 'cdk8s-plus-23' Volume . fromSecret ( scope : Construct , id : string , secr : ISecret , options? : SecretVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string secr Required \u00b6 Type: cdk8s-plus-23.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-23.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import { Workload } from 'cdk8s-plus-23' new Workload ( scope : Construct , id : string , props? : WorkloadProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-23.WorkloadProps Methods \u00b6 select \u00b6 public select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s-plus-23.LabelSelector Properties \u00b6 connections Required \u00b6 public readonly connections : PodConnections ; Type: cdk8s-plus-23.PodConnections matchExpressions Required \u00b6 public readonly matchExpressions : LabelSelectorRequirement []; Type: cdk8s-plus-23.LabelSelectorRequirement [] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public readonly matchLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 public readonly scheduling : WorkloadScheduling ; Type: cdk8s-plus-23.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import { AbstractPodProps } from 'cdk8s-plus-23' const abstractPodProps : AbstractPodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-23' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-23' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import { ApiResourceOptions } from 'cdk8s-plus-23' const apiResourceOptions : ApiResourceOptions = { ... } apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import { AwsElasticBlockStorePersistentVolumeProps } from 'cdk8s-plus-23' const awsElasticBlockStorePersistentVolumeProps : AwsElasticBlockStorePersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import { AwsElasticBlockStoreVolumeOptions } from 'cdk8s-plus-23' const awsElasticBlockStoreVolumeOptions : AwsElasticBlockStoreVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import { AzureDiskPersistentVolumeProps } from 'cdk8s-plus-23' const azureDiskPersistentVolumeProps : AzureDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public readonly diskName : string ; Type: string The Name of the data disk in the blob storage. diskUri Required \u00b6 public readonly diskUri : string ; Type: string The URI the data disk in the blob storage. cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import { AzureDiskVolumeOptions } from 'cdk8s-plus-23' const azureDiskVolumeOptions : AzureDiskVolumeOptions = { ... } cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-23.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-23.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import { BasicAuthSecretProps } from 'cdk8s-plus-23' const basicAuthSecretProps : BasicAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public readonly password : string ; Type: string The password or token for authentication. username Required \u00b6 public readonly username : string ; Type: string The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import { ClusterRoleBindingProps } from 'cdk8s-plus-23' const clusterRoleBindingProps : ClusterRoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-23.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import { ClusterRolePolicyRule } from 'cdk8s-plus-23' const clusterRolePolicyRule : ClusterRolePolicyRule = { ... } endpoints Required \u00b6 public readonly endpoints : IApiEndpoint []; Type: cdk8s-plus-23.IApiEndpoint [] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import { ClusterRoleProps } from 'cdk8s-plus-23' const clusterRoleProps : ClusterRoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public readonly aggregationLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-23.ClusterRolePolicyRule [] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-23' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import { CommonSecretProps } from 'cdk8s-plus-23' const commonSecretProps : CommonSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-23' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-23' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-23.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import { ContainerLifecycle } from 'cdk8s-plus-23' const containerLifecycle : ContainerLifecycle = { ... } postStart Optional \u00b6 public readonly postStart : Handler ; Type: cdk8s-plus-23.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public readonly preStop : Handler ; Type: cdk8s-plus-23.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import { ContainerPort } from 'cdk8s-plus-23' const containerPort : ContainerPort = { ... } number Required \u00b6 public readonly number : number ; Type: number Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. hostIp Optional \u00b6 public readonly hostIp : string ; Type: string Default: 127.0.0.1. What host IP to bind the external port to. hostPort Optional \u00b6 public readonly hostPort : number ; Type: number Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 public readonly name : string ; Type: string Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-23.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-23' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 public readonly envFrom : EnvFrom []; Type: cdk8s-plus-23.EnvFrom [] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 public readonly envVariables : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-23.EnvValue } Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-23.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public readonly lifecycle : ContainerLifecycle ; Type: cdk8s-plus-23.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-23.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public readonly port : number ; Type: number portNumber Optional \u00b6 public readonly portNumber : number ; Type: number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 public readonly ports : ContainerPort []; Type: cdk8s-plus-23.ContainerPort [] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-23.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-23.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public readonly securityContext : ContainerSecurityContextProps ; Type: cdk8s-plus-23.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-23.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-23.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import { ContainerResources } from 'cdk8s-plus-23' const containerResources : ContainerResources = { ... } cpu Optional \u00b6 public readonly cpu : CpuResources ; Type: cdk8s-plus-23.CpuResources ephemeralStorage Optional \u00b6 public readonly ephemeralStorage : EphemeralStorageResources ; Type: cdk8s-plus-23.EphemeralStorageResources memory Optional \u00b6 public readonly memory : MemoryResources ; Type: cdk8s-plus-23.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import { ContainerSecurityContextProps } from 'cdk8s-plus-23' const containerSecurityContextProps : ContainerSecurityContextProps = { ... } allowPrivilegeEscalation Optional \u00b6 public readonly allowPrivilegeEscalation : boolean ; Type: boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public readonly group : number ; Type: number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 public readonly privileged : boolean ; Type: boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 public readonly user : number ; Type: number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import { CpuResources } from 'cdk8s-plus-23' const cpuResources : CpuResources = { ... } limit Optional \u00b6 public readonly limit : Cpu ; Type: cdk8s-plus-23.Cpu request Optional \u00b6 public readonly request : Cpu ; Type: cdk8s-plus-23.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import { CronJobProps } from 'cdk8s-plus-23' const cronJobProps : CronJobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 public readonly schedule : Cron ; Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 public readonly concurrencyPolicy : ConcurrencyPolicy ; Type: cdk8s-plus-23.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 public readonly failedJobsRetained : number ; Type: number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 public readonly startingDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 public readonly successfulJobsRetained : number ; Type: number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 public readonly suspend : boolean ; Type: boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import { DaemonSetProps } from 'cdk8s-plus-23' const daemonSetProps : DaemonSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 public readonly minReadySeconds : number ; Type: number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import { DeploymentExposeViaServiceOptions } from 'cdk8s-plus-23' const deploymentExposeViaServiceOptions : DeploymentExposeViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-23.ServicePort [] Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-23.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-23' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 2 Number of desired pods. strategy Optional \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-23.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import { DeploymentStrategyRollingUpdateOptions } from 'cdk8s-plus-23' const deploymentStrategyRollingUpdateOptions : DeploymentStrategyRollingUpdateOptions = { ... } maxSurge Optional \u00b6 public readonly maxSurge : PercentOrAbsolute ; Type: cdk8s-plus-23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public readonly maxUnavailable : PercentOrAbsolute ; Type: cdk8s-plus-23.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import { DnsOption } from 'cdk8s-plus-23' const dnsOption : DnsOption = { ... } name Required \u00b6 public readonly name : string ; Type: string Option name. value Optional \u00b6 public readonly value : string ; Type: string Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import { DockerConfigSecretProps } from 'cdk8s-plus-23' const dockerConfigSecretProps : DockerConfigSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public readonly data : {[ key : string ] : any }; Type: {[ key: string ]: any } JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-23' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-23.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-23' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import { EnvValueFromFieldRefOptions } from 'cdk8s-plus-23' const envValueFromFieldRefOptions : EnvValueFromFieldRefOptions = { ... } apiVersion Optional \u00b6 public readonly apiVersion : string ; Type: string Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public readonly key : string ; Type: string The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-23' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import { EnvValueFromResourceOptions } from 'cdk8s-plus-23' const envValueFromResourceOptions : EnvValueFromResourceOptions = { ... } container Optional \u00b6 public readonly container : Container ; Type: cdk8s-plus-23.Container The container to select the value from. divisor Optional \u00b6 public readonly divisor : string ; Type: string The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-23' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import { EphemeralStorageResources } from 'cdk8s-plus-23' const ephemeralStorageResources : EphemeralStorageResources = { ... } limit Optional \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Optional \u00b6 public readonly request : Size ; Type: cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-23' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-23.ServicePort [] Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-23.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-23' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-23.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-23.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import { GCEPersistentDiskPersistentVolumeProps } from 'cdk8s-plus-23' const gCEPersistentDiskPersistentVolumeProps : GCEPersistentDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public readonly pdName : string ; Type: string Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import { GCEPersistentDiskVolumeOptions } from 'cdk8s-plus-23' const gCEPersistentDiskVolumeOptions : GCEPersistentDiskVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import { HandlerFromHttpGetOptions } from 'cdk8s-plus-23' const handlerFromHttpGetOptions : HandlerFromHttpGetOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import { HandlerFromTcpSocketOptions } from 'cdk8s-plus-23' const handlerFromTcpSocketOptions : HandlerFromTcpSocketOptions = { ... } host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import { HostAlias } from 'cdk8s-plus-23' const hostAlias : HostAlias = { ... } hostnames Required \u00b6 public readonly hostnames : string []; Type: string [] Hostnames for the chosen IP address. ip Required \u00b6 public readonly ip : string ; Type: string IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import { HostPathVolumeOptions } from 'cdk8s-plus-23' const hostPathVolumeOptions : HostPathVolumeOptions = { ... } path Required \u00b6 public readonly path : string ; Type: string The path of the directory on the host. type Optional \u00b6 public readonly type : HostPathVolumeType ; Type: cdk8s-plus-23.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-23' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 public readonly scheme : ConnectionScheme ; Type: cdk8s-plus-23.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressProps } from 'cdk8s-plus-23' const ingressProps : IngressProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressBackend ; Type: cdk8s-plus-23.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressRule []; Type: cdk8s-plus-23.IngressRule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressTls []; Type: cdk8s-plus-23.IngressTls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressRule } from 'cdk8s-plus-23' const ingressRule : IngressRule = { ... } backend Required \u00b6 public readonly backend : IngressBackend ; Type: cdk8s-plus-23.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-23.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressTls } from 'cdk8s-plus-23' const ingressTls : IngressTls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-23.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-23' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import { LabelSelectorOptions } from 'cdk8s-plus-23' const labelSelectorOptions : LabelSelectorOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-23.LabelExpression [] Expression based label matchers. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import { LabelSelectorRequirement } from 'cdk8s-plus-23' const labelSelectorRequirement : LabelSelectorRequirement = { ... } key Required \u00b6 public readonly key : string ; Type: string The label key that the selector applies to. operator Required \u00b6 public readonly operator : string ; Type: string Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public readonly values : string []; Type: string [] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import { MemoryResources } from 'cdk8s-plus-23' const memoryResources : MemoryResources = { ... } limit Optional \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Optional \u00b6 public readonly request : Size ; Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-23' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import { NamespaceProps } from 'cdk8s-plus-23' const namespaceProps : NamespaceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import { NamespaceSelectorConfig } from 'cdk8s-plus-23' const namespaceSelectorConfig : NamespaceSelectorConfig = { ... } labelSelector Optional \u00b6 public readonly labelSelector : LabelSelector ; Type: cdk8s-plus-23.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 public readonly names : string []; Type: string [] A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import { NamespacesSelectOptions } from 'cdk8s-plus-23' const namespacesSelectOptions : NamespacesSelectOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-23.LabelExpression [] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 public readonly names : string []; Type: string [] Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import { NetworkPolicyAddEgressRuleOptions } from 'cdk8s-plus-23' const networkPolicyAddEgressRuleOptions : NetworkPolicyAddEgressRuleOptions = { ... } ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-23.NetworkPolicyPort [] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import { NetworkPolicyPeerConfig } from 'cdk8s-plus-23' const networkPolicyPeerConfig : NetworkPolicyPeerConfig = { ... } ipBlock Optional \u00b6 public readonly ipBlock : NetworkPolicyIpBlock ; Type: cdk8s-plus-23.NetworkPolicyIpBlock The ip block this peer represents. podSelector Optional \u00b6 public readonly podSelector : PodSelectorConfig ; Type: cdk8s-plus-23.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import { NetworkPolicyPortProps } from 'cdk8s-plus-23' const networkPolicyPortProps : NetworkPolicyPortProps = { ... } endPort Optional \u00b6 public readonly endPort : number ; Type: number Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 public readonly port : number ; Type: number Default: all ports are allowed. Specific port number. protocol Optional \u00b6 public readonly protocol : NetworkProtocol ; Type: cdk8s-plus-23.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import { NetworkPolicyProps } from 'cdk8s-plus-23' const networkPolicyProps : NetworkPolicyProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 public readonly egress : NetworkPolicyTraffic ; Type: cdk8s-plus-23.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 public readonly ingress : NetworkPolicyTraffic ; Type: cdk8s-plus-23.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 public readonly selector : IPodSelector ; Type: cdk8s-plus-23.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import { NetworkPolicyRule } from 'cdk8s-plus-23' const networkPolicyRule : NetworkPolicyRule = { ... } peer Required \u00b6 public readonly peer : INetworkPolicyPeer ; Type: cdk8s-plus-23.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-23.NetworkPolicyPort [] Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import { NetworkPolicyTraffic } from 'cdk8s-plus-23' const networkPolicyTraffic : NetworkPolicyTraffic = { ... } default Optional \u00b6 public readonly default : NetworkPolicyTrafficDefault ; Type: cdk8s-plus-23.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 public readonly rules : NetworkPolicyRule []; Type: cdk8s-plus-23.NetworkPolicyRule [] Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import { NodeTaintQueryOptions } from 'cdk8s-plus-23' const nodeTaintQueryOptions : NodeTaintQueryOptions = { ... } effect Optional \u00b6 public readonly effect : TaintEffect ; Type: cdk8s-plus-23.TaintEffect Default: all effects are matched. The taint effect to match. evictAfter Optional \u00b6 public readonly evictAfter : Duration ; Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-23' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import { PersistentVolumeClaimProps } from 'cdk8s-plus-23' const persistentVolumeClaimProps : PersistentVolumeClaimProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. - If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-23.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import { PersistentVolumeClaimVolumeOptions } from 'cdk8s-plus-23' const persistentVolumeClaimVolumeOptions : PersistentVolumeClaimVolumeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import { PersistentVolumeProps } from 'cdk8s-plus-23' const persistentVolumeProps : PersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-23.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-23.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-23.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-23.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import { PodConnectionsAllowFromOptions } from 'cdk8s-plus-23' const podConnectionsAllowFromOptions : PodConnectionsAllowFromOptions = { ... } isolation Optional \u00b6 public readonly isolation : PodConnectionsIsolation ; Type: cdk8s-plus-23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-23.NetworkPolicyPort [] Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import { PodConnectionsAllowToOptions } from 'cdk8s-plus-23' const podConnectionsAllowToOptions : PodConnectionsAllowToOptions = { ... } isolation Optional \u00b6 public readonly isolation : PodConnectionsIsolation ; Type: cdk8s-plus-23.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-23.NetworkPolicyPort [] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import { PodDnsProps } from 'cdk8s-plus-23' const podDnsProps : PodDnsProps = { ... } hostname Optional \u00b6 public readonly hostname : string ; Type: string Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public readonly nameservers : string []; Type: string [] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-23.DnsOption [] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-23.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public readonly searches : string []; Type: string [] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-23' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import { PodsAllOptions } from 'cdk8s-plus-23' const podsAllOptions : PodsAllOptions = { ... } namespaces Optional \u00b6 public readonly namespaces : Namespaces ; Type: cdk8s-plus-23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import { PodSchedulingAttractOptions } from 'cdk8s-plus-23' const podSchedulingAttractOptions : PodSchedulingAttractOptions = { ... } weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import { PodSchedulingColocateOptions } from 'cdk8s-plus-23' const podSchedulingColocateOptions : PodSchedulingColocateOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-23.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import { PodSchedulingSeparateOptions } from 'cdk8s-plus-23' const podSchedulingSeparateOptions : PodSchedulingSeparateOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-23.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import { PodSecurityContextProps } from 'cdk8s-plus-23' const podSecurityContextProps : PodSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-23.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-23.Sysctl [] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import { PodSelectorConfig } from 'cdk8s-plus-23' const podSelectorConfig : PodSelectorConfig = { ... } labelSelector Required \u00b6 public readonly labelSelector : LabelSelector ; Type: cdk8s-plus-23.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 public readonly namespaces : NamespaceSelectorConfig ; Type: cdk8s-plus-23.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import { PodsSelectOptions } from 'cdk8s-plus-23' const podsSelectOptions : PodsSelectOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-23.LabelExpression [] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 public readonly namespaces : Namespaces ; Type: cdk8s-plus-23.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-23' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-23' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import { RoleBindingProps } from 'cdk8s-plus-23' const roleBindingProps : RoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-23.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import { RolePolicyRule } from 'cdk8s-plus-23' const rolePolicyRule : RolePolicyRule = { ... } resources Required \u00b6 public readonly resources : IApiResource []; Type: cdk8s-plus-23.IApiResource [] Resources this rule applies to. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import { RoleProps } from 'cdk8s-plus-23' const roleProps : RoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-23.RolePolicyRule [] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-23' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-23' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-23.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import { SecretVolumeOptions } from 'cdk8s-plus-23' const secretVolumeOptions : SecretVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-23.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-23' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public readonly automountToken : boolean ; Type: boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-23.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import { ServiceAccountTokenSecretProps } from 'cdk8s-plus-23' const serviceAccountTokenSecretProps : ServiceAccountTokenSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import { ServiceBindOptions } from 'cdk8s-plus-23' const serviceBindOptions : ServiceBindOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressBackendOptions } from 'cdk8s-plus-23' const serviceIngressBackendOptions : ServiceIngressBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-23' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-23.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-23' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-23.ServicePort [] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 public readonly selector : IPodSelector ; Type: cdk8s-plus-23.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-23.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import { SshAuthSecretProps } from 'cdk8s-plus-23' const sshAuthSecretProps : SshAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public readonly sshPrivateKey : string ; Type: string The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-23' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-23.Service Service to associate with the statefulset. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-23.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-23.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import { StatefulSetUpdateStrategyRollingUpdateOptions } from 'cdk8s-plus-23' const statefulSetUpdateStrategyRollingUpdateOptions : StatefulSetUpdateStrategyRollingUpdateOptions = { ... } partition Optional \u00b6 public readonly partition : number ; Type: number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import { SubjectConfiguration } from 'cdk8s-plus-23' const subjectConfiguration : SubjectConfiguration = { ... } kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public readonly namespace : string ; Type: string Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import { Sysctl } from 'cdk8s-plus-23' const sysctl : Sysctl = { ... } name Required \u00b6 public readonly name : string ; Type: string Name of a property to set. value Required \u00b6 public readonly value : string ; Type: string Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import { TcpSocketProbeOptions } from 'cdk8s-plus-23' const tcpSocketProbeOptions : TcpSocketProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import { TlsSecretProps } from 'cdk8s-plus-23' const tlsSecretProps : TlsSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public readonly tlsCert : string ; Type: string The TLS cert. tlsKey Required \u00b6 public readonly tlsKey : string ; Type: string The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-23' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-23.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-23.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import { WorkloadProps } from 'cdk8s-plus-23' const workloadProps : WorkloadProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-23.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-23.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-23.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-23.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-23.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-23.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-23.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-23.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import { WorkloadSchedulingSpreadOptions } from 'cdk8s-plus-23' const workloadSchedulingSpreadOptions : WorkloadSchedulingSpreadOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-23.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s-plus-23.IApiResource , cdk8s-plus-23.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import { ApiResource } from 'cdk8s-plus-23' ApiResource . custom ( options : ApiResourceOptions ) options Required \u00b6 Type: cdk8s-plus-23.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s-plus-23.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-23' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-23.ContainerProps Methods \u00b6 addPort \u00b6 public addPort ( port : ContainerPort ) port Required \u00b6 Type: cdk8s-plus-23.ContainerPort mount \u00b6 public mount ( path : string , storage : IStorage , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. storage Required \u00b6 Type: cdk8s-plus-23.IStorage The storage to mount. options Optional \u00b6 Type: cdk8s-plus-23.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : Env ; Type: cdk8s-plus-23.Env The environment of the container. image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-23.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-23.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. ports Required \u00b6 public readonly ports : ContainerPort []; Type: cdk8s-plus-23.ContainerPort [] Ports exposed by this containers. Returns a copy, use addPort to modify. securityContext Required \u00b6 public readonly securityContext : ContainerSecurityContext ; Type: cdk8s-plus-23.ContainerSecurityContext The security context of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public readonly port : number ; Type: number portNumber Optional \u00b6 public readonly portNumber : number ; Type: number The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-23.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import { ContainerSecurityContext } from 'cdk8s-plus-23' new ContainerSecurityContext ( props? : ContainerSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-23.ContainerSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean privileged Required \u00b6 public readonly privileged : boolean ; Type: boolean readOnlyRootFilesystem Required \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean allowPrivilegeEscalation Optional \u00b6 public readonly allowPrivilegeEscalation : boolean ; Type: boolean group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import { Cpu } from 'cdk8s-plus-23' Cpu . millis ( amount : number ) amount Required \u00b6 Type: number units \u00b6 import { Cpu } from 'cdk8s-plus-23' Cpu . units ( amount : number ) amount Required \u00b6 Type: number Properties \u00b6 amount Required \u00b6 public readonly amount : string ; Type: string DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-23' DeploymentStrategy . recreate () rollingUpdate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-23' DeploymentStrategy . rollingUpdate ( options? : DeploymentStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-23.DeploymentStrategyRollingUpdateOptions Env \u00b6 Container environment variables. Initializers \u00b6 import { Env } from 'cdk8s-plus-23' new Env ( sources : EnvFrom [], variables : {[ key : string ] : EnvValue }) sources Required \u00b6 Type: cdk8s-plus-23.EnvFrom [] variables Required \u00b6 Type: {[ key: string ]: cdk8s-plus-23.EnvValue } Methods \u00b6 addVariable \u00b6 public addVariable ( name : string , value : EnvValue ) name Required \u00b6 Type: string value Required \u00b6 Type: cdk8s-plus-23.EnvValue copyFrom \u00b6 public copyFrom ( from : EnvFrom ) from Required \u00b6 Type: cdk8s-plus-23.EnvFrom Static Functions \u00b6 fromConfigMap \u00b6 import { Env } from 'cdk8s-plus-23' Env . fromConfigMap ( configMap : IConfigMap , prefix? : string ) configMap Required \u00b6 Type: cdk8s-plus-23.IConfigMap prefix Optional \u00b6 Type: string fromSecret \u00b6 import { Env } from 'cdk8s-plus-23' Env . fromSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-23.ISecret Properties \u00b6 sources Required \u00b6 public readonly sources : EnvFrom []; Type: cdk8s-plus-23.EnvFrom [] The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 public readonly variables : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-23.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import { EnvFrom } from 'cdk8s-plus-23' new EnvFrom ( configMap? : IConfigMap , prefix? : string , sec? : ISecret ) configMap Optional \u00b6 Type: cdk8s-plus-23.IConfigMap prefix Optional \u00b6 Type: string sec Optional \u00b6 Type: cdk8s-plus-23.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-23' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-23.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-23.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import { EnvValue } from 'cdk8s-plus-23' EnvValue . fromFieldRef ( fieldPath : EnvFieldPaths , options? : EnvValueFromFieldRefOptions ) fieldPath Required \u00b6 Type: cdk8s-plus-23.EnvFieldPaths : The field reference. options Optional \u00b6 Type: cdk8s-plus-23.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-23' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-23.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import { EnvValue } from 'cdk8s-plus-23' EnvValue . fromResource ( resource : ResourceFieldPaths , options? : EnvValueFromResourceOptions ) resource Required \u00b6 Type: cdk8s-plus-23.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: cdk8s-plus-23.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-23' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-23.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-23.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-23' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import { Handler } from 'cdk8s-plus-23' Handler . fromCommand ( command : string []) command Required \u00b6 Type: string [] The command to execute. fromHttpGet \u00b6 import { Handler } from 'cdk8s-plus-23' Handler . fromHttpGet ( path : string , options? : HandlerFromHttpGetOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-23.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import { Handler } from 'cdk8s-plus-23' Handler . fromTcpSocket ( options? : HandlerFromTcpSocketOptions ) options Optional \u00b6 Type: cdk8s-plus-23.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromResource \u00b6 import { IngressBackend } from 'cdk8s-plus-23' IngressBackend . fromResource ( resource : IResource ) resource Required \u00b6 Type: cdk8s-plus-23.IResource fromService \u00b6 import { IngressBackend } from 'cdk8s-plus-23' IngressBackend . fromService ( serv : Service , options? : ServiceIngressBackendOptions ) serv Required \u00b6 Type: cdk8s-plus-23.Service The service object. options Optional \u00b6 Type: cdk8s-plus-23.ServiceIngressBackendOptions LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import { LabeledNode } from 'cdk8s-plus-23' new LabeledNode ( labelSelector : NodeLabelQuery []) labelSelector Required \u00b6 Type: cdk8s-plus-23.NodeLabelQuery [] Properties \u00b6 labelSelector Required \u00b6 public readonly labelSelector : NodeLabelQuery []; Type: cdk8s-plus-23.NodeLabelQuery [] LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 doesNotExist \u00b6 import { LabelExpression } from 'cdk8s-plus-23' LabelExpression . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { LabelExpression } from 'cdk8s-plus-23' LabelExpression . exists ( key : string ) key Required \u00b6 Type: string in \u00b6 import { LabelExpression } from 'cdk8s-plus-23' LabelExpression . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] notIn \u00b6 import { LabelExpression } from 'cdk8s-plus-23' LabelExpression . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string operator Required \u00b6 public readonly operator : string ; Type: string values Optional \u00b6 public readonly values : string []; Type: string [] LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 isEmpty \u00b6 public isEmpty () Static Functions \u00b6 of \u00b6 import { LabelSelector } from 'cdk8s-plus-23' LabelSelector . of ( options? : LabelSelectorOptions ) options Optional \u00b6 Type: cdk8s-plus-23.LabelSelectorOptions NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import { NamedNode } from 'cdk8s-plus-23' new NamedNode ( name : string ) name Required \u00b6 Type: string Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 allTcp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . allTcp () allUdp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . allUdp () of \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . of ( props : NetworkPolicyPortProps ) props Required \u00b6 Type: cdk8s-plus-23.NetworkPolicyPortProps tcp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . tcp ( port : number ) port Required \u00b6 Type: number tcpRange \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . tcpRange ( startPort : number , endPort : number ) startPort Required \u00b6 Type: number endPort Required \u00b6 Type: number udp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . udp ( port : number ) port Required \u00b6 Type: number udpRange \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-23' NetworkPolicyPort . udpRange ( startPort : number , endPort : number ) startPort Required \u00b6 Type: number endPort Required \u00b6 Type: number Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import { Node } from 'cdk8s-plus-23' new Node () Static Functions \u00b6 labeled \u00b6 import { Node } from 'cdk8s-plus-23' Node . labeled ( labelSelector : NodeLabelQuery ) labelSelector Required \u00b6 Type: cdk8s-plus-23.NodeLabelQuery named \u00b6 import { Node } from 'cdk8s-plus-23' Node . named ( nodeName : string ) nodeName Required \u00b6 Type: string tainted \u00b6 import { Node } from 'cdk8s-plus-23' Node . tainted ( taintSelector : NodeTaintQuery ) taintSelector Required \u00b6 Type: cdk8s-plus-23.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 doesNotExist \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . exists ( key : string ) key Required \u00b6 Type: string gt \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . gt ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] in \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] is \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . is ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string lt \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . lt ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] notIn \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-23' NodeLabelQuery . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-23' NodeTaintQuery . any () exists \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-23' NodeTaintQuery . exists ( key : string , options? : NodeTaintQueryOptions ) key Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.NodeTaintQueryOptions is \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-23' NodeTaintQuery . is ( key : string , value : string , options? : NodeTaintQueryOptions ) key Required \u00b6 Type: string value Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-23.NodeTaintQueryOptions NonApiResource \u00b6 Implements: cdk8s-plus-23.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import { NonApiResource } from 'cdk8s-plus-23' NonApiResource . of ( url : string ) url Required \u00b6 Type: string PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-23' PercentOrAbsolute . absolute ( num : number ) num Required \u00b6 Type: number percent \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-23' PercentOrAbsolute . percent ( percent : number ) percent Required \u00b6 Type: number Properties \u00b6 value Required \u00b6 public readonly value : any ; Type: any PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import { PodConnections } from 'cdk8s-plus-23' new PodConnections ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-23.AbstractPod Methods \u00b6 allowFrom \u00b6 public allowFrom ( peer : INetworkPolicyPeer , options? : PodConnectionsAllowFromOptions ) peer Required \u00b6 Type: cdk8s-plus-23.INetworkPolicyPeer options Optional \u00b6 Type: cdk8s-plus-23.PodConnectionsAllowFromOptions allowTo \u00b6 public allowTo ( peer : INetworkPolicyPeer , options? : PodConnectionsAllowToOptions ) peer Required \u00b6 Type: cdk8s-plus-23.INetworkPolicyPeer options Optional \u00b6 Type: cdk8s-plus-23.PodConnectionsAllowToOptions PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import { PodDns } from 'cdk8s-plus-23' new PodDns ( props? : PodDnsProps ) props Optional \u00b6 Type: cdk8s-plus-23.PodDnsProps Methods \u00b6 addNameserver \u00b6 public addNameserver ( nameservers : string ) nameservers Required \u00b6 Type: string addOption \u00b6 public addOption ( options : DnsOption ) options Required \u00b6 Type: cdk8s-plus-23.DnsOption addSearch \u00b6 public addSearch ( searches : string ) searches Required \u00b6 Type: string Properties \u00b6 hostnameAsFQDN Required \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public readonly nameservers : string []; Type: string [] Nameservers defined for this pod. options Required \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-23.DnsOption [] Custom dns options defined for this pod. policy Required \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-23.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public readonly searches : string []; Type: string [] Search domains defined for this pod. hostname Optional \u00b6 public readonly hostname : string ; Type: string The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import { PodScheduling } from 'cdk8s-plus-23' new PodScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-23.AbstractPod Methods \u00b6 assign \u00b6 public assign ( node : NamedNode ) node Required \u00b6 Type: cdk8s-plus-23.NamedNode attract \u00b6 public attract ( node : LabeledNode , options? : PodSchedulingAttractOptions ) node Required \u00b6 Type: cdk8s-plus-23.LabeledNode options Optional \u00b6 Type: cdk8s-plus-23.PodSchedulingAttractOptions colocate \u00b6 public colocate ( selector : IPodSelector , options? : PodSchedulingColocateOptions ) selector Required \u00b6 Type: cdk8s-plus-23.IPodSelector options Optional \u00b6 Type: cdk8s-plus-23.PodSchedulingColocateOptions separate \u00b6 public separate ( selector : IPodSelector , options? : PodSchedulingSeparateOptions ) selector Required \u00b6 Type: cdk8s-plus-23.IPodSelector options Optional \u00b6 Type: cdk8s-plus-23.PodSchedulingSeparateOptions tolerate \u00b6 public tolerate ( node : TaintedNode ) node Required \u00b6 Type: cdk8s-plus-23.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import { PodSecurityContext } from 'cdk8s-plus-23' new PodSecurityContext ( props? : PodSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-23.PodSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean fsGroupChangePolicy Required \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-23.FsGroupChangePolicy sysctls Required \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-23.Sysctl [] fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-23' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-23.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-23' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-23.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import { Probe } from 'cdk8s-plus-23' Probe . fromTcpSocket ( options? : TcpSocketProbeOptions ) options Optional \u00b6 Type: cdk8s-plus-23.TcpSocketProbeOptions Options. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import { ResourcePermissions } from 'cdk8s-plus-23' new ResourcePermissions ( instance : Resource ) instance Required \u00b6 Type: cdk8s-plus-23.Resource Methods \u00b6 grantRead \u00b6 public grantRead ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-23.ISubject grantReadWrite \u00b6 public grantReadWrite ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-23.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-23' StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-23' StatefulSetUpdateStrategy . rollingUpdate ( options? : StatefulSetUpdateStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-23.StatefulSetUpdateStrategyRollingUpdateOptions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import { TaintedNode } from 'cdk8s-plus-23' new TaintedNode ( taintSelector : NodeTaintQuery []) taintSelector Required \u00b6 Type: cdk8s-plus-23.NodeTaintQuery [] Properties \u00b6 taintSelector Required \u00b6 public readonly taintSelector : NodeTaintQuery []; Type: cdk8s-plus-23.NodeTaintQuery [] Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import { Topology } from 'cdk8s-plus-23' Topology . custom ( key : string ) key Required \u00b6 Type: string Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string Constants \u00b6 HOSTNAME \u00b6 Type: cdk8s-plus-23.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: cdk8s-plus-23.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: cdk8s-plus-23.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import { WorkloadScheduling } from 'cdk8s-plus-23' new WorkloadScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-23.AbstractPod Methods \u00b6 spread \u00b6 public spread ( options? : WorkloadSchedulingSpreadOptions ) options Optional \u00b6 Type: cdk8s-plus-23.WorkloadSchedulingSpreadOptions Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.ApiResource , cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.ClusterRole , cdk8s-plus-23.ClusterRoleBinding , cdk8s-plus-23.ConfigMap , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.Ingress , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.NetworkPolicy , cdk8s-plus-23.NonApiResource , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.Pod , cdk8s-plus-23.Resource , cdk8s-plus-23.Role , cdk8s-plus-23.RoleBinding , cdk8s-plus-23.Secret , cdk8s-plus-23.Service , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.Workload , cdk8s-plus-23.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.ApiResource , cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.ClusterRole , cdk8s-plus-23.ClusterRoleBinding , cdk8s-plus-23.ConfigMap , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.Ingress , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.NetworkPolicy , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.Pod , cdk8s-plus-23.Resource , cdk8s-plus-23.Role , cdk8s-plus-23.RoleBinding , cdk8s-plus-23.Secret , cdk8s-plus-23.Service , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.Workload , cdk8s-plus-23.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ClusterRole , cdk8s-plus-23.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ConfigMap , cdk8s-plus-23.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.Namespace , cdk8s-plus-23.Namespaces , cdk8s-plus-23.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.Namespaces , cdk8s-plus-23.NetworkPolicyIpBlock , cdk8s-plus-23.Pod , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.Workload , cdk8s-plus-23.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. IPersistentVolume \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.Job , cdk8s-plus-23.Pod , cdk8s-plus-23.Pods , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.Workload , cdk8s-plus-23.IPodSelector Represents an object that can select pods. Methods \u00b6 toPodSelectorConfig \u00b6 public toPodSelectorConfig () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. IResource \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.ClusterRole , cdk8s-plus-23.ClusterRoleBinding , cdk8s-plus-23.ConfigMap , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.Ingress , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.NetworkPolicy , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.Pod , cdk8s-plus-23.Resource , cdk8s-plus-23.Role , cdk8s-plus-23.RoleBinding , cdk8s-plus-23.Secret , cdk8s-plus-23.Service , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.Workload , cdk8s-plus-23.IClusterRole , cdk8s-plus-23.IConfigMap , cdk8s-plus-23.IPersistentVolume , cdk8s-plus-23.IPersistentVolumeClaim , cdk8s-plus-23.IResource , cdk8s-plus-23.IRole , cdk8s-plus-23.ISecret , cdk8s-plus-23.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ClusterRole , cdk8s-plus-23.Role , cdk8s-plus-23.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.Secret , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.ISecret Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.IServiceAccount Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IStorage \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.Volume , cdk8s-plus-23.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. ISubject \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.Group , cdk8s-plus-23.Job , cdk8s-plus-23.Pod , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.User , cdk8s-plus-23.Workload , cdk8s-plus-23.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. - Pods that tolerate the taint without specifying duration remain bound forever. - Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"TypeScript"},{"location":"reference/cdk8s-plus-23/typescript/#cdk8s-plus-23-typescript","text":"","title":"cdk8s-plus-23 (TypeScript) "},{"location":"reference/cdk8s-plus-23/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-23/typescript/#abstractpod","text":"Implements: cdk8s-plus-23.IPodSelector , cdk8s-plus-23.INetworkPolicyPeer , cdk8s-plus-23.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-23/typescript/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-23/typescript/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-23/typescript/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-23/typescript/#clusterrole","text":"Implements: cdk8s-plus-23.IClusterRole , cdk8s-plus-23.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-23/typescript/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-23/typescript/#configmap","text":"Implements: cdk8s-plus-23.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-23/typescript/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-23/typescript/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-23/typescript/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-23/typescript/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-23/typescript/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-23/typescript/#group","text":"Implements: cdk8s-plus-23.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-23/typescript/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-23/typescript/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-23/typescript/#namespace","text":"Implements: cdk8s-plus-23.INamespaceSelector , cdk8s-plus-23.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-23/typescript/#namespaces","text":"Implements: cdk8s-plus-23.INamespaceSelector , cdk8s-plus-23.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicyipblock","text":"Implements: cdk8s-plus-23.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolume","text":"Implements: cdk8s-plus-23.IPersistentVolume , cdk8s-plus-23.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumeclaim","text":"Implements: cdk8s-plus-23.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-23/typescript/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-23/typescript/#pods","text":"Implements: cdk8s-plus-23.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-23/typescript/#resource","text":"Implements: cdk8s-plus-23.IResource , cdk8s-plus-23.IApiResource , cdk8s-plus-23.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-23/typescript/#role","text":"Implements: cdk8s-plus-23.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-23/typescript/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-23/typescript/#secret","text":"Implements: cdk8s-plus-23.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-23/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-23/typescript/#serviceaccount","text":"Implements: cdk8s-plus-23.IServiceAccount , cdk8s-plus-23.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-23/typescript/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-23/typescript/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-23/typescript/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-23/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-23/typescript/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-23/typescript/#user","text":"Implements: cdk8s-plus-23.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-23/typescript/#volume","text":"Implements: cdk8s-plus-23.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-23/typescript/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-23/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-23/typescript/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-23/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-23/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-23/typescript/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-23/typescript/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/typescript/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/typescript/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-23/typescript/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-23/typescript/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-23/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-23/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-23/typescript/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-23/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-23/typescript/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-23/typescript/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-23/typescript/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-23/typescript/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-23/typescript/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-23/typescript/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-23/typescript/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-23/typescript/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-23/typescript/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-23/typescript/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-23/typescript/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-23/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-23/typescript/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-23/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-23/typescript/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-23/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-23/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-23/typescript/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/typescript/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-23/typescript/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-23/typescript/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-23/typescript/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-23/typescript/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-23/typescript/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-23/typescript/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-23/typescript/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-23/typescript/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-23/typescript/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-23/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-23/typescript/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-23/typescript/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-23/typescript/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-23/typescript/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-23/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-23/typescript/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-23/typescript/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-23/typescript/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-23/typescript/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-23/typescript/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-23/typescript/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-23/typescript/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-23/typescript/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-23/typescript/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-23/typescript/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-23/typescript/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-23/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-23/typescript/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-23/typescript/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-23/typescript/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-23/typescript/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-23/typescript/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-23/typescript/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-23/typescript/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-23/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-23/typescript/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-23/typescript/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-23/typescript/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-23/typescript/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-23/typescript/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-23/typescript/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-23/typescript/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-23/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-23/typescript/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-23/typescript/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-23/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-23/typescript/#apiresource","text":"Implements: cdk8s-plus-23.IApiResource , cdk8s-plus-23.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-23/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-23/typescript/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-23/typescript/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-23/typescript/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-23/typescript/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-23/typescript/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-23/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-23/typescript/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-23/typescript/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-23/typescript/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-23/typescript/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-23/typescript/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-23/typescript/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-23/typescript/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-23/typescript/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-23/typescript/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-23/typescript/#nonapiresource","text":"Implements: cdk8s-plus-23.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-23/typescript/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-23/typescript/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-23/typescript/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-23/typescript/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-23/typescript/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-23/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-23/typescript/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-23/typescript/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-23/typescript/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-23/typescript/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-23/typescript/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-23/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-23/typescript/#iapiendpoint","text":"Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.ApiResource , cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.ClusterRole , cdk8s-plus-23.ClusterRoleBinding , cdk8s-plus-23.ConfigMap , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.Ingress , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.NetworkPolicy , cdk8s-plus-23.NonApiResource , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.Pod , cdk8s-plus-23.Resource , cdk8s-plus-23.Role , cdk8s-plus-23.RoleBinding , cdk8s-plus-23.Secret , cdk8s-plus-23.Service , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.Workload , cdk8s-plus-23.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-23/typescript/#iapiresource","text":"Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.ApiResource , cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.ClusterRole , cdk8s-plus-23.ClusterRoleBinding , cdk8s-plus-23.ConfigMap , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.Ingress , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.NetworkPolicy , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.Pod , cdk8s-plus-23.Resource , cdk8s-plus-23.Role , cdk8s-plus-23.RoleBinding , cdk8s-plus-23.Secret , cdk8s-plus-23.Service , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.Workload , cdk8s-plus-23.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-23/typescript/#iclusterrole","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ClusterRole , cdk8s-plus-23.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-23/typescript/#iconfigmap","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ConfigMap , cdk8s-plus-23.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-23/typescript/#inamespaceselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.Namespace , cdk8s-plus-23.Namespaces , cdk8s-plus-23.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-23/typescript/#inetworkpolicypeer","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.Namespaces , cdk8s-plus-23.NetworkPolicyIpBlock , cdk8s-plus-23.Pod , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.Workload , cdk8s-plus-23.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-23/typescript/#ipersistentvolume","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-23/typescript/#ipersistentvolumeclaim","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-23/typescript/#ipodselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.Job , cdk8s-plus-23.Pod , cdk8s-plus-23.Pods , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.Workload , cdk8s-plus-23.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-23/typescript/#iresource","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.ClusterRole , cdk8s-plus-23.ClusterRoleBinding , cdk8s-plus-23.ConfigMap , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.Ingress , cdk8s-plus-23.Job , cdk8s-plus-23.Namespace , cdk8s-plus-23.NetworkPolicy , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.PersistentVolumeClaim , cdk8s-plus-23.Pod , cdk8s-plus-23.Resource , cdk8s-plus-23.Role , cdk8s-plus-23.RoleBinding , cdk8s-plus-23.Secret , cdk8s-plus-23.Service , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.Workload , cdk8s-plus-23.IClusterRole , cdk8s-plus-23.IConfigMap , cdk8s-plus-23.IPersistentVolume , cdk8s-plus-23.IPersistentVolumeClaim , cdk8s-plus-23.IResource , cdk8s-plus-23.IRole , cdk8s-plus-23.ISecret , cdk8s-plus-23.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-23/typescript/#irole","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ClusterRole , cdk8s-plus-23.Role , cdk8s-plus-23.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-23/typescript/#isecret","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.BasicAuthSecret , cdk8s-plus-23.DockerConfigSecret , cdk8s-plus-23.Secret , cdk8s-plus-23.ServiceAccountTokenSecret , cdk8s-plus-23.SshAuthSecret , cdk8s-plus-23.TlsSecret , cdk8s-plus-23.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-23/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-23.IResource Implemented By: cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-23/typescript/#istorage","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AwsElasticBlockStorePersistentVolume , cdk8s-plus-23.AzureDiskPersistentVolume , cdk8s-plus-23.GCEPersistentDiskPersistentVolume , cdk8s-plus-23.PersistentVolume , cdk8s-plus-23.Volume , cdk8s-plus-23.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-23/typescript/#isubject","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-23.AbstractPod , cdk8s-plus-23.CronJob , cdk8s-plus-23.DaemonSet , cdk8s-plus-23.Deployment , cdk8s-plus-23.Group , cdk8s-plus-23.Job , cdk8s-plus-23.Pod , cdk8s-plus-23.ServiceAccount , cdk8s-plus-23.StatefulSet , cdk8s-plus-23.User , cdk8s-plus-23.Workload , cdk8s-plus-23.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-23/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-23/typescript/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-23/typescript/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-23/typescript/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-23/typescript/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-23/typescript/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-23/typescript/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-23/typescript/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-23/typescript/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-23/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-23/typescript/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-23/typescript/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-23/typescript/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-23/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-23/typescript/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-23/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-23/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-23/typescript/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-24/go/","text":"cdk8s-plus-24 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus24 .","title":"Go"},{"location":"reference/cdk8s-plus-24/go/#cdk8s-plus-24-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus24 .","title":"cdk8s-plus-24 (Go) "},{"location":"reference/cdk8s-plus-24/java/","text":"cdk8s-plus-24 (Java) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: org.cdk8s.plus24.IPodSelector , org.cdk8s.plus24.INetworkPolicyPeer , org.cdk8s.plus24.ISubject Initializers \u00b6 import org.cdk8s.plus24.AbstractPod ; AbstractPod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus24.ContainerProps addHostAlias \u00b6 public addHostAlias ( HostAlias hostAlias ) hostAlias Required \u00b6 Type: org.cdk8s.plus24.HostAlias addInitContainer \u00b6 public addInitContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus24.ContainerProps addVolume \u00b6 public addVolume ( Volume vol ) vol Required \u00b6 Type: org.cdk8s.plus24.Volume toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 automountServiceAccountToken Required \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus24.Container > dns Required \u00b6 public PodDns getDns (); Type: org.cdk8s.plus24.PodDns hostAliases Required \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > initContainers Required \u00b6 public java . util . List < Container > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.Container > podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition securityContext Required \u00b6 public PodSecurityContext getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContext volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume ; AwsElasticBlockStorePersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Volume id of this volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import org.cdk8s.plus24.AzureDiskPersistentVolume ; AzureDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 Type: org.cdk8s.plus24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: org.cdk8s.plus24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azureKind Required \u00b6 public AzureDiskPersistentVolumeKind getAzureKind (); Type: org.cdk8s.plus24.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus24.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String Disk name of this volume. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String Disk URI of this volume. fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import org.cdk8s.plus24.BasicAuthSecret ; BasicAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: java.lang.String The password or token for authentication. username Required \u00b6 Type: java.lang.String The user name for authentication. ClusterRole \u00b6 Implements: org.cdk8s.plus24.IClusterRole , org.cdk8s.plus24.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import org.cdk8s.plus24.ClusterRole ; ClusterRole . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 public aggregate ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiEndpoint endpoints ) verbs Required \u00b6 Type: java.util.List< java.lang.String > endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus24.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( java . lang . String namespace , ISubject subjects ) namespace Required \u00b6 Type: java.lang.String the namespace to limit permissions to. subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject a list of subjects to bind to. combine \u00b6 public combine ( ClusterRole rol ) rol Required \u00b6 Type: org.cdk8s.plus24.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import org.cdk8s.plus24.ClusterRole ; ClusterRole . fromClusterRoleName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus24.ClusterRolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import org.cdk8s.plus24.ClusterRoleBinding ; ClusterRoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus24.IClusterRole The role to bind to. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus24.IClusterRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus24.ISubject > ConfigMap \u00b6 Implements: org.cdk8s.plus24.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus24.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus24.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus24.ConfigMap ; ConfigMap . fromConfigMapName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not this config map is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import org.cdk8s.plus24.CronJob ; CronJob . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . schedule ( Cron ) // .concurrencyPolicy(ConcurrencyPolicy) // .failedJobsRetained(java.lang.Number) // .startingDeadline(Duration) // .successfulJobsRetained(java.lang.Number) // .suspend(java.lang.Boolean) // .timeZone(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 Type: org.cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 Type: org.cdk8s.plus24.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 Type: java.lang.Number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 Type: java.lang.Number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 Type: java.lang.Boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. timeZone Optional \u00b6 Type: java.lang.String Default: Timezone of kube-controller-manager process. Specifies the timezone for the job. This helps aligining the schedule to follow the specified timezone. {@link https://en.wikipedia.org/wiki/List_of_tz_database_time_zones} for list of valid timezone values. Properties \u00b6 concurrencyPolicy Required \u00b6 public java . lang . String getConcurrencyPolicy (); Type: java.lang.String The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failedJobsRetained Required \u00b6 public java . lang . Number getFailedJobsRetained (); Type: java.lang.Number The number of failed jobs retained by this cron job. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String Represents the resource type. schedule Required \u00b6 public Cron getSchedule (); Type: org.cdk8s.Cron The schedule this cron job is scheduled to run in. startingDeadline Required \u00b6 public Duration getStartingDeadline (); Type: org.cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successfulJobsRetained Required \u00b6 public java . lang . Number getSuccessfulJobsRetained (); Type: java.lang.Number The number of successful jobs retained by this cron job. suspend Required \u00b6 public java . lang . Boolean getSuspend (); Type: java.lang.Boolean Whether or not the cron job is currently suspended or not. timeZone Optional \u00b6 public java . lang . String getTimeZone (); Type: java.lang.String The timezone which this cron job would follow to schedule jobs. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import org.cdk8s.plus24.DaemonSet ; DaemonSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 minReadySeconds Required \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus24.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: java.lang.Number Default: 2 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus24.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus24.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( DeploymentExposeViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.DeploymentExposeViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus24.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import org.cdk8s.plus24.DockerConfigSecret ; DockerConfigSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import org.cdk8s.plus24.GCEPersistentDiskPersistentVolume ; GCEPersistentDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String PD resource in GCE of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. Group \u00b6 Implements: org.cdk8s.plus24.ISubject Represents a group. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import org.cdk8s.plus24.Group ; Group . fromName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String name Required \u00b6 public java . lang . String getName (); Type: java.lang.String apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus24.Ingress ; Ingress . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus24.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressBackend backend ) backend Required \u00b6 Type: org.cdk8s.plus24.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressBackend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus24.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend ) public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus24.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus24.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( java . lang . String path , IngressBackend backend ) public addRule ( java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus24.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus24.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( IngressRule rules ) rules Required \u00b6 Type: org.cdk8s.plus24.IngressRule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressTls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus24.IngressTls > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus24.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: org.cdk8s.plus24.INamespaceSelector , org.cdk8s.plus24.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import org.cdk8s.plus24.Namespace ; Namespace . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: java.lang.String https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: org.cdk8s.plus24.INamespaceSelector , org.cdk8s.plus24.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import org.cdk8s.plus24.Namespaces ; new Namespaces ( Construct scope , java . lang . String id ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . List < java . lang . String > names ); new Namespaces ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . List < java . lang . String > names , java . util . Map < java . lang . String , java . lang . String > labels ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String expressions Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.LabelExpression > names Optional \u00b6 Type: java.util.List< java.lang.String > labels Optional \u00b6 Type: java.util.Map java.lang.String > Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 all \u00b6 import org.cdk8s.plus24.Namespaces ; Namespaces . all ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String select \u00b6 import org.cdk8s.plus24.Namespaces ; Namespaces . select ( Construct scope , java . lang . String id , NamespacesSelectOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus24.NamespacesSelectOptions NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import org.cdk8s.plus24.NetworkPolicy ; NetworkPolicy . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .egress(NetworkPolicyTraffic) // .ingress(NetworkPolicyTraffic) // .selector(IPodSelector) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 Type: org.cdk8s.plus24.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 Type: org.cdk8s.plus24.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 Type: org.cdk8s.plus24.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that Methods \u00b6 addEgressRule \u00b6 public addEgressRule ( INetworkPolicyPeer peer ) public addEgressRule ( INetworkPolicyPeer peer , java . util . List < NetworkPolicyPort > ports ) peer Required \u00b6 Type: org.cdk8s.plus24.INetworkPolicyPeer ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.NetworkPolicyPort > addIngressRule \u00b6 public addIngressRule ( INetworkPolicyPeer peer ) public addIngressRule ( INetworkPolicyPeer peer , java . util . List < NetworkPolicyPort > ports ) peer Required \u00b6 Type: org.cdk8s.plus24.INetworkPolicyPeer ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.NetworkPolicyPort > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: org.cdk8s.plus24.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 anyIpv4 \u00b6 import org.cdk8s.plus24.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . anyIpv4 ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String anyIpv6 \u00b6 import org.cdk8s.plus24.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . anyIpv6 ( Construct scope , java . lang . String id ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String ipv4 \u00b6 import org.cdk8s.plus24.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . ipv4 ( Construct scope , java . lang . String id , java . lang . String cidrIp ) NetworkPolicyIpBlock . ipv4 ( Construct scope , java . lang . String id , java . lang . String cidrIp , java . util . List < java . lang . String > except ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String cidrIp Required \u00b6 Type: java.lang.String except Optional \u00b6 Type: java.util.List< java.lang.String > ipv6 \u00b6 import org.cdk8s.plus24.NetworkPolicyIpBlock ; NetworkPolicyIpBlock . ipv6 ( Construct scope , java . lang . String id , java . lang . String cidrIp ) NetworkPolicyIpBlock . ipv6 ( Construct scope , java . lang . String id , java . lang . String cidrIp , java . util . List < java . lang . String > except ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String cidrIp Required \u00b6 Type: java.lang.String except Optional \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 cidr Required \u00b6 public java . lang . String getCidr (); Type: java.lang.String A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 public java . util . List < java . lang . String > getExcept (); Type: java.util.List< java.lang.String > A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: org.cdk8s.plus24.IPersistentVolume , org.cdk8s.plus24.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import org.cdk8s.plus24.PersistentVolume ; PersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( IPersistentVolumeClaim claim ) claim Required \u00b6 Type: org.cdk8s.plus24.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import org.cdk8s.plus24.PersistentVolume ; PersistentVolume . fromPersistentVolumeName ( Construct scope , java . lang . String id , java . lang . String volumeName ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String volumeName Required \u00b6 Type: java.lang.String Properties \u00b6 mode Required \u00b6 public PersistentVolumeMode getMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Access modes requirement of this claim. claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus24.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Mount options of this volume. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: org.cdk8s.plus24.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import org.cdk8s.plus24.PersistentVolumeClaim ; PersistentVolumeClaim . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: org.cdk8s.plus24.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 public bind ( IPersistentVolume vol ) vol Required \u00b6 Type: org.cdk8s.plus24.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import org.cdk8s.plus24.PersistentVolumeClaim ; PersistentVolumeClaim . fromClaimName ( Construct scope , java . lang . String id , java . lang . String claimName ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String claimName Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Access modes requirement of this claim. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class requirment of this claim. volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus24.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus24.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 connections Required \u00b6 public PodConnections getConnections (); Type: org.cdk8s.plus24.PodConnections podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 public PodScheduling getScheduling (); Type: org.cdk8s.plus24.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: java.lang.String This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: org.cdk8s.plus24.IPodSelector Represents a group of pods. Initializers \u00b6 import org.cdk8s.plus24.Pods ; new Pods ( Construct scope , java . lang . String id ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . Map < java . lang . String , java . lang . String > labels ); new Pods ( Construct scope , java . lang . String id , java . util . List < LabelExpression > expressions , java . util . Map < java . lang . String , java . lang . String > labels , INamespaceSelector namespaces ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String expressions Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.LabelExpression > labels Optional \u00b6 Type: java.util.Map java.lang.String > namespaces Optional \u00b6 Type: org.cdk8s.plus24.INamespaceSelector Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () Static Functions \u00b6 all \u00b6 import org.cdk8s.plus24.Pods ; Pods . all ( Construct scope , java . lang . String id ) Pods . all ( Construct scope , java . lang . String id , PodsAllOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.PodsAllOptions select \u00b6 import org.cdk8s.plus24.Pods ; Pods . select ( Construct scope , java . lang . String id , PodsSelectOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus24.PodsSelectOptions Resource \u00b6 Implements: org.cdk8s.plus24.IResource , org.cdk8s.plus24.IApiResource , org.cdk8s.plus24.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus24.Resource ; new Resource ( Construct scope , java . lang . String id ); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. permissions Required \u00b6 public ResourcePermissions getPermissions (); Type: org.cdk8s.plus24.ResourcePermissions resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: org.cdk8s.plus24.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import org.cdk8s.plus24.Role ; Role . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.RolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiResource resources ) verbs Required \u00b6 Type: java.util.List< java.lang.String > resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus24.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import org.cdk8s.plus24.Role ; Role . fromRoleName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus24.RolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import org.cdk8s.plus24.RoleBinding ; RoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus24.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus24.IRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus24.ISubject > Secret \u00b6 Implements: org.cdk8s.plus24.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus24.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus24.Secret ; Secret . fromSecretName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not the secret is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus24.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .selector(IPodSelector) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ServicePort > Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 Type: org.cdk8s.plus24.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 Type: org.cdk8s.plus24.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 bind \u00b6 public bind ( java . lang . Number port ) public bind ( java . lang . Number port , ServiceBindOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus24.ServiceBindOptions exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus24.ExposeServiceViaIngressOptions Additional options. select \u00b6 public select ( IPodSelector selector ) selector Required \u00b6 Type: org.cdk8s.plus24.IPodSelector selectLabel \u00b6 public selectLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus24.ServicePort > Ports for this service. Use bind() to bind additional service ports. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus24.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus24.IServiceAccount , org.cdk8s.plus24.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus24.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus24.ISecret The secret. toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus24.ServiceAccount ; ServiceAccount . fromServiceAccountName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus24.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import org.cdk8s.plus24.ServiceAccountTokenSecret ; ServiceAccountTokenSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 Type: org.cdk8s.plus24.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import org.cdk8s.plus24.SshAuthSecret ; SshAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 Type: java.lang.String The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus24.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 Type: org.cdk8s.plus24.Service Service to associate with the statefulset. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus24.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus24.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus24.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus24.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import org.cdk8s.plus24.TlsSecret ; TlsSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 Type: java.lang.String The TLS cert. tlsKey Required \u00b6 Type: java.lang.String The TLS key. User \u00b6 Implements: org.cdk8s.plus24.ISubject Represents a user. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import org.cdk8s.plus24.User ; User . fromName ( Construct scope , java . lang . String id , java . lang . String name ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String name Required \u00b6 public java . lang . String getName (); Type: java.lang.String apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String Volume \u00b6 Implements: org.cdk8s.plus24.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromAwsElasticBlockStore ( Construct scope , java . lang . String id , java . lang . String volumeId ) Volume . fromAwsElasticBlockStore ( Construct scope , java . lang . String id , java . lang . String volumeId , AwsElasticBlockStoreVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String volumeId Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromAzureDisk ( Construct scope , java . lang . String id , java . lang . String diskName , java . lang . String diskUri ) Volume . fromAzureDisk ( Construct scope , java . lang . String id , java . lang . String diskName , java . lang . String diskUri , AzureDiskVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String diskName Required \u00b6 Type: java.lang.String diskUri Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.AzureDiskVolumeOptions fromConfigMap \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromConfigMap ( Construct scope , java . lang . String id , IConfigMap configMap ) Volume . fromConfigMap ( Construct scope , java . lang . String id , IConfigMap configMap , ConfigMapVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String configMap Required \u00b6 Type: org.cdk8s.plus24.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus24.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromEmptyDir ( Construct scope , java . lang . String id , java . lang . String name ) Volume . fromEmptyDir ( Construct scope , java . lang . String id , java . lang . String name , EmptyDirVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromGcePersistentDisk ( Construct scope , java . lang . String id , java . lang . String pdName ) Volume . fromGcePersistentDisk ( Construct scope , java . lang . String id , java . lang . String pdName , GCEPersistentDiskVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String pdName Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.GCEPersistentDiskVolumeOptions fromHostPath \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromHostPath ( Construct scope , java . lang . String id , java . lang . String name , HostPathVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String name Required \u00b6 Type: java.lang.String options Required \u00b6 Type: org.cdk8s.plus24.HostPathVolumeOptions fromPersistentVolumeClaim \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromPersistentVolumeClaim ( Construct scope , java . lang . String id , IPersistentVolumeClaim claim ) Volume . fromPersistentVolumeClaim ( Construct scope , java . lang . String id , IPersistentVolumeClaim claim , PersistentVolumeClaimVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String claim Required \u00b6 Type: org.cdk8s.plus24.IPersistentVolumeClaim options Optional \u00b6 Type: org.cdk8s.plus24.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import org.cdk8s.plus24.Volume ; Volume . fromSecret ( Construct scope , java . lang . String id , ISecret secr ) Volume . fromSecret ( Construct scope , java . lang . String id , ISecret secr , SecretVolumeOptions options ) scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String secr Required \u00b6 Type: org.cdk8s.plus24.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus24.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import org.cdk8s.plus24.Workload ; Workload . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints Methods \u00b6 select \u00b6 public select ( LabelSelector selectors ) selectors Required \u00b6 Type: org.cdk8s.plus24.LabelSelector Properties \u00b6 connections Required \u00b6 public PodConnections getConnections (); Type: org.cdk8s.plus24.PodConnections matchExpressions Required \u00b6 public java . util . List < LabelSelectorRequirement > getMatchExpressions (); Type: java.util.List< org.cdk8s.plus24.LabelSelectorRequirement > The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getMatchLabels (); Type: java.util.Map java.lang.String > The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 public WorkloadScheduling getScheduling (); Type: org.cdk8s.plus24.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import org.cdk8s.plus24.AbstractPodProps ; AbstractPodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus24.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus24.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import org.cdk8s.plus24.ApiResourceOptions ; ApiResourceOptions . builder () . apiGroup ( java . lang . String ) . resourceType ( java . lang . String ) . build (); apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import org.cdk8s.plus24.AwsElasticBlockStorePersistentVolumeProps ; AwsElasticBlockStorePersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import org.cdk8s.plus24.AwsElasticBlockStoreVolumeOptions ; AwsElasticBlockStoreVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus24.AzureDiskPersistentVolumeProps ; AzureDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import org.cdk8s.plus24.AzureDiskVolumeOptions ; AzureDiskVolumeOptions . builder () // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import org.cdk8s.plus24.BasicAuthSecretProps ; BasicAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public java . lang . String getPassword (); Type: java.lang.String The password or token for authentication. username Required \u00b6 public java . lang . String getUsername (); Type: java.lang.String The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import org.cdk8s.plus24.ClusterRoleBindingProps ; ClusterRoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus24.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import org.cdk8s.plus24.ClusterRolePolicyRule ; ClusterRolePolicyRule . builder () . endpoints ( java . util . List < IApiEndpoint > ) . verbs ( java . util . List < java . lang . String > ) . build (); endpoints Required \u00b6 public java . util . List < IApiEndpoint > getEndpoints (); Type: java.util.List< org.cdk8s.plus24.IApiEndpoint > Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import org.cdk8s.plus24.ClusterRoleProps ; ClusterRoleProps . builder () // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAggregationLabels (); Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus24.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus24.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import org.cdk8s.plus24.CommonSecretProps ; CommonSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus24.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus24.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:11033\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import org.cdk8s.plus24.ContainerLifecycle ; ContainerLifecycle . builder () // .postStart(Handler) // .preStop(Handler) . build (); postStart Optional \u00b6 public Handler getPostStart (); Type: org.cdk8s.plus24.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public Handler getPreStop (); Type: org.cdk8s.plus24.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import org.cdk8s.plus24.ContainerPort ; ContainerPort . builder () . number ( java . lang . Number ) // .hostIp(java.lang.String) // .hostPort(java.lang.Number) // .name(java.lang.String) // .protocol(Protocol) . build (); number Required \u00b6 public java . lang . Number getNumber (); Type: java.lang.Number Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. hostIp Optional \u00b6 public java . lang . String getHostIp (); Type: java.lang.String Default: 127.0.0.1. What host IP to bind the external port to. hostPort Optional \u00b6 public java . lang . Number getHostPort (); Type: java.lang.Number Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus24.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus24.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .envFrom(java.util.List<EnvFrom>) // .envVariables(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .portNumber(java.lang.Number) // .ports(java.util.List<ContainerPort>) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 public java . util . List < EnvFrom > getEnvFrom (); Type: java.util.List< org.cdk8s.plus24.EnvFrom > Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnvVariables (); Type: java.util.Map \u0002klzzwxh:10987\u0003 > Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public ContainerLifecycle getLifecycle (); Type: org.cdk8s.plus24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public java . lang . Number getPort (); Type: java.lang.Number portNumber Optional \u00b6 public java . lang . Number getPortNumber (); Type: java.lang.Number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 public java . util . List < ContainerPort > getPorts (); Type: java.util.List< org.cdk8s.plus24.ContainerPort > Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public ContainerSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus24.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import org.cdk8s.plus24.ContainerResources ; ContainerResources . builder () // .cpu(CpuResources) // .ephemeralStorage(EphemeralStorageResources) // .memory(MemoryResources) . build (); cpu Optional \u00b6 public CpuResources getCpu (); Type: org.cdk8s.plus24.CpuResources ephemeralStorage Optional \u00b6 public EphemeralStorageResources getEphemeralStorage (); Type: org.cdk8s.plus24.EphemeralStorageResources memory Optional \u00b6 public MemoryResources getMemory (); Type: org.cdk8s.plus24.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import org.cdk8s.plus24.ContainerSecurityContextProps ; ContainerSecurityContextProps . builder () // .allowPrivilegeEscalation(java.lang.Boolean) // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); allowPrivilegeEscalation Optional \u00b6 public java . lang . Boolean getAllowPrivilegeEscalation (); Type: java.lang.Boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import org.cdk8s.plus24.CpuResources ; CpuResources . builder () // .limit(Cpu) // .request(Cpu) . build (); limit Optional \u00b6 public Cpu getLimit (); Type: org.cdk8s.plus24.Cpu request Optional \u00b6 public Cpu getRequest (); Type: org.cdk8s.plus24.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import org.cdk8s.plus24.CronJobProps ; CronJobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . schedule ( Cron ) // .concurrencyPolicy(ConcurrencyPolicy) // .failedJobsRetained(java.lang.Number) // .startingDeadline(Duration) // .successfulJobsRetained(java.lang.Number) // .suspend(java.lang.Boolean) // .timeZone(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 public Cron getSchedule (); Type: org.cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 public ConcurrencyPolicy getConcurrencyPolicy (); Type: org.cdk8s.plus24.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 public java . lang . Number getFailedJobsRetained (); Type: java.lang.Number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 public Duration getStartingDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 public java . lang . Number getSuccessfulJobsRetained (); Type: java.lang.Number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 public java . lang . Boolean getSuspend (); Type: java.lang.Boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. timeZone Optional \u00b6 public java . lang . String getTimeZone (); Type: java.lang.String Default: Timezone of kube-controller-manager process. Specifies the timezone for the job. This helps aligining the schedule to follow the specified timezone. {@link https://en.wikipedia.org/wiki/List_of_tz_database_time_zones} for list of valid timezone values. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import org.cdk8s.plus24.DaemonSetProps ; DaemonSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import org.cdk8s.plus24.DeploymentExposeViaServiceOptions ; DeploymentExposeViaServiceOptions . builder () // .name(java.lang.String) // .ports(java.util.List<ServicePort>) // .serviceType(ServiceType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus24.ServicePort > Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus24.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import org.cdk8s.plus24.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 2 Number of desired pods. strategy Optional \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus24.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus24.DeploymentStrategyRollingUpdateOptions ; DeploymentStrategyRollingUpdateOptions . builder () // .maxSurge(PercentOrAbsolute) // .maxUnavailable(PercentOrAbsolute) . build (); maxSurge Optional \u00b6 public PercentOrAbsolute getMaxSurge (); Type: org.cdk8s.plus24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public PercentOrAbsolute getMaxUnavailable (); Type: org.cdk8s.plus24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import org.cdk8s.plus24.DnsOption ; DnsOption . builder () . name ( java . lang . String ) // .value(java.lang.String) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Option name. value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import org.cdk8s.plus24.DockerConfigSecretProps ; DockerConfigSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getData (); Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus24.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus24.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus24.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import org.cdk8s.plus24.EnvValueFromFieldRefOptions ; EnvValueFromFieldRefOptions . builder () // .apiVersion(java.lang.String) // .key(java.lang.String) . build (); apiVersion Optional \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus24.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import org.cdk8s.plus24.EnvValueFromResourceOptions ; EnvValueFromResourceOptions . builder () // .container(Container) // .divisor(java.lang.String) . build (); container Optional \u00b6 public Container getContainer (); Type: org.cdk8s.plus24.Container The container to select the value from. divisor Optional \u00b6 public java . lang . String getDivisor (); Type: java.lang.String The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus24.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import org.cdk8s.plus24.EphemeralStorageResources ; EphemeralStorageResources . builder () // .limit(Size) // .request(Size) . build (); limit Optional \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Optional \u00b6 public Size getRequest (); Type: org.cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus24.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .ports(java.util.List<ServicePort>) // .serviceType(ServiceType) // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus24.ServicePort > Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus24.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus24.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus24.GCEPersistentDiskPersistentVolumeProps ; GCEPersistentDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import org.cdk8s.plus24.GCEPersistentDiskVolumeOptions ; GCEPersistentDiskVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import org.cdk8s.plus24.HandlerFromHttpGetOptions ; HandlerFromHttpGetOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import org.cdk8s.plus24.HandlerFromTcpSocketOptions ; HandlerFromTcpSocketOptions . builder () // .host(java.lang.String) // .port(java.lang.Number) . build (); host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import org.cdk8s.plus24.HostAlias ; HostAlias . builder () . hostnames ( java . util . List < java . lang . String > ) . ip ( java . lang . String ) . build (); hostnames Required \u00b6 public java . util . List < java . lang . String > getHostnames (); Type: java.util.List< java.lang.String > Hostnames for the chosen IP address. ip Required \u00b6 public java . lang . String getIp (); Type: java.lang.String IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import org.cdk8s.plus24.HostPathVolumeOptions ; HostPathVolumeOptions . builder () . path ( java . lang . String ) // .type(HostPathVolumeType) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The path of the directory on the host. type Optional \u00b6 public HostPathVolumeType getType (); Type: org.cdk8s.plus24.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus24.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) // .scheme(ConnectionScheme) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 public ConnectionScheme getScheme (); Type: org.cdk8s.plus24.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus24.IngressProps ; IngressProps . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressBackend getDefaultBackend (); Type: org.cdk8s.plus24.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressRule > getRules (); Type: java.util.List< org.cdk8s.plus24.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressTls > getTls (); Type: java.util.List< org.cdk8s.plus24.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus24.IngressRule ; IngressRule . builder () . backend ( IngressBackend ) // .host(java.lang.String) // .path(java.lang.String) // .pathType(HttpIngressPathType) . build (); backend Required \u00b6 public IngressBackend getBackend (); Type: org.cdk8s.plus24.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus24.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus24.IngressTls ; IngressTls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus24.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import org.cdk8s.plus24.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import org.cdk8s.plus24.LabelSelectorOptions ; LabelSelectorOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus24.LabelExpression > Expression based label matchers. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import org.cdk8s.plus24.LabelSelectorRequirement ; LabelSelectorRequirement . builder () . key ( java . lang . String ) . operator ( java . lang . String ) // .values(java.util.List<java.lang.String>) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The label key that the selector applies to. operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import org.cdk8s.plus24.MemoryResources ; MemoryResources . builder () // .limit(Size) // .request(Size) . build (); limit Optional \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Optional \u00b6 public Size getRequest (); Type: org.cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus24.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import org.cdk8s.plus24.NamespaceProps ; NamespaceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import org.cdk8s.plus24.NamespaceSelectorConfig ; NamespaceSelectorConfig . builder () // .labelSelector(LabelSelector) // .names(java.util.List<java.lang.String>) . build (); labelSelector Optional \u00b6 public LabelSelector getLabelSelector (); Type: org.cdk8s.plus24.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 public java . util . List < java . lang . String > getNames (); Type: java.util.List< java.lang.String > A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import org.cdk8s.plus24.NamespacesSelectOptions ; NamespacesSelectOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .names(java.util.List<java.lang.String>) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus24.LabelExpression > Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 public java . util . List < java . lang . String > getNames (); Type: java.util.List< java.lang.String > Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import org.cdk8s.plus24.NetworkPolicyAddEgressRuleOptions ; NetworkPolicyAddEgressRuleOptions . builder () // .ports(java.util.List<NetworkPolicyPort>) . build (); ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus24.NetworkPolicyPort > Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import org.cdk8s.plus24.NetworkPolicyPeerConfig ; NetworkPolicyPeerConfig . builder () // .ipBlock(NetworkPolicyIpBlock) // .podSelector(PodSelectorConfig) . build (); ipBlock Optional \u00b6 public NetworkPolicyIpBlock getIpBlock (); Type: org.cdk8s.plus24.NetworkPolicyIpBlock The ip block this peer represents. podSelector Optional \u00b6 public PodSelectorConfig getPodSelector (); Type: org.cdk8s.plus24.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import org.cdk8s.plus24.NetworkPolicyPortProps ; NetworkPolicyPortProps . builder () // .endPort(java.lang.Number) // .port(java.lang.Number) // .protocol(NetworkProtocol) . build (); endPort Optional \u00b6 public java . lang . Number getEndPort (); Type: java.lang.Number Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: all ports are allowed. Specific port number. protocol Optional \u00b6 public NetworkProtocol getProtocol (); Type: org.cdk8s.plus24.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import org.cdk8s.plus24.NetworkPolicyProps ; NetworkPolicyProps . builder () // .metadata(ApiObjectMetadata) // .egress(NetworkPolicyTraffic) // .ingress(NetworkPolicyTraffic) // .selector(IPodSelector) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 public NetworkPolicyTraffic getEgress (); Type: org.cdk8s.plus24.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 public NetworkPolicyTraffic getIngress (); Type: org.cdk8s.plus24.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 public IPodSelector getSelector (); Type: org.cdk8s.plus24.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import org.cdk8s.plus24.NetworkPolicyRule ; NetworkPolicyRule . builder () . peer ( INetworkPolicyPeer ) // .ports(java.util.List<NetworkPolicyPort>) . build (); peer Required \u00b6 public INetworkPolicyPeer getPeer (); Type: org.cdk8s.plus24.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus24.NetworkPolicyPort > Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import org.cdk8s.plus24.NetworkPolicyTraffic ; NetworkPolicyTraffic . builder () // .default(NetworkPolicyTrafficDefault) // .rules(java.util.List<NetworkPolicyRule>) . build (); default Optional \u00b6 public NetworkPolicyTrafficDefault getDefault (); Type: org.cdk8s.plus24.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 public java . util . List < NetworkPolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus24.NetworkPolicyRule > Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import org.cdk8s.plus24.NodeTaintQueryOptions ; NodeTaintQueryOptions . builder () // .effect(TaintEffect) // .evictAfter(Duration) . build (); effect Optional \u00b6 public TaintEffect getEffect (); Type: org.cdk8s.plus24.TaintEffect Default: all effects are matched. The taint effect to match. evictAfter Optional \u00b6 public Duration getEvictAfter (); Type: org.cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus24.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import org.cdk8s.plus24.PersistentVolumeClaimProps ; PersistentVolumeClaimProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus24.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import org.cdk8s.plus24.PersistentVolumeClaimVolumeOptions ; PersistentVolumeClaimVolumeOptions . builder () // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import org.cdk8s.plus24.PersistentVolumeProps ; PersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus24.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import org.cdk8s.plus24.PodConnectionsAllowFromOptions ; PodConnectionsAllowFromOptions . builder () // .isolation(PodConnectionsIsolation) // .ports(java.util.List<NetworkPolicyPort>) . build (); isolation Optional \u00b6 public PodConnectionsIsolation getIsolation (); Type: org.cdk8s.plus24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus24.NetworkPolicyPort > Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import org.cdk8s.plus24.PodConnectionsAllowToOptions ; PodConnectionsAllowToOptions . builder () // .isolation(PodConnectionsIsolation) // .ports(java.util.List<NetworkPolicyPort>) . build (); isolation Optional \u00b6 public PodConnectionsIsolation getIsolation (); Type: org.cdk8s.plus24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public java . util . List < NetworkPolicyPort > getPorts (); Type: java.util.List< org.cdk8s.plus24.NetworkPolicyPort > Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import org.cdk8s.plus24.PodDnsProps ; PodDnsProps . builder () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus24.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus24.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import org.cdk8s.plus24.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import org.cdk8s.plus24.PodsAllOptions ; PodsAllOptions . builder () // .namespaces(Namespaces) . build (); namespaces Optional \u00b6 public Namespaces getNamespaces (); Type: org.cdk8s.plus24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import org.cdk8s.plus24.PodSchedulingAttractOptions ; PodSchedulingAttractOptions . builder () // .weight(java.lang.Number) . build (); weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import org.cdk8s.plus24.PodSchedulingColocateOptions ; PodSchedulingColocateOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus24.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import org.cdk8s.plus24.PodSchedulingSeparateOptions ; PodSchedulingSeparateOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus24.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import org.cdk8s.plus24.PodSecurityContextProps ; PodSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus24.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus24.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import org.cdk8s.plus24.PodSelectorConfig ; PodSelectorConfig . builder () . labelSelector ( LabelSelector ) // .namespaces(NamespaceSelectorConfig) . build (); labelSelector Required \u00b6 public LabelSelector getLabelSelector (); Type: org.cdk8s.plus24.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 public NamespaceSelectorConfig getNamespaces (); Type: org.cdk8s.plus24.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import org.cdk8s.plus24.PodsSelectOptions ; PodsSelectOptions . builder () // .expressions(java.util.List<LabelExpression>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespaces(Namespaces) . build (); expressions Optional \u00b6 public java . util . List < LabelExpression > getExpressions (); Type: java.util.List< org.cdk8s.plus24.LabelExpression > Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 public Namespaces getNamespaces (); Type: org.cdk8s.plus24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus24.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus24.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import org.cdk8s.plus24.RoleBindingProps ; RoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus24.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import org.cdk8s.plus24.RolePolicyRule ; RolePolicyRule . builder () . resources ( java . util . List < IApiResource > ) . verbs ( java . util . List < java . lang . String > ) . build (); resources Required \u00b6 public java . util . List < IApiResource > getResources (); Type: java.util.List< org.cdk8s.plus24.IApiResource > Resources this rule applies to. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import org.cdk8s.plus24.RoleProps ; RoleProps . builder () // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus24.RolePolicyRule > Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import org.cdk8s.plus24.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus24.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus24.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import org.cdk8s.plus24.SecretVolumeOptions ; SecretVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:10051\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus24.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus24.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import org.cdk8s.plus24.ServiceAccountTokenSecretProps ; ServiceAccountTokenSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import org.cdk8s.plus24.ServiceBindOptions ; ServiceBindOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus24.ServiceIngressBackendOptions ; ServiceIngressBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus24.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import org.cdk8s.plus24.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .selector(IPodSelector) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus24.ServicePort > Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 public IPodSelector getSelector (); Type: org.cdk8s.plus24.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus24.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import org.cdk8s.plus24.SshAuthSecretProps ; SshAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public java . lang . String getSshPrivateKey (); Type: java.lang.String The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus24.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 public Service getService (); Type: org.cdk8s.plus24.Service Service to associate with the statefulset. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus24.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus24.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus24.StatefulSetUpdateStrategyRollingUpdateOptions ; StatefulSetUpdateStrategyRollingUpdateOptions . builder () // .partition(java.lang.Number) . build (); partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import org.cdk8s.plus24.SubjectConfiguration ; SubjectConfiguration . builder () . kind ( java . lang . String ) . name ( java . lang . String ) // .apiGroup(java.lang.String) // .namespace(java.lang.String) . build (); kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import org.cdk8s.plus24.Sysctl ; Sysctl . builder () . name ( java . lang . String ) . value ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of a property to set. value Required \u00b6 public java . lang . String getValue (); Type: java.lang.String Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import org.cdk8s.plus24.TcpSocketProbeOptions ; TcpSocketProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .host(java.lang.String) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import org.cdk8s.plus24.TlsSecretProps ; TlsSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public java . lang . String getTlsCert (); Type: java.lang.String The TLS cert. tlsKey Required \u00b6 public java . lang . String getTlsKey (); Type: java.lang.String The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus24.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus24.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import org.cdk8s.plus24.WorkloadProps ; WorkloadProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .spread(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus24.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus24.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus24.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public java . lang . Boolean getSpread (); Type: java.lang.Boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import org.cdk8s.plus24.WorkloadSchedulingSpreadOptions ; WorkloadSchedulingSpreadOptions . builder () // .topology(Topology) // .weight(java.lang.Number) . build (); topology Optional \u00b6 public Topology getTopology (); Type: org.cdk8s.plus24.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 public java . lang . Number getWeight (); Type: java.lang.Number Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: org.cdk8s.plus24.IApiResource , org.cdk8s.plus24.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus24.ApiResource ; ApiResource . custom ( ApiResourceOptions options ) options Required \u00b6 Type: org.cdk8s.plus24.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Ingress. JOBS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Job. LEASES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: org.cdk8s.plus24.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus24.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .envFrom(java.util.List<EnvFrom>) // .envVariables(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .portNumber(java.lang.Number) // .ports(java.util.List<ContainerPort>) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.EnvFrom > Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 Type: java.util.Map \u0002klzzwxh:9571\u0003 > Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: org.cdk8s.plus24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: org.cdk8s.plus24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: java.lang.Number portNumber Optional \u00b6 Type: java.lang.Number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.ContainerPort > Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: org.cdk8s.plus24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: org.cdk8s.plus24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 Type: org.cdk8s.plus24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: org.cdk8s.plus24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addPort \u00b6 public addPort ( ContainerPort port ) port Required \u00b6 Type: org.cdk8s.plus24.ContainerPort mount \u00b6 public mount ( java . lang . String path , IStorage storage ) public mount ( java . lang . String path , IStorage storage , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. storage Required \u00b6 Type: org.cdk8s.plus24.IStorage The storage to mount. options Optional \u00b6 Type: org.cdk8s.plus24.MountOptions Properties \u00b6 env Required \u00b6 public Env getEnv (); Type: org.cdk8s.plus24.Env The environment of the container. image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus24.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus24.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. ports Required \u00b6 public java . util . List < ContainerPort > getPorts (); Type: java.util.List< org.cdk8s.plus24.ContainerPort > Ports exposed by this containers. Returns a copy, use addPort to modify. securityContext Required \u00b6 public ContainerSecurityContext getSecurityContext (); Type: org.cdk8s.plus24.ContainerSecurityContext The security context of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public java . lang . Number getPort (); Type: java.lang.Number portNumber Optional \u00b6 public java . lang . Number getPortNumber (); Type: java.lang.Number The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus24.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import org.cdk8s.plus24.ContainerSecurityContext ; ContainerSecurityContext . Builder . create () // .allowPrivilegeEscalation(java.lang.Boolean) // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); allowPrivilegeEscalation Optional \u00b6 Type: java.lang.Boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: java.lang.Number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 Type: java.lang.Boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 Type: java.lang.Number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean privileged Required \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean readOnlyRootFilesystem Required \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean allowPrivilegeEscalation Optional \u00b6 public java . lang . Boolean getAllowPrivilegeEscalation (); Type: java.lang.Boolean group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import org.cdk8s.plus24.Cpu ; Cpu . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number units \u00b6 import org.cdk8s.plus24.Cpu ; Cpu . units ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Properties \u00b6 amount Required \u00b6 public java . lang . String getAmount (); Type: java.lang.String DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import org.cdk8s.plus24.DeploymentStrategy ; DeploymentStrategy . recreate () rollingUpdate \u00b6 import org.cdk8s.plus24.DeploymentStrategy ; DeploymentStrategy . rollingUpdate () DeploymentStrategy . rollingUpdate ( DeploymentStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.DeploymentStrategyRollingUpdateOptions Env \u00b6 Container environment variables. Initializers \u00b6 import org.cdk8s.plus24.Env ; new Env ( java . util . List < EnvFrom > sources , java . util . Map < java . lang . String , EnvValue > variables ); sources Required \u00b6 Type: java.util.List< org.cdk8s.plus24.EnvFrom > variables Required \u00b6 Type: java.util.Map \u0002klzzwxh:9431\u0003 > Methods \u00b6 addVariable \u00b6 public addVariable ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String value Required \u00b6 Type: org.cdk8s.plus24.EnvValue copyFrom \u00b6 public copyFrom ( EnvFrom from ) from Required \u00b6 Type: org.cdk8s.plus24.EnvFrom Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus24.Env ; Env . fromConfigMap ( IConfigMap configMap ) Env . fromConfigMap ( IConfigMap configMap , java . lang . String prefix ) configMap Required \u00b6 Type: org.cdk8s.plus24.IConfigMap prefix Optional \u00b6 Type: java.lang.String fromSecret \u00b6 import org.cdk8s.plus24.Env ; Env . fromSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus24.ISecret Properties \u00b6 sources Required \u00b6 public java . util . List < EnvFrom > getSources (); Type: java.util.List< org.cdk8s.plus24.EnvFrom > The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getVariables (); Type: java.util.Map \u0002klzzwxh:9408\u0003 > The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import org.cdk8s.plus24.EnvFrom ; new EnvFrom (); new EnvFrom ( IConfigMap configMap ); new EnvFrom ( IConfigMap configMap , java . lang . String prefix ); new EnvFrom ( IConfigMap configMap , java . lang . String prefix , ISecret sec ); configMap Optional \u00b6 Type: org.cdk8s.plus24.IConfigMap prefix Optional \u00b6 Type: java.lang.String sec Optional \u00b6 Type: org.cdk8s.plus24.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus24.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus24.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus24.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import org.cdk8s.plus24.EnvValue ; EnvValue . fromFieldRef ( EnvFieldPaths fieldPath ) EnvValue . fromFieldRef ( EnvFieldPaths fieldPath , EnvValueFromFieldRefOptions options ) fieldPath Required \u00b6 Type: org.cdk8s.plus24.EnvFieldPaths : The field reference. options Optional \u00b6 Type: org.cdk8s.plus24.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import org.cdk8s.plus24.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus24.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import org.cdk8s.plus24.EnvValue ; EnvValue . fromResource ( ResourceFieldPaths resource ) EnvValue . fromResource ( ResourceFieldPaths resource , EnvValueFromResourceOptions options ) resource Required \u00b6 Type: org.cdk8s.plus24.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: org.cdk8s.plus24.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import org.cdk8s.plus24.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus24.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus24.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus24.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus24.Handler ; Handler . fromCommand ( java . util . List < java . lang . String > command ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. fromHttpGet \u00b6 import org.cdk8s.plus24.Handler ; Handler . fromHttpGet ( java . lang . String path ) Handler . fromHttpGet ( java . lang . String path , HandlerFromHttpGetOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus24.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus24.Handler ; Handler . fromTcpSocket () Handler . fromTcpSocket ( HandlerFromTcpSocketOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromResource \u00b6 import org.cdk8s.plus24.IngressBackend ; IngressBackend . fromResource ( IResource resource ) resource Required \u00b6 Type: org.cdk8s.plus24.IResource fromService \u00b6 import org.cdk8s.plus24.IngressBackend ; IngressBackend . fromService ( Service serv ) IngressBackend . fromService ( Service serv , ServiceIngressBackendOptions options ) serv Required \u00b6 Type: org.cdk8s.plus24.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus24.ServiceIngressBackendOptions LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import org.cdk8s.plus24.LabeledNode ; new LabeledNode ( java . util . List < NodeLabelQuery > labelSelector ); labelSelector Required \u00b6 Type: java.util.List< org.cdk8s.plus24.NodeLabelQuery > Properties \u00b6 labelSelector Required \u00b6 public java . util . List < NodeLabelQuery > getLabelSelector (); Type: java.util.List< org.cdk8s.plus24.NodeLabelQuery > LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus24.LabelExpression ; LabelExpression . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus24.LabelExpression ; LabelExpression . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String in \u00b6 import org.cdk8s.plus24.LabelExpression ; LabelExpression . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > notIn \u00b6 import org.cdk8s.plus24.LabelExpression ; LabelExpression . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Required \u00b6 public java . lang . String getOperator (); Type: java.lang.String values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 isEmpty \u00b6 public isEmpty () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus24.LabelSelector ; LabelSelector . of () LabelSelector . of ( LabelSelectorOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.LabelSelectorOptions NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import org.cdk8s.plus24.NamedNode ; new NamedNode ( java . lang . String name ); name Required \u00b6 Type: java.lang.String Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 allTcp \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . allTcp () allUdp \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . allUdp () of \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . of ( NetworkPolicyPortProps props ) props Required \u00b6 Type: org.cdk8s.plus24.NetworkPolicyPortProps tcp \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . tcp ( java . lang . Number port ) port Required \u00b6 Type: java.lang.Number tcpRange \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . tcpRange ( java . lang . Number startPort , java . lang . Number endPort ) startPort Required \u00b6 Type: java.lang.Number endPort Required \u00b6 Type: java.lang.Number udp \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . udp ( java . lang . Number port ) port Required \u00b6 Type: java.lang.Number udpRange \u00b6 import org.cdk8s.plus24.NetworkPolicyPort ; NetworkPolicyPort . udpRange ( java . lang . Number startPort , java . lang . Number endPort ) startPort Required \u00b6 Type: java.lang.Number endPort Required \u00b6 Type: java.lang.Number Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import org.cdk8s.plus24.Node ; new Node (); Static Functions \u00b6 labeled \u00b6 import org.cdk8s.plus24.Node ; Node . labeled ( NodeLabelQuery labelSelector ) labelSelector Required \u00b6 Type: org.cdk8s.plus24.NodeLabelQuery named \u00b6 import org.cdk8s.plus24.Node ; Node . named ( java . lang . String nodeName ) nodeName Required \u00b6 Type: java.lang.String tainted \u00b6 import org.cdk8s.plus24.Node ; Node . tainted ( NodeTaintQuery taintSelector ) taintSelector Required \u00b6 Type: org.cdk8s.plus24.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String gt \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . gt ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > in \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > is \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . is ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String lt \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . lt ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > notIn \u00b6 import org.cdk8s.plus24.NodeLabelQuery ; NodeLabelQuery . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import org.cdk8s.plus24.NodeTaintQuery ; NodeTaintQuery . any () exists \u00b6 import org.cdk8s.plus24.NodeTaintQuery ; NodeTaintQuery . exists ( java . lang . String key ) NodeTaintQuery . exists ( java . lang . String key , NodeTaintQueryOptions options ) key Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.NodeTaintQueryOptions is \u00b6 import org.cdk8s.plus24.NodeTaintQuery ; NodeTaintQuery . is ( java . lang . String key , java . lang . String value ) NodeTaintQuery . is ( java . lang . String key , java . lang . String value , NodeTaintQueryOptions options ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus24.NodeTaintQueryOptions NonApiResource \u00b6 Implements: org.cdk8s.plus24.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus24.NonApiResource ; NonApiResource . of ( java . lang . String url ) url Required \u00b6 Type: java.lang.String PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import org.cdk8s.plus24.PercentOrAbsolute ; PercentOrAbsolute . absolute ( java . lang . Number num ) num Required \u00b6 Type: java.lang.Number percent \u00b6 import org.cdk8s.plus24.PercentOrAbsolute ; PercentOrAbsolute . percent ( java . lang . Number percent ) percent Required \u00b6 Type: java.lang.Number Properties \u00b6 value Required \u00b6 public java . lang . Object getValue (); Type: java.lang.Object PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import org.cdk8s.plus24.PodConnections ; new PodConnections ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus24.AbstractPod Methods \u00b6 allowFrom \u00b6 public allowFrom ( INetworkPolicyPeer peer ) public allowFrom ( INetworkPolicyPeer peer , PodConnectionsAllowFromOptions options ) peer Required \u00b6 Type: org.cdk8s.plus24.INetworkPolicyPeer options Optional \u00b6 Type: org.cdk8s.plus24.PodConnectionsAllowFromOptions allowTo \u00b6 public allowTo ( INetworkPolicyPeer peer ) public allowTo ( INetworkPolicyPeer peer , PodConnectionsAllowToOptions options ) peer Required \u00b6 Type: org.cdk8s.plus24.INetworkPolicyPeer options Optional \u00b6 Type: org.cdk8s.plus24.PodConnectionsAllowToOptions PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import org.cdk8s.plus24.PodDns ; PodDns . Builder . create () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: org.cdk8s.plus24.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 addNameserver \u00b6 public addNameserver ( java . lang . String nameservers ) nameservers Required \u00b6 Type: java.lang.String addOption \u00b6 public addOption ( DnsOption options ) options Required \u00b6 Type: org.cdk8s.plus24.DnsOption addSearch \u00b6 public addSearch ( java . lang . String searches ) searches Required \u00b6 Type: java.lang.String Properties \u00b6 hostnameAsFQDN Required \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > Nameservers defined for this pod. options Required \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus24.DnsOption > Custom dns options defined for this pod. policy Required \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus24.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > Search domains defined for this pod. hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import org.cdk8s.plus24.PodScheduling ; new PodScheduling ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus24.AbstractPod Methods \u00b6 assign \u00b6 public assign ( NamedNode node ) node Required \u00b6 Type: org.cdk8s.plus24.NamedNode attract \u00b6 public attract ( LabeledNode node ) public attract ( LabeledNode node , PodSchedulingAttractOptions options ) node Required \u00b6 Type: org.cdk8s.plus24.LabeledNode options Optional \u00b6 Type: org.cdk8s.plus24.PodSchedulingAttractOptions colocate \u00b6 public colocate ( IPodSelector selector ) public colocate ( IPodSelector selector , PodSchedulingColocateOptions options ) selector Required \u00b6 Type: org.cdk8s.plus24.IPodSelector options Optional \u00b6 Type: org.cdk8s.plus24.PodSchedulingColocateOptions separate \u00b6 public separate ( IPodSelector selector ) public separate ( IPodSelector selector , PodSchedulingSeparateOptions options ) selector Required \u00b6 Type: org.cdk8s.plus24.IPodSelector options Optional \u00b6 Type: org.cdk8s.plus24.PodSchedulingSeparateOptions tolerate \u00b6 public tolerate ( TaintedNode node ) node Required \u00b6 Type: org.cdk8s.plus24.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import org.cdk8s.plus24.PodSecurityContext ; PodSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 Type: org.cdk8s.plus24.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: java.util.List< org.cdk8s.plus24.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean fsGroupChangePolicy Required \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus24.FsGroupChangePolicy sysctls Required \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus24.Sysctl > fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus24.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus24.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus24.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus24.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus24.Probe ; Probe . fromTcpSocket () Probe . fromTcpSocket ( TcpSocketProbeOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.TcpSocketProbeOptions Options. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import org.cdk8s.plus24.ResourcePermissions ; new ResourcePermissions ( Resource instance ); instance Required \u00b6 Type: org.cdk8s.plus24.Resource Methods \u00b6 grantRead \u00b6 public grantRead ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject grantReadWrite \u00b6 public grantReadWrite ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus24.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import org.cdk8s.plus24.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import org.cdk8s.plus24.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . rollingUpdate () StatefulSetUpdateStrategy . rollingUpdate ( StatefulSetUpdateStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.StatefulSetUpdateStrategyRollingUpdateOptions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import org.cdk8s.plus24.TaintedNode ; new TaintedNode ( java . util . List < NodeTaintQuery > taintSelector ); taintSelector Required \u00b6 Type: java.util.List< org.cdk8s.plus24.NodeTaintQuery > Properties \u00b6 taintSelector Required \u00b6 public java . util . List < NodeTaintQuery > getTaintSelector (); Type: java.util.List< org.cdk8s.plus24.NodeTaintQuery > Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus24.Topology ; Topology . custom ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Properties \u00b6 key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String Constants \u00b6 HOSTNAME \u00b6 Type: org.cdk8s.plus24.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: org.cdk8s.plus24.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: org.cdk8s.plus24.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import org.cdk8s.plus24.WorkloadScheduling ; new WorkloadScheduling ( AbstractPod instance ); instance Required \u00b6 Type: org.cdk8s.plus24.AbstractPod Methods \u00b6 spread \u00b6 public spread () public spread ( WorkloadSchedulingSpreadOptions options ) options Optional \u00b6 Type: org.cdk8s.plus24.WorkloadSchedulingSpreadOptions Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.ApiResource , org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.ClusterRoleBinding , org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.Ingress , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.NetworkPolicy , org.cdk8s.plus24.NonApiResource , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Resource , org.cdk8s.plus24.Role , org.cdk8s.plus24.RoleBinding , org.cdk8s.plus24.Secret , org.cdk8s.plus24.Service , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.ApiResource , org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.ClusterRoleBinding , org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.Ingress , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.NetworkPolicy , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Resource , org.cdk8s.plus24.Role , org.cdk8s.plus24.RoleBinding , org.cdk8s.plus24.Secret , org.cdk8s.plus24.Service , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IConfigMap \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.Namespace , org.cdk8s.plus24.Namespaces , org.cdk8s.plus24.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.Namespaces , org.cdk8s.plus24.NetworkPolicyIpBlock , org.cdk8s.plus24.Pod , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.Workload , org.cdk8s.plus24.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. IPersistentVolume \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSelector \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.Job , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Pods , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IPodSelector Represents an object that can select pods. Methods \u00b6 toPodSelectorConfig \u00b6 public toPodSelectorConfig () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. IResource \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.ClusterRoleBinding , org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.Ingress , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.NetworkPolicy , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Resource , org.cdk8s.plus24.Role , org.cdk8s.plus24.RoleBinding , org.cdk8s.plus24.Secret , org.cdk8s.plus24.Service , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IClusterRole , org.cdk8s.plus24.IConfigMap , org.cdk8s.plus24.IPersistentVolume , org.cdk8s.plus24.IPersistentVolumeClaim , org.cdk8s.plus24.IResource , org.cdk8s.plus24.IRole , org.cdk8s.plus24.ISecret , org.cdk8s.plus24.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IRole \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.Role , org.cdk8s.plus24.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.Secret , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.ISecret Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.IServiceAccount Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IStorage \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.Volume , org.cdk8s.plus24.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. ISubject \u00b6 Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.Group , org.cdk8s.plus24.Job , org.cdk8s.plus24.Pod , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.User , org.cdk8s.plus24.Workload , org.cdk8s.plus24.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 node Required \u00b6 public Node getNode (); Type: software.constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. Pods that tolerate the taint without specifying duration remain bound forever. Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"Java"},{"location":"reference/cdk8s-plus-24/java/#cdk8s-plus-24-java","text":"","title":"cdk8s-plus-24 (Java) "},{"location":"reference/cdk8s-plus-24/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-24/java/#abstractpod","text":"Implements: org.cdk8s.plus24.IPodSelector , org.cdk8s.plus24.INetworkPolicyPeer , org.cdk8s.plus24.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-24/java/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-24/java/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-24/java/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-24/java/#clusterrole","text":"Implements: org.cdk8s.plus24.IClusterRole , org.cdk8s.plus24.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-24/java/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-24/java/#configmap","text":"Implements: org.cdk8s.plus24.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-24/java/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-24/java/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-24/java/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-24/java/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-24/java/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-24/java/#group","text":"Implements: org.cdk8s.plus24.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-24/java/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-24/java/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-24/java/#namespace","text":"Implements: org.cdk8s.plus24.INamespaceSelector , org.cdk8s.plus24.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-24/java/#namespaces","text":"Implements: org.cdk8s.plus24.INamespaceSelector , org.cdk8s.plus24.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-24/java/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-24/java/#networkpolicyipblock","text":"Implements: org.cdk8s.plus24.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-24/java/#persistentvolume","text":"Implements: org.cdk8s.plus24.IPersistentVolume , org.cdk8s.plus24.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumeclaim","text":"Implements: org.cdk8s.plus24.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-24/java/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-24/java/#pods","text":"Implements: org.cdk8s.plus24.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-24/java/#resource","text":"Implements: org.cdk8s.plus24.IResource , org.cdk8s.plus24.IApiResource , org.cdk8s.plus24.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-24/java/#role","text":"Implements: org.cdk8s.plus24.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-24/java/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-24/java/#secret","text":"Implements: org.cdk8s.plus24.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-24/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-24/java/#serviceaccount","text":"Implements: org.cdk8s.plus24.IServiceAccount , org.cdk8s.plus24.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-24/java/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-24/java/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-24/java/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-24/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-24/java/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-24/java/#user","text":"Implements: org.cdk8s.plus24.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-24/java/#volume","text":"Implements: org.cdk8s.plus24.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-24/java/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-24/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-24/java/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-24/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-24/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-24/java/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-24/java/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/java/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/java/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-24/java/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-24/java/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-24/java/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-24/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-24/java/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-24/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-24/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-24/java/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-24/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-24/java/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-24/java/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-24/java/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-24/java/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-24/java/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-24/java/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-24/java/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-24/java/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-24/java/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-24/java/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-24/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-24/java/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-24/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-24/java/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-24/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-24/java/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-24/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-24/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-24/java/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/java/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-24/java/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-24/java/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-24/java/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-24/java/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-24/java/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-24/java/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-24/java/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-24/java/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-24/java/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-24/java/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-24/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-24/java/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-24/java/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-24/java/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-24/java/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-24/java/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-24/java/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-24/java/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-24/java/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-24/java/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-24/java/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-24/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/java/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-24/java/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-24/java/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-24/java/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-24/java/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-24/java/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-24/java/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-24/java/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-24/java/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-24/java/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-24/java/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-24/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-24/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-24/java/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-24/java/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-24/java/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-24/java/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-24/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-24/java/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-24/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-24/java/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-24/java/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-24/java/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-24/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-24/java/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-24/java/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-24/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-24/java/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-24/java/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-24/java/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-24/java/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-24/java/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-24/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-24/java/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-24/java/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-24/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-24/java/#apiresource","text":"Implements: org.cdk8s.plus24.IApiResource , org.cdk8s.plus24.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-24/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-24/java/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-24/java/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-24/java/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-24/java/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-24/java/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-24/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-24/java/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-24/java/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-24/java/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-24/java/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-24/java/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-24/java/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-24/java/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-24/java/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-24/java/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-24/java/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-24/java/#nonapiresource","text":"Implements: org.cdk8s.plus24.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-24/java/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-24/java/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-24/java/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-24/java/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-24/java/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-24/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-24/java/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-24/java/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-24/java/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-24/java/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-24/java/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-24/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-24/java/#iapiendpoint","text":"Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.ApiResource , org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.ClusterRoleBinding , org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.Ingress , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.NetworkPolicy , org.cdk8s.plus24.NonApiResource , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Resource , org.cdk8s.plus24.Role , org.cdk8s.plus24.RoleBinding , org.cdk8s.plus24.Secret , org.cdk8s.plus24.Service , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-24/java/#iapiresource","text":"Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.ApiResource , org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.ClusterRoleBinding , org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.Ingress , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.NetworkPolicy , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Resource , org.cdk8s.plus24.Role , org.cdk8s.plus24.RoleBinding , org.cdk8s.plus24.Secret , org.cdk8s.plus24.Service , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-24/java/#iclusterrole","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-24/java/#iconfigmap","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-24/java/#inamespaceselector","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.Namespace , org.cdk8s.plus24.Namespaces , org.cdk8s.plus24.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-24/java/#inetworkpolicypeer","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.Namespaces , org.cdk8s.plus24.NetworkPolicyIpBlock , org.cdk8s.plus24.Pod , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.Workload , org.cdk8s.plus24.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-24/java/#ipersistentvolume","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-24/java/#ipersistentvolumeclaim","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-24/java/#ipodselector","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.Job , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Pods , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-24/java/#iresource","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.ClusterRoleBinding , org.cdk8s.plus24.ConfigMap , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.Ingress , org.cdk8s.plus24.Job , org.cdk8s.plus24.Namespace , org.cdk8s.plus24.NetworkPolicy , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.PersistentVolumeClaim , org.cdk8s.plus24.Pod , org.cdk8s.plus24.Resource , org.cdk8s.plus24.Role , org.cdk8s.plus24.RoleBinding , org.cdk8s.plus24.Secret , org.cdk8s.plus24.Service , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.Workload , org.cdk8s.plus24.IClusterRole , org.cdk8s.plus24.IConfigMap , org.cdk8s.plus24.IPersistentVolume , org.cdk8s.plus24.IPersistentVolumeClaim , org.cdk8s.plus24.IResource , org.cdk8s.plus24.IRole , org.cdk8s.plus24.ISecret , org.cdk8s.plus24.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-24/java/#irole","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ClusterRole , org.cdk8s.plus24.Role , org.cdk8s.plus24.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-24/java/#isecret","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.BasicAuthSecret , org.cdk8s.plus24.DockerConfigSecret , org.cdk8s.plus24.Secret , org.cdk8s.plus24.ServiceAccountTokenSecret , org.cdk8s.plus24.SshAuthSecret , org.cdk8s.plus24.TlsSecret , org.cdk8s.plus24.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-24/java/#iserviceaccount","text":"Extends: org.cdk8s.plus24.IResource Implemented By: org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-24/java/#istorage","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus24.AzureDiskPersistentVolume , org.cdk8s.plus24.GCEPersistentDiskPersistentVolume , org.cdk8s.plus24.PersistentVolume , org.cdk8s.plus24.Volume , org.cdk8s.plus24.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-24/java/#isubject","text":"Extends: software.constructs.IConstruct Implemented By: org.cdk8s.plus24.AbstractPod , org.cdk8s.plus24.CronJob , org.cdk8s.plus24.DaemonSet , org.cdk8s.plus24.Deployment , org.cdk8s.plus24.Group , org.cdk8s.plus24.Job , org.cdk8s.plus24.Pod , org.cdk8s.plus24.ServiceAccount , org.cdk8s.plus24.StatefulSet , org.cdk8s.plus24.User , org.cdk8s.plus24.Workload , org.cdk8s.plus24.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-24/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-24/java/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-24/java/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-24/java/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-24/java/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-24/java/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-24/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-24/java/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-24/java/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-24/java/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-24/java/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-24/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-24/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-24/java/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-24/java/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-24/java/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-24/java/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-24/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-24/java/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-24/java/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-24/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-24/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-24/java/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-24/python/","text":"cdk8s-plus-24 (Python) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: cdk8s_plus_24.IPodSelector , cdk8s_plus_24.INetworkPolicyPeer , cdk8s_plus_24.ISubject Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AbstractPod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_24.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_24.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_24.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_host_alias \u00b6 def add_host_alias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 Type: str IP address of the host file entry. add_init_container \u00b6 def add_init_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_24.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_24.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_24.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( vol : Volume ) vol Required \u00b6 Type: cdk8s_plus_24.Volume to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () to_pod_selector_config \u00b6 def to_pod_selector_config () to_subject_configuration \u00b6 def to_subject_configuration () Properties \u00b6 automount_service_account_token Required \u00b6 automount_service_account_token : bool Type: bool containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_24.Container ] dns Required \u00b6 dns : PodDns Type: cdk8s_plus_24.PodDns host_aliases Required \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] init_containers Required \u00b6 init_containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_24.Container ] pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition security_context Required \u00b6 security_context : PodSecurityContext Type: cdk8s_plus_24.PodSecurityContext volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AwsElasticBlockStorePersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. volume_id Required \u00b6 volume_id : str Type: str Volume id of this volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AzureDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 Type: cdk8s_plus_24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azure_kind Required \u00b6 azure_kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_24.AzureDiskPersistentVolumeKind Azure kind of this volume. caching_mode Required \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_24.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. disk_name Required \u00b6 disk_name : str Type: str Disk name of this volume. disk_uri Required \u00b6 disk_uri : str Type: str Disk URI of this volume. fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . BasicAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: str The password or token for authentication. username Required \u00b6 Type: str The user name for authentication. ClusterRole \u00b6 Implements: cdk8s_plus_24.IClusterRole , cdk8s_plus_24.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ClusterRole ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 def aggregate ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str allow \u00b6 def allow ( verbs : typing . List [ str ], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: typing.List[ str ] endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The endpoints(s) to apply to. allow_create \u00b6 def allow_create ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_get \u00b6 def allow_get ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_list \u00b6 def allow_list ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_read \u00b6 def allow_read ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_update \u00b6 def allow_update ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_24.IApiEndpoint The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_24.ISubject a list of subjects to bind to. bind_in_namespace \u00b6 def bind_in_namespace ( namespace : str , subjects : ISubject ) namespace Required \u00b6 Type: str the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s_plus_24.ISubject a list of subjects to bind to. combine \u00b6 def combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s_plus_24.ClusterRole Static Functions \u00b6 from_cluster_role_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ClusterRole . from_cluster_role_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_24.ClusterRolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ClusterRoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IClusterRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_24.IClusterRole The role to bind to. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_24.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_24.IClusterRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_24.ISubject ] ConfigMap \u00b6 Implements: cdk8s_plus_24.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ConfigMap . from_config_map_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 immutable : bool Type: bool Whether or not this config map is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . CronJob ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None , schedule : Cron , concurrency_policy : ConcurrencyPolicy = None , failed_jobs_retained : typing . Union [ int , float ] = None , starting_deadline : Duration = None , successful_jobs_retained : typing . Union [ int , float ] = None , suspend : bool = None , time_zone : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrency_policy Optional \u00b6 Type: cdk8s_plus_24.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failed_jobs_retained Optional \u00b6 Type: typing.Union[int, float] Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. starting_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successful_jobs_retained Optional \u00b6 Type: typing.Union[int, float] Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 Type: bool Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. time_zone Optional \u00b6 Type: str Default: Timezone of kube-controller-manager process. Specifies the timezone for the job. This helps aligining the schedule to follow the specified timezone. {@link https://en.wikipedia.org/wiki/List_of_tz_database_time_zones} for list of valid timezone values. Properties \u00b6 concurrency_policy Required \u00b6 concurrency_policy : str Type: str The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failed_jobs_retained Required \u00b6 failed_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] The number of failed jobs retained by this cron job. resource_type Required \u00b6 resource_type : str Type: str Represents the resource type. schedule Required \u00b6 schedule : Cron Type: cdk8s.Cron The schedule this cron job is scheduled to run in. starting_deadline Required \u00b6 starting_deadline : Duration Type: cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successful_jobs_retained Required \u00b6 successful_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] The number of successful jobs retained by this cron job. suspend Required \u00b6 suspend : bool Type: bool Whether or not the cron job is currently suspended or not. time_zone Optional \u00b6 time_zone : str Type: str The timezone which this cron job would follow to schedule jobs. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DaemonSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready_seconds Optional \u00b6 Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 min_ready_seconds Required \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: typing.Union[int, float] Default: 2 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_24.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 Type: cdk8s_plus_24.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 Type: cdk8s_plus_24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. expose_via_service \u00b6 def expose_via_service ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None ) name Optional \u00b6 Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 Type: cdk8s_plus_24.ServiceType Default: ClusterIP. The type of the exposed service. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progress_deadline Required \u00b6 progress_deadline : Duration Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_24.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DockerConfigSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . GCEPersistentDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. pd_name Required \u00b6 pd_name : str Type: str PD resource in GCE of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. Group \u00b6 Implements: cdk8s_plus_24.ISubject Represents a group. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Group . from_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 kind Required \u00b6 kind : str Type: str name Required \u00b6 name : str Type: str api_group Optional \u00b6 api_group : str Type: str Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Ingress ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_24.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_24.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_24.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s_plus_24.IngressBackend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressBackend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_24.IngressBackend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_24.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_24.HttpIngressPathType How the path is matched against request paths. add_rule \u00b6 def add_rule ( path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_24.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_24.HttpIngressPathType How the path is matched against request paths. add_rules \u00b6 def add_rules ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 Type: cdk8s_plus_24.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 Type: cdk8s_plus_24.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types add_tls \u00b6 def add_tls ( tls : typing . List [ IngressTls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_24.IngressTls ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: cdk8s_plus_24.INamespaceSelector , cdk8s_plus_24.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Namespace ( scope : Construct , id : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: str https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: cdk8s_plus_24.INamespaceSelector , cdk8s_plus_24.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Namespaces ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , names : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_24.LabelExpression ] names Optional \u00b6 Type: typing.List[ str ] labels Optional \u00b6 Type: typing.Mapping[ str ] Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Static Functions \u00b6 all \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Namespaces . all ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str select \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Namespaces . select ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , names : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_24.LabelExpression ] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 Type: typing.List[ str ] Default: no name requirements. Namespaces names must be one of these. NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicy ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , egress : NetworkPolicyTraffic = None , ingress : NetworkPolicyTraffic = None , selector : IPodSelector = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 Type: cdk8s_plus_24.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 Type: cdk8s_plus_24.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 Type: cdk8s_plus_24.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that Methods \u00b6 add_egress_rule \u00b6 def add_egress_rule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_24.INetworkPolicyPeer ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] add_ingress_rule \u00b6 def add_ingress_rule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_24.INetworkPolicyPeer ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: cdk8s_plus_24.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Static Functions \u00b6 any_ipv4 \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyIpBlock . any_ipv4 ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str any_ipv6 \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyIpBlock . any_ipv6 ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str ipv4 \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyIpBlock . ipv4 ( scope : Construct , id : str , cidr_ip : str , except : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str cidr_ip Required \u00b6 Type: str except Optional \u00b6 Type: typing.List[ str ] ipv6 \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyIpBlock . ipv6 ( scope : Construct , id : str , cidr_ip : str , except : typing . List [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str cidr_ip Required \u00b6 Type: str except Optional \u00b6 Type: typing.List[ str ] Properties \u00b6 cidr Required \u00b6 cidr : str Type: str A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 except : typing . List [ str ] Type: typing.List[ str ] A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: cdk8s_plus_24.IPersistentVolume , cdk8s_plus_24.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 as_volume \u00b6 def as_volume () bind \u00b6 def bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s_plus_24.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 def reserve () Static Functions \u00b6 from_persistent_volume_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolume . from_persistent_volume_name ( scope : Construct , id : str , volume_name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str volume_name Required \u00b6 Type: str Properties \u00b6 mode Required \u00b6 mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Volume mode of this volume. reclaim_policy Required \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Access modes requirement of this claim. claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_24.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Mount options of this volume. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage size of this volume. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s_plus_24.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolumeClaim ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: cdk8s_plus_24.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 def bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s_plus_24.IPersistentVolume The PV to bind to. Static Functions \u00b6 from_claim_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolumeClaim . from_claim_name ( scope : Construct , id : str , claim_name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str claim_name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. volume_mode Required \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Volume mode requirement of this claim. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Access modes requirement of this claim. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage requirement of this claim. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class requirment of this claim. volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_24.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 connections Required \u00b6 connections : PodConnections Type: cdk8s_plus_24.PodConnections pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 scheduling : PodScheduling Type: cdk8s_plus_24.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: str This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: cdk8s_plus_24.IPodSelector Represents a group of pods. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Pods ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : INamespaceSelector = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_24.LabelExpression ] labels Optional \u00b6 Type: typing.Mapping[ str ] namespaces Optional \u00b6 Type: cdk8s_plus_24.INamespaceSelector Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () to_pod_selector_config \u00b6 def to_pod_selector_config () Static Functions \u00b6 all \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Pods . all ( scope : Construct , id : str , namespaces : Namespaces = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str namespaces Optional \u00b6 Type: cdk8s_plus_24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. select \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Pods . select ( scope : Construct , id : str , expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : Namespaces = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_24.LabelExpression ] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 Type: cdk8s_plus_24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. Resource \u00b6 Implements: cdk8s_plus_24.IResource , cdk8s_plus_24.IApiResource , cdk8s_plus_24.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Resource ( scope : Construct , id : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. permissions Required \u00b6 permissions : ResourcePermissions Type: cdk8s_plus_24.ResourcePermissions resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s_plus_24.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Role ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_24.RolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 def allow ( verbs : typing . List [ str ], resources : IApiResource ) verbs Required \u00b6 Type: typing.List[ str ] resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_create \u00b6 def allow_create ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_get \u00b6 def allow_get ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_list \u00b6 def allow_list ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_read \u00b6 def allow_read ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_update \u00b6 def allow_update ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_24.IApiResource The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_24.ISubject a list of subjects to bind to. Static Functions \u00b6 from_role_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Role . from_role_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_24.RolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . RoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_24.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_24.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IRole Type: cdk8s_plus_24.IRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_24.ISubject ] Secret \u00b6 Implements: cdk8s_plus_24.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Secret . from_secret_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 immutable Required \u00b6 immutable : bool Type: bool Whether or not the secret is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , selector : IPodSelector = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ServicePort ] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 Type: cdk8s_plus_24.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 Type: cdk8s_plus_24.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 bind \u00b6 def bind ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. select \u00b6 def select ( selector : IPodSelector ) selector Required \u00b6 Type: cdk8s_plus_24.IPodSelector select_label \u00b6 def select_label ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_24.ServicePort ] Ports for this service. Use bind() to bind additional service ports. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 type : ServiceType Type: cdk8s_plus_24.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_24.IServiceAccount , cdk8s_plus_24.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 Type: bool Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_24.ISecret The secret. to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceAccount . from_service_account_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 automount_token Required \u00b6 automount_token : bool Type: bool Whether or not a token is automatically mounted for this service account. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_24.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceAccountTokenSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 Type: cdk8s_plus_24.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . SshAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 Type: str The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 Type: cdk8s_plus_24.Service Service to associate with the statefulset. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 Type: cdk8s_plus_24.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_24.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_24.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_24.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . TlsSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 Type: str The TLS cert. tls_key Required \u00b6 Type: str The TLS key. User \u00b6 Implements: cdk8s_plus_24.ISubject Represents a user. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Static Functions \u00b6 from_name \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . User . from_name ( scope : Construct , id : str , name : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str Properties \u00b6 kind Required \u00b6 kind : str Type: str name Required \u00b6 name : str Type: str api_group Optional \u00b6 api_group : str Type: str Volume \u00b6 Implements: cdk8s_plus_24.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 as_volume \u00b6 def as_volume () Static Functions \u00b6 from_aws_elastic_block_store \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_aws_elastic_block_store ( scope : Construct , id : str , volume_id : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str volume_id Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_azure_disk \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_azure_disk ( scope : Construct , id : str , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str disk_name Required \u00b6 Type: str disk_uri Required \u00b6 Type: str caching_mode Optional \u00b6 Type: cdk8s_plus_24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 Type: str Default: auto-generated The volume name. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. from_config_map \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_config_map ( scope : Construct , id : str , config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str config_map Required \u00b6 Type: cdk8s_plus_24.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_24.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_empty_dir ( scope : Construct , id : str , name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_24.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. from_gce_persistent_disk \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_gce_persistent_disk ( scope : Construct , id : str , pd_name : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str pd_name Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_host_path \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_host_path ( scope : Construct , id : str , name : str , path : str , type : HostPathVolumeType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str name Required \u00b6 Type: str path Required \u00b6 Type: str The path of the directory on the host. type Optional \u00b6 Type: cdk8s_plus_24.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. from_persistent_volume_claim \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_persistent_volume_claim ( scope : Construct , id : str , claim : IPersistentVolumeClaim , name : str = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str claim Required \u00b6 Type: cdk8s_plus_24.IPersistentVolumeClaim name Optional \u00b6 Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. from_secret \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Volume . from_secret ( scope : Construct , id : str , secr : ISecret , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str secr Required \u00b6 Type: cdk8s_plus_24.ISecret The secret to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_24.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the secret or its keys must be defined. Properties \u00b6 name Required \u00b6 name : str Type: str Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Workload ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints Methods \u00b6 select \u00b6 def select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s_plus_24.LabelSelector Properties \u00b6 connections Required \u00b6 connections : PodConnections Type: cdk8s_plus_24.PodConnections match_expressions Required \u00b6 match_expressions : typing . List [ LabelSelectorRequirement ] Type: typing.List[ cdk8s_plus_24.LabelSelectorRequirement ] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. match_labels Required \u00b6 match_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 scheduling : WorkloadScheduling Type: cdk8s_plus_24.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AbstractPodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ApiResourceOptions ( api_group : str , resource_type : str ) api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AwsElasticBlockStorePersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 volume_id : str Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AwsElasticBlockStoreVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AzureDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 disk_name : str Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 disk_uri : str Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . AzureDiskVolumeOptions ( caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . BasicAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 password : str Type: str The password or token for authentication. username Required \u00b6 username : str Type: str The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ClusterRoleBindingProps ( metadata : ApiObjectMetadata = None , role : IClusterRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_24.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ClusterRolePolicyRule ( endpoints : typing . List [ IApiEndpoint ], verbs : typing . List [ str ] ) endpoints Required \u00b6 endpoints : typing . List [ IApiEndpoint ] Type: typing.List[ cdk8s_plus_24.IApiEndpoint ] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ClusterRoleProps ( metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 aggregation_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_24.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . CommonSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_24.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ContainerLifecycle ( post_start : Handler = None , pre_stop : Handler = None ) post_start Optional \u00b6 post_start : Handler Type: cdk8s_plus_24.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. pre_stop Optional \u00b6 pre_stop : Handler Type: cdk8s_plus_24.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ContainerPort ( number : typing . Union [ int , float ], host_ip : str = None , host_port : typing . Union [ int , float ] = None , name : str = None , protocol : Protocol = None ) number Required \u00b6 number : typing . Union [ int , float ] Type: typing.Union[int, float] Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. host_ip Optional \u00b6 host_ip : str Type: str Default: 127.0.0.1. What host IP to bind the external port to. host_port Optional \u00b6 host_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 name : str Type: str Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_24.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 env_from : typing . List [ EnvFrom ] Type: typing.List[ cdk8s_plus_24.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 env_variables : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_24.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 lifecycle : ContainerLifecycle Type: cdk8s_plus_24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . port : typing . Union [ int , float ] Type: typing.Union[int, float] port_number Optional \u00b6 port_number : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 ports : typing . List [ ContainerPort ] Type: typing.List[ cdk8s_plus_24.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 security_context : ContainerSecurityContextProps Type: cdk8s_plus_24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 startup : Probe Type: cdk8s_plus_24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_24.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ContainerResources ( cpu : CpuResources = None , ephemeral_storage : EphemeralStorageResources = None , memory : MemoryResources = None ) cpu Optional \u00b6 cpu : CpuResources Type: cdk8s_plus_24.CpuResources ephemeral_storage Optional \u00b6 ephemeral_storage : EphemeralStorageResources Type: cdk8s_plus_24.EphemeralStorageResources memory Optional \u00b6 memory : MemoryResources Type: cdk8s_plus_24.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ContainerSecurityContextProps ( allow_privilege_escalation : bool = None , ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) allow_privilege_escalation Optional \u00b6 allow_privilege_escalation : bool Type: bool Default: false Whether a process can gain more privileges than its parent process. ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 privileged : bool Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 read_only_root_filesystem : bool Type: bool Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . CpuResources ( limit : Cpu = None , request : Cpu = None ) limit Optional \u00b6 limit : Cpu Type: cdk8s_plus_24.Cpu request Optional \u00b6 request : Cpu Type: cdk8s_plus_24.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . CronJobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None , schedule : Cron , concurrency_policy : ConcurrencyPolicy = None , failed_jobs_retained : typing . Union [ int , float ] = None , starting_deadline : Duration = None , successful_jobs_retained : typing . Union [ int , float ] = None , suspend : bool = None , time_zone : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 schedule : Cron Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrency_policy Optional \u00b6 concurrency_policy : ConcurrencyPolicy Type: cdk8s_plus_24.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failed_jobs_retained Optional \u00b6 failed_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. starting_deadline Optional \u00b6 starting_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successful_jobs_retained Optional \u00b6 successful_jobs_retained : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 suspend : bool Type: bool Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. time_zone Optional \u00b6 time_zone : str Type: str Default: Timezone of kube-controller-manager process. Specifies the timezone for the job. This helps aligining the schedule to follow the specified timezone. {@link https://en.wikipedia.org/wiki/List_of_tz_database_time_zones} for list of valid timezone values. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DaemonSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready_seconds Optional \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DeploymentExposeViaServiceOptions ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None ) name Optional \u00b6 name : str Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_24.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_24.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DeploymentProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 progress_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 2 Number of desired pods. strategy Optional \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_24.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DeploymentStrategyRollingUpdateOptions ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 max_surge : PercentOrAbsolute Type: cdk8s_plus_24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 max_unavailable : PercentOrAbsolute Type: cdk8s_plus_24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DnsOption ( name : str , value : str = None ) name Required \u00b6 name : str Type: str Option name. value Optional \u00b6 value : str Type: str Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DockerConfigSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 data : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_24.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValueFromFieldRefOptions ( api_version : str = None , key : str = None ) api_version Optional \u00b6 api_version : str Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 key : str Type: str The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValueFromResourceOptions ( container : Container = None , divisor : str = None ) container Optional \u00b6 container : Container Type: cdk8s_plus_24.Container The container to select the value from. divisor Optional \u00b6 divisor : str Type: str The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EphemeralStorageResources ( limit : Size = None , request : Size = None ) limit Optional \u00b6 limit : Size Type: cdk8s.Size request Optional \u00b6 request : Size Type: cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ExposeDeploymentViaIngressOptions ( name : str = None , ports : typing . List [ ServicePort ] = None , service_type : ServiceType = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) name Optional \u00b6 name : str Type: str Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_24.ServicePort ] Default: extracted from the deployment. The ports that the service should bind to. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_24.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ExposeServiceViaIngressOptions ( ingress : Ingress = None , path_type : HttpIngressPathType = None ) ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . GCEPersistentDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 pd_name : str Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . GCEPersistentDiskVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . HandlerFromHttpGetOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . HandlerFromTcpSocketOptions ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . HostAlias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 hostnames : typing . List [ str ] Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 ip : str Type: str IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . HostPathVolumeOptions ( path : str , type : HostPathVolumeType = None ) path Required \u00b6 path : str Type: str The path of the directory on the host. type Optional \u00b6 type : HostPathVolumeType Type: cdk8s_plus_24.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None , scheme : ConnectionScheme = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 scheme : ConnectionScheme Type: cdk8s_plus_24.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . IngressProps ( metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressBackend Type: cdk8s_plus_24.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressRule ] Type: typing.List[ cdk8s_plus_24.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressTls ] Type: typing.List[ cdk8s_plus_24.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . IngressRule ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 backend : IngressBackend Type: cdk8s_plus_24.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_24.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . IngressTls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_24.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . JobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelSelectorOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_24.LabelExpression ] Expression based label matchers. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelSelectorRequirement ( key : str , operator : str , values : typing . List [ str ] = None ) key Required \u00b6 key : str Type: str The label key that the selector applies to. operator Required \u00b6 operator : str Type: str Represents a key\u2019s relationship to a set of values. values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . MemoryResources ( limit : Size = None , request : Size = None ) limit Optional \u00b6 limit : Size Type: cdk8s.Size request Optional \u00b6 request : Size Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NamespaceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NamespaceSelectorConfig ( label_selector : LabelSelector = None , names : typing . List [ str ] = None ) label_selector Optional \u00b6 label_selector : LabelSelector Type: cdk8s_plus_24.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 names : typing . List [ str ] Type: typing.List[ str ] A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NamespacesSelectOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , names : typing . List [ str ] = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_24.LabelExpression ] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 names : typing . List [ str ] Type: typing.List[ str ] Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyAddEgressRuleOptions ( ports : typing . List [ NetworkPolicyPort ] = None ) ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPeerConfig ( ip_block : NetworkPolicyIpBlock = None , pod_selector : PodSelectorConfig = None ) ip_block Optional \u00b6 ip_block : NetworkPolicyIpBlock Type: cdk8s_plus_24.NetworkPolicyIpBlock The ip block this peer represents. pod_selector Optional \u00b6 pod_selector : PodSelectorConfig Type: cdk8s_plus_24.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPortProps ( end_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None , protocol : NetworkProtocol = None ) end_port Optional \u00b6 end_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: all ports are allowed. Specific port number. protocol Optional \u00b6 protocol : NetworkProtocol Type: cdk8s_plus_24.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyProps ( metadata : ApiObjectMetadata = None , egress : NetworkPolicyTraffic = None , ingress : NetworkPolicyTraffic = None , selector : IPodSelector = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 egress : NetworkPolicyTraffic Type: cdk8s_plus_24.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 ingress : NetworkPolicyTraffic Type: cdk8s_plus_24.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 selector : IPodSelector Type: cdk8s_plus_24.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyRule ( peer : INetworkPolicyPeer , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 peer : INetworkPolicyPeer Type: cdk8s_plus_24.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyTraffic ( default : NetworkPolicyTrafficDefault = None , rules : typing . List [ NetworkPolicyRule ] = None ) default Optional \u00b6 default : NetworkPolicyTrafficDefault Type: cdk8s_plus_24.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 rules : typing . List [ NetworkPolicyRule ] Type: typing.List[ cdk8s_plus_24.NetworkPolicyRule ] Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeTaintQueryOptions ( effect : TaintEffect = None , evict_after : Duration = None ) effect Optional \u00b6 effect : TaintEffect Type: cdk8s_plus_24.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 evict_after : Duration Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolumeClaimProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_24.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolumeClaimVolumeOptions ( name : str = None , read_only : bool = None ) name Optional \u00b6 name : str Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_24.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodConnectionsAllowFromOptions ( isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) isolation Optional \u00b6 isolation : PodConnectionsIsolation Type: cdk8s_plus_24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodConnectionsAllowToOptions ( isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) isolation Optional \u00b6 isolation : PodConnectionsIsolation Type: cdk8s_plus_24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 ports : typing . List [ NetworkPolicyPort ] Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodDnsProps ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 hostname : str Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 hostname_as_fqd_n : bool Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_24.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 policy : DnsPolicy Type: cdk8s_plus_24.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 subdomain : str Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodsAllOptions ( namespaces : Namespaces = None ) namespaces Optional \u00b6 namespaces : Namespaces Type: cdk8s_plus_24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodSchedulingAttractOptions ( weight : typing . Union [ int , float ] = None ) weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodSchedulingColocateOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_24.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodSchedulingSeparateOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_24.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodSecurityContextProps ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_24.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_24.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodSelectorConfig ( label_selector : LabelSelector , namespaces : NamespaceSelectorConfig = None ) label_selector Required \u00b6 label_selector : LabelSelector Type: cdk8s_plus_24.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 namespaces : NamespaceSelectorConfig Type: cdk8s_plus_24.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodsSelectOptions ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None , namespaces : Namespaces = None ) expressions Optional \u00b6 expressions : typing . List [ LabelExpression ] Type: typing.List[ cdk8s_plus_24.LabelExpression ] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 namespaces : Namespaces Type: cdk8s_plus_24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . RoleBindingProps ( metadata : ApiObjectMetadata = None , role : IRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IRole Type: cdk8s_plus_24.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . RolePolicyRule ( resources : typing . List [ IApiResource ], verbs : typing . List [ str ] ) resources Required \u00b6 resources : typing . List [ IApiResource ] Type: typing.List[ cdk8s_plus_24.IApiResource ] Resources this rule applies to. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . RoleProps ( metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_24.RolePolicyRule ] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . SecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_24.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . SecretVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_24.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 automount_token : bool Type: bool Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_24.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceAccountTokenSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceBindOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceIngressBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , selector : IPodSelector = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_24.ServicePort ] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 selector : IPodSelector Type: cdk8s_plus_24.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 type : ServiceType Type: cdk8s_plus_24.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . SshAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 ssh_private_key : str Type: str The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . StatefulSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 service : Service Type: cdk8s_plus_24.Service Service to associate with the statefulset. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_24.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_24.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . StatefulSetUpdateStrategyRollingUpdateOptions ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . SubjectConfiguration ( kind : str , name : str , api_group : str = None , namespace : str = None ) kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 namespace : str Type: str Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Sysctl ( name : str , value : str ) name Required \u00b6 name : str Type: str Name of a property to set. value Required \u00b6 value : str Type: str Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . TcpSocketProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . TlsSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 tls_cert : str Type: str The TLS cert. tls_key Required \u00b6 tls_key : str Type: str The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_24.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . WorkloadProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , spread : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_24.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_24.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_24.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 spread : bool Type: bool Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . WorkloadSchedulingSpreadOptions ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 topology : Topology Type: cdk8s_plus_24.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 weight : typing . Union [ int , float ] Type: typing.Union[int, float] Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s_plus_24.IApiResource , cdk8s_plus_24.IApiEndpoint Represents information about an API resource type. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 custom \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ApiResource . custom ( api_group : str , resource_type : str ) api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s_plus_24.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env_from : typing . List [ EnvFrom ] = None , env_variables : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , port_number : typing . Union [ int , float ] = None , ports : typing . List [ ContainerPort ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env_from Optional \u00b6 Type: typing.List[ cdk8s_plus_24.EnvFrom ] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. env_variables Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_24.EnvValue ] Default: No environment variables. Environment variables to set in the container. image_pull_policy Optional \u00b6 Type: cdk8s_plus_24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . Type: typing.Union[int, float] port_number Optional \u00b6 Type: typing.Union[int, float] Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.ContainerPort ] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 Type: cdk8s_plus_24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_24.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_port \u00b6 def add_port ( number : typing . Union [ int , float ], host_ip : str = None , host_port : typing . Union [ int , float ] = None , name : str = None , protocol : Protocol = None ) number Required \u00b6 Type: typing.Union[int, float] Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. host_ip Optional \u00b6 Type: str Default: 127.0.0.1. What host IP to bind the external port to. host_port Optional \u00b6 Type: typing.Union[int, float] Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 Type: str Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 Type: cdk8s_plus_24.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. mount \u00b6 def mount ( path : str , storage : IStorage , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. storage Required \u00b6 Type: cdk8s_plus_24.IStorage The storage to mount. propagation Optional \u00b6 Type: cdk8s_plus_24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. Properties \u00b6 env Required \u00b6 env : Env Type: cdk8s_plus_24.Env The environment of the container. image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_24.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_24.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. ports Required \u00b6 ports : typing . List [ ContainerPort ] Type: typing.List[ cdk8s_plus_24.ContainerPort ] Ports exposed by this containers. Returns a copy, use addPort to modify. security_context Required \u00b6 security_context : ContainerSecurityContext Type: cdk8s_plus_24.ContainerSecurityContext The security context of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . port : typing . Union [ int , float ] Type: typing.Union[int, float] port_number Optional \u00b6 port_number : typing . Union [ int , float ] Type: typing.Union[int, float] The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_24.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ContainerSecurityContext ( allow_privilege_escalation : bool = None , ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) allow_privilege_escalation Optional \u00b6 Type: bool Default: false Whether a process can gain more privileges than its parent process. ensure_non_root Optional \u00b6 Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: typing.Union[int, float] Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 Type: bool Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 Type: typing.Union[int, float] Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool privileged Required \u00b6 privileged : bool Type: bool read_only_root_filesystem Required \u00b6 read_only_root_filesystem : bool Type: bool allow_privilege_escalation Optional \u00b6 allow_privilege_escalation : bool Type: bool group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Cpu . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] units \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Cpu . units ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 amount Required \u00b6 amount : str Type: str DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DeploymentStrategy . recreate () rolling_update \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . DeploymentStrategy . rolling_update ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 Type: cdk8s_plus_24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 Type: cdk8s_plus_24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. Env \u00b6 Container environment variables. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Env ( sources : typing . List [ EnvFrom ], variables : typing . Mapping [ EnvValue ] ) sources Required \u00b6 Type: typing.List[ cdk8s_plus_24.EnvFrom ] variables Required \u00b6 Type: typing.Mapping[ cdk8s_plus_24.EnvValue ] Methods \u00b6 add_variable \u00b6 def add_variable ( name : str , value : EnvValue ) name Required \u00b6 Type: str value Required \u00b6 Type: cdk8s_plus_24.EnvValue copy_from \u00b6 def copy_from ( from : EnvFrom ) from Required \u00b6 Type: cdk8s_plus_24.EnvFrom Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Env . from_config_map ( config_map : IConfigMap , prefix : str = None ) config_map Required \u00b6 Type: cdk8s_plus_24.IConfigMap prefix Optional \u00b6 Type: str from_secret \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Env . from_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_24.ISecret Properties \u00b6 sources Required \u00b6 sources : typing . List [ EnvFrom ] Type: typing.List[ cdk8s_plus_24.EnvFrom ] The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 variables : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_24.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvFrom ( config_map : IConfigMap = None , prefix : str = None , sec : ISecret = None ) config_map Optional \u00b6 Type: cdk8s_plus_24.IConfigMap prefix Optional \u00b6 Type: str sec Optional \u00b6 Type: cdk8s_plus_24.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_24.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_field_ref \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValue . from_field_ref ( field_path : EnvFieldPaths , api_version : str = None , key : str = None ) field_path Required \u00b6 Type: cdk8s_plus_24.EnvFieldPaths : The field reference. api_version Optional \u00b6 Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 Type: str The key to select the pod label or annotation. from_process \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_resource \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValue . from_resource ( resource : ResourceFieldPaths , container : Container = None , divisor : str = None ) resource Required \u00b6 Type: cdk8s_plus_24.ResourceFieldPaths : Resource to select the value from. container Optional \u00b6 Type: cdk8s_plus_24.Container The container to select the value from. divisor Optional \u00b6 Type: str The output format of the exposed resource. from_secret_value \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_24.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Handler . from_command ( command : typing . List [ str ] ) command Required \u00b6 Type: typing.List[ str ] The command to execute. from_http_get \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Handler . from_http_get ( path : str , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Handler . from_tcp_socket ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_resource \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . IngressBackend . from_resource ( resource : IResource ) resource Required \u00b6 Type: cdk8s_plus_24.IResource from_service \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . IngressBackend . from_service ( serv : Service , port : typing . Union [ int , float ] = None ) serv Required \u00b6 Type: cdk8s_plus_24.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabeledNode ( label_selector : typing . List [ NodeLabelQuery ] ) label_selector Required \u00b6 Type: typing.List[ cdk8s_plus_24.NodeLabelQuery ] Properties \u00b6 label_selector Required \u00b6 label_selector : typing . List [ NodeLabelQuery ] Type: typing.List[ cdk8s_plus_24.NodeLabelQuery ] LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelExpression . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelExpression . exists ( key : str ) key Required \u00b6 Type: str in \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelExpression . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] not_in \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelExpression . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 key Required \u00b6 key : str Type: str operator Required \u00b6 operator : str Type: str values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 is_empty \u00b6 def is_empty () Static Functions \u00b6 of \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . LabelSelector . of ( expressions : typing . List [ LabelExpression ] = None , labels : typing . Mapping [ str ] = None ) expressions Optional \u00b6 Type: typing.List[ cdk8s_plus_24.LabelExpression ] Expression based label matchers. labels Optional \u00b6 Type: typing.Mapping[ str ] Strict label matchers. NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NamedNode ( name : str ) name Required \u00b6 Type: str Properties \u00b6 name Required \u00b6 name : str Type: str NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 all_tcp \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . all_tcp () all_udp \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . all_udp () of \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . of ( end_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None , protocol : NetworkProtocol = None ) end_port Optional \u00b6 Type: typing.Union[int, float] Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 Type: typing.Union[int, float] Default: all ports are allowed. Specific port number. protocol Optional \u00b6 Type: cdk8s_plus_24.NetworkProtocol Default: NetworkProtocol.TCP Protocol. tcp \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . tcp ( port : typing . Union [ int , float ] ) port Required \u00b6 Type: typing.Union[int, float] tcp_range \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . tcp_range ( start_port : typing . Union [ int , float ], end_port : typing . Union [ int , float ] ) start_port Required \u00b6 Type: typing.Union[int, float] end_port Required \u00b6 Type: typing.Union[int, float] udp \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . udp ( port : typing . Union [ int , float ] ) port Required \u00b6 Type: typing.Union[int, float] udp_range \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NetworkPolicyPort . udp_range ( start_port : typing . Union [ int , float ], end_port : typing . Union [ int , float ] ) start_port Required \u00b6 Type: typing.Union[int, float] end_port Required \u00b6 Type: typing.Union[int, float] Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Node () Static Functions \u00b6 labeled \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Node . labeled ( label_selector : NodeLabelQuery ) label_selector Required \u00b6 Type: cdk8s_plus_24.NodeLabelQuery named \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Node . named ( node_name : str ) node_name Required \u00b6 Type: str tainted \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Node . tainted ( taint_selector : NodeTaintQuery ) taint_selector Required \u00b6 Type: cdk8s_plus_24.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . exists ( key : str ) key Required \u00b6 Type: str gt \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . gt ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] in \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] is \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . is ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str lt \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . lt ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] not_in \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeLabelQuery . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeTaintQuery . any () exists \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeTaintQuery . exists ( key : str , effect : TaintEffect = None , evict_after : Duration = None ) key Required \u00b6 Type: str effect Optional \u00b6 Type: cdk8s_plus_24.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. is \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NodeTaintQuery . is ( key : str , value : str , effect : TaintEffect = None , evict_after : Duration = None ) key Required \u00b6 Type: str value Required \u00b6 Type: str effect Optional \u00b6 Type: cdk8s_plus_24.TaintEffect Default: all effects are matched. The taint effect to match. evict_after Optional \u00b6 Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. NonApiResource \u00b6 Implements: cdk8s_plus_24.IApiEndpoint Factory for creating non api resources. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 of \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . NonApiResource . of ( url : str ) url Required \u00b6 Type: str PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 is_zero \u00b6 def is_zero () Static Functions \u00b6 absolute \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PercentOrAbsolute . absolute ( num : typing . Union [ int , float ] ) num Required \u00b6 Type: typing.Union[int, float] percent \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PercentOrAbsolute . percent ( percent : typing . Union [ int , float ] ) percent Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 value Required \u00b6 value : typing . Any Type: typing.Any PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodConnections ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_24.AbstractPod Methods \u00b6 allow_from \u00b6 def allow_from ( peer : INetworkPolicyPeer , isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_24.INetworkPolicyPeer isolation Optional \u00b6 Type: cdk8s_plus_24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Default: The pod ports. Ports to allow incoming traffic to. allow_to \u00b6 def allow_to ( peer : INetworkPolicyPeer , isolation : PodConnectionsIsolation = None , ports : typing . List [ NetworkPolicyPort ] = None ) peer Required \u00b6 Type: cdk8s_plus_24.INetworkPolicyPeer isolation Optional \u00b6 Type: cdk8s_plus_24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 Type: typing.List[ cdk8s_plus_24.NetworkPolicyPort ] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodDns ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: typing.List[ cdk8s_plus_24.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: cdk8s_plus_24.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 add_nameserver \u00b6 def add_nameserver ( nameservers : str ) nameservers Required \u00b6 Type: str add_option \u00b6 def add_option ( name : str , value : str = None ) name Required \u00b6 Type: str Option name. value Optional \u00b6 Type: str Default: No value. Option value. add_search \u00b6 def add_search ( searches : str ) searches Required \u00b6 Type: str Properties \u00b6 hostname_as_fqd_n Required \u00b6 hostname_as_fqd_n : bool Type: bool Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] Nameservers defined for this pod. options Required \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_24.DnsOption ] Custom dns options defined for this pod. policy Required \u00b6 policy : DnsPolicy Type: cdk8s_plus_24.DnsPolicy The DNS policy of this pod. searches Required \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] Search domains defined for this pod. hostname Optional \u00b6 hostname : str Type: str The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 subdomain : str Type: str The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_24.AbstractPod Methods \u00b6 assign \u00b6 def assign ( node : NamedNode ) node Required \u00b6 Type: cdk8s_plus_24.NamedNode attract \u00b6 def attract ( node : LabeledNode , weight : typing . Union [ int , float ] = None ) node Required \u00b6 Type: cdk8s_plus_24.LabeledNode weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. colocate \u00b6 def colocate ( selector : IPodSelector , topology : Topology = None , weight : typing . Union [ int , float ] = None ) selector Required \u00b6 Type: cdk8s_plus_24.IPodSelector topology Optional \u00b6 Type: cdk8s_plus_24.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. separate \u00b6 def separate ( selector : IPodSelector , topology : Topology = None , weight : typing . Union [ int , float ] = None ) selector Required \u00b6 Type: cdk8s_plus_24.IPodSelector topology Optional \u00b6 Type: cdk8s_plus_24.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. tolerate \u00b6 def tolerate ( node : TaintedNode ) node Required \u00b6 Type: cdk8s_plus_24.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . PodSecurityContext ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 Type: cdk8s_plus_24.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: typing.List[ cdk8s_plus_24.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool fs_group_change_policy Required \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_24.FsGroupChangePolicy sysctls Required \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_24.Sysctl ] fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None , scheme : ConnectionScheme = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 Type: cdk8s_plus_24.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). from_tcp_socket \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Probe . from_tcp_socket ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . ResourcePermissions ( instance : Resource ) instance Required \u00b6 Type: cdk8s_plus_24.Resource Methods \u00b6 grant_read \u00b6 def grant_read ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_24.ISubject grant_read_write \u00b6 def grant_read_write ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_24.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 on_delete \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . StatefulSetUpdateStrategy . on_delete () rolling_update \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . StatefulSetUpdateStrategy . rolling_update ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . TaintedNode ( taint_selector : typing . List [ NodeTaintQuery ] ) taint_selector Required \u00b6 Type: typing.List[ cdk8s_plus_24.NodeTaintQuery ] Properties \u00b6 taint_selector Required \u00b6 taint_selector : typing . List [ NodeTaintQuery ] Type: typing.List[ cdk8s_plus_24.NodeTaintQuery ] Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . Topology . custom ( key : str ) key Required \u00b6 Type: str Properties \u00b6 key Required \u00b6 key : str Type: str Constants \u00b6 HOSTNAME \u00b6 Type: cdk8s_plus_24.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: cdk8s_plus_24.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: cdk8s_plus_24.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import cdk8s_plus_24 cdk8s_plus_24 . WorkloadScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s_plus_24.AbstractPod Methods \u00b6 spread \u00b6 def spread ( topology : Topology = None , weight : typing . Union [ int , float ] = None ) topology Optional \u00b6 Type: cdk8s_plus_24.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 Type: typing.Union[int, float] Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.ApiResource , cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.ClusterRole , cdk8s_plus_24.ClusterRoleBinding , cdk8s_plus_24.ConfigMap , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.Ingress , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.NetworkPolicy , cdk8s_plus_24.NonApiResource , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.Pod , cdk8s_plus_24.Resource , cdk8s_plus_24.Role , cdk8s_plus_24.RoleBinding , cdk8s_plus_24.Secret , cdk8s_plus_24.Service , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.Workload , cdk8s_plus_24.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () IApiResource \u00b6 Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.ApiResource , cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.ClusterRole , cdk8s_plus_24.ClusterRoleBinding , cdk8s_plus_24.ConfigMap , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.Ingress , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.NetworkPolicy , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.Pod , cdk8s_plus_24.Resource , cdk8s_plus_24.Role , cdk8s_plus_24.RoleBinding , cdk8s_plus_24.Secret , cdk8s_plus_24.Service , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.Workload , cdk8s_plus_24.IApiResource Represents a resource or collection of resources. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ClusterRole , cdk8s_plus_24.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ConfigMap , cdk8s_plus_24.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.Namespace , cdk8s_plus_24.Namespaces , cdk8s_plus_24.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 to_namespace_selector_config \u00b6 def to_namespace_selector_config () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.Namespaces , cdk8s_plus_24.NetworkPolicyIpBlock , cdk8s_plus_24.Pod , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.Workload , cdk8s_plus_24.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 to_network_policy_peer_config \u00b6 def to_network_policy_peer_config () to_pod_selector \u00b6 def to_pod_selector () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. IPersistentVolume \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.Job , cdk8s_plus_24.Pod , cdk8s_plus_24.Pods , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.Workload , cdk8s_plus_24.IPodSelector Represents an object that can select pods. Methods \u00b6 to_pod_selector_config \u00b6 def to_pod_selector_config () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. IResource \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.ClusterRole , cdk8s_plus_24.ClusterRoleBinding , cdk8s_plus_24.ConfigMap , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.Ingress , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.NetworkPolicy , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.Pod , cdk8s_plus_24.Resource , cdk8s_plus_24.Role , cdk8s_plus_24.RoleBinding , cdk8s_plus_24.Secret , cdk8s_plus_24.Service , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.Workload , cdk8s_plus_24.IClusterRole , cdk8s_plus_24.IConfigMap , cdk8s_plus_24.IPersistentVolume , cdk8s_plus_24.IPersistentVolumeClaim , cdk8s_plus_24.IResource , cdk8s_plus_24.IRole , cdk8s_plus_24.ISecret , cdk8s_plus_24.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ClusterRole , cdk8s_plus_24.Role , cdk8s_plus_24.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.Secret , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.ISecret Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.IServiceAccount Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IStorage \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.Volume , cdk8s_plus_24.IStorage Represents a piece of storage in the cluster. Methods \u00b6 as_volume \u00b6 def as_volume () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. ISubject \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.Group , cdk8s_plus_24.Job , cdk8s_plus_24.Pod , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.User , cdk8s_plus_24.Workload , cdk8s_plus_24.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 to_subject_configuration \u00b6 def to_subject_configuration () Properties \u00b6 node Required \u00b6 node : Node Type: constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. Pods that tolerate the taint without specifying duration remain bound forever. Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"Python"},{"location":"reference/cdk8s-plus-24/python/#cdk8s-plus-24-python","text":"","title":"cdk8s-plus-24 (Python) "},{"location":"reference/cdk8s-plus-24/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-24/python/#abstractpod","text":"Implements: cdk8s_plus_24.IPodSelector , cdk8s_plus_24.INetworkPolicyPeer , cdk8s_plus_24.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-24/python/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-24/python/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-24/python/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-24/python/#clusterrole","text":"Implements: cdk8s_plus_24.IClusterRole , cdk8s_plus_24.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-24/python/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-24/python/#configmap","text":"Implements: cdk8s_plus_24.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-24/python/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-24/python/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-24/python/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-24/python/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-24/python/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-24/python/#group","text":"Implements: cdk8s_plus_24.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-24/python/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-24/python/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-24/python/#namespace","text":"Implements: cdk8s_plus_24.INamespaceSelector , cdk8s_plus_24.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-24/python/#namespaces","text":"Implements: cdk8s_plus_24.INamespaceSelector , cdk8s_plus_24.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-24/python/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-24/python/#networkpolicyipblock","text":"Implements: cdk8s_plus_24.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-24/python/#persistentvolume","text":"Implements: cdk8s_plus_24.IPersistentVolume , cdk8s_plus_24.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumeclaim","text":"Implements: cdk8s_plus_24.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-24/python/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-24/python/#pods","text":"Implements: cdk8s_plus_24.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-24/python/#resource","text":"Implements: cdk8s_plus_24.IResource , cdk8s_plus_24.IApiResource , cdk8s_plus_24.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-24/python/#role","text":"Implements: cdk8s_plus_24.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-24/python/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-24/python/#secret","text":"Implements: cdk8s_plus_24.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-24/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-24/python/#serviceaccount","text":"Implements: cdk8s_plus_24.IServiceAccount , cdk8s_plus_24.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-24/python/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-24/python/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-24/python/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-24/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-24/python/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-24/python/#user","text":"Implements: cdk8s_plus_24.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-24/python/#volume","text":"Implements: cdk8s_plus_24.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-24/python/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-24/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-24/python/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-24/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-24/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-24/python/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-24/python/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/python/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/python/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-24/python/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-24/python/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-24/python/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-24/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-24/python/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-24/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-24/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-24/python/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-24/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-24/python/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-24/python/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-24/python/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-24/python/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-24/python/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-24/python/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-24/python/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-24/python/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-24/python/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-24/python/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-24/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-24/python/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-24/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-24/python/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-24/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-24/python/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-24/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-24/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-24/python/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/python/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-24/python/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-24/python/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-24/python/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-24/python/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-24/python/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-24/python/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-24/python/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-24/python/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-24/python/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-24/python/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-24/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-24/python/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-24/python/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-24/python/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-24/python/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-24/python/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-24/python/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-24/python/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-24/python/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-24/python/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-24/python/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-24/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/python/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-24/python/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-24/python/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-24/python/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-24/python/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-24/python/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-24/python/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-24/python/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-24/python/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-24/python/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-24/python/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-24/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-24/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-24/python/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-24/python/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-24/python/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-24/python/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-24/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-24/python/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-24/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-24/python/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-24/python/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-24/python/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-24/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-24/python/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-24/python/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-24/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-24/python/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-24/python/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-24/python/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-24/python/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-24/python/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-24/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-24/python/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-24/python/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-24/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-24/python/#apiresource","text":"Implements: cdk8s_plus_24.IApiResource , cdk8s_plus_24.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-24/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-24/python/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-24/python/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-24/python/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-24/python/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-24/python/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-24/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-24/python/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-24/python/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-24/python/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-24/python/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-24/python/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-24/python/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-24/python/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-24/python/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-24/python/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-24/python/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-24/python/#nonapiresource","text":"Implements: cdk8s_plus_24.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-24/python/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-24/python/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-24/python/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-24/python/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-24/python/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-24/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-24/python/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-24/python/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-24/python/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-24/python/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-24/python/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-24/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-24/python/#iapiendpoint","text":"Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.ApiResource , cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.ClusterRole , cdk8s_plus_24.ClusterRoleBinding , cdk8s_plus_24.ConfigMap , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.Ingress , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.NetworkPolicy , cdk8s_plus_24.NonApiResource , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.Pod , cdk8s_plus_24.Resource , cdk8s_plus_24.Role , cdk8s_plus_24.RoleBinding , cdk8s_plus_24.Secret , cdk8s_plus_24.Service , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.Workload , cdk8s_plus_24.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-24/python/#iapiresource","text":"Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.ApiResource , cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.ClusterRole , cdk8s_plus_24.ClusterRoleBinding , cdk8s_plus_24.ConfigMap , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.Ingress , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.NetworkPolicy , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.Pod , cdk8s_plus_24.Resource , cdk8s_plus_24.Role , cdk8s_plus_24.RoleBinding , cdk8s_plus_24.Secret , cdk8s_plus_24.Service , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.Workload , cdk8s_plus_24.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-24/python/#iclusterrole","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ClusterRole , cdk8s_plus_24.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-24/python/#iconfigmap","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ConfigMap , cdk8s_plus_24.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-24/python/#inamespaceselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.Namespace , cdk8s_plus_24.Namespaces , cdk8s_plus_24.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-24/python/#inetworkpolicypeer","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.Namespaces , cdk8s_plus_24.NetworkPolicyIpBlock , cdk8s_plus_24.Pod , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.Workload , cdk8s_plus_24.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-24/python/#ipersistentvolume","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-24/python/#ipersistentvolumeclaim","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-24/python/#ipodselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.Job , cdk8s_plus_24.Pod , cdk8s_plus_24.Pods , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.Workload , cdk8s_plus_24.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-24/python/#iresource","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.ClusterRole , cdk8s_plus_24.ClusterRoleBinding , cdk8s_plus_24.ConfigMap , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.Ingress , cdk8s_plus_24.Job , cdk8s_plus_24.Namespace , cdk8s_plus_24.NetworkPolicy , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.PersistentVolumeClaim , cdk8s_plus_24.Pod , cdk8s_plus_24.Resource , cdk8s_plus_24.Role , cdk8s_plus_24.RoleBinding , cdk8s_plus_24.Secret , cdk8s_plus_24.Service , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.Workload , cdk8s_plus_24.IClusterRole , cdk8s_plus_24.IConfigMap , cdk8s_plus_24.IPersistentVolume , cdk8s_plus_24.IPersistentVolumeClaim , cdk8s_plus_24.IResource , cdk8s_plus_24.IRole , cdk8s_plus_24.ISecret , cdk8s_plus_24.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-24/python/#irole","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ClusterRole , cdk8s_plus_24.Role , cdk8s_plus_24.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-24/python/#isecret","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.BasicAuthSecret , cdk8s_plus_24.DockerConfigSecret , cdk8s_plus_24.Secret , cdk8s_plus_24.ServiceAccountTokenSecret , cdk8s_plus_24.SshAuthSecret , cdk8s_plus_24.TlsSecret , cdk8s_plus_24.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-24/python/#iserviceaccount","text":"Extends: cdk8s_plus_24.IResource Implemented By: cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-24/python/#istorage","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AwsElasticBlockStorePersistentVolume , cdk8s_plus_24.AzureDiskPersistentVolume , cdk8s_plus_24.GCEPersistentDiskPersistentVolume , cdk8s_plus_24.PersistentVolume , cdk8s_plus_24.Volume , cdk8s_plus_24.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-24/python/#isubject","text":"Extends: constructs.IConstruct Implemented By: cdk8s_plus_24.AbstractPod , cdk8s_plus_24.CronJob , cdk8s_plus_24.DaemonSet , cdk8s_plus_24.Deployment , cdk8s_plus_24.Group , cdk8s_plus_24.Job , cdk8s_plus_24.Pod , cdk8s_plus_24.ServiceAccount , cdk8s_plus_24.StatefulSet , cdk8s_plus_24.User , cdk8s_plus_24.Workload , cdk8s_plus_24.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-24/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-24/python/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-24/python/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-24/python/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-24/python/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-24/python/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-24/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-24/python/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-24/python/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-24/python/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-24/python/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-24/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-24/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-24/python/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-24/python/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-24/python/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-24/python/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-24/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-24/python/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-24/python/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-24/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-24/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-24/python/#tainteffect","text":"Taint effects.","title":"TaintEffect "},{"location":"reference/cdk8s-plus-24/typescript/","text":"cdk8s-plus-24 (TypeScript) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Implements: cdk8s-plus-24.IPodSelector , cdk8s-plus-24.INetworkPolicyPeer , cdk8s-plus-24.ISubject Initializers \u00b6 import { AbstractPod } from 'cdk8s-plus-24' new AbstractPod ( scope : Construct , id : string , props? : AbstractPodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.AbstractPodProps Methods \u00b6 addContainer \u00b6 public addContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-24.ContainerProps addHostAlias \u00b6 public addHostAlias ( hostAlias : HostAlias ) hostAlias Required \u00b6 Type: cdk8s-plus-24.HostAlias addInitContainer \u00b6 public addInitContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-24.ContainerProps addVolume \u00b6 public addVolume ( vol : Volume ) vol Required \u00b6 Type: cdk8s-plus-24.Volume toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 automountServiceAccountToken Required \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-24.Container [] dns Required \u00b6 public readonly dns : PodDns ; Type: cdk8s-plus-24.PodDns hostAliases Required \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] initContainers Required \u00b6 public readonly initContainers : Container []; Type: cdk8s-plus-24.Container [] podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition securityContext Required \u00b6 public readonly securityContext : PodSecurityContext ; Type: cdk8s-plus-24.PodSecurityContext volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import { AwsElasticBlockStorePersistentVolume } from 'cdk8s-plus-24' new AwsElasticBlockStorePersistentVolume ( scope : Construct , id : string , props : AwsElasticBlockStorePersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.AwsElasticBlockStorePersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Volume id of this volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import { AzureDiskPersistentVolume } from 'cdk8s-plus-24' new AzureDiskPersistentVolume ( scope : Construct , id : string , props : AzureDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.AzureDiskPersistentVolumeProps Properties \u00b6 azureKind Required \u00b6 public readonly azureKind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-24.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-24.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public readonly diskName : string ; Type: string Disk name of this volume. diskUri Required \u00b6 public readonly diskUri : string ; Type: string Disk URI of this volume. fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import { BasicAuthSecret } from 'cdk8s-plus-24' new BasicAuthSecret ( scope : Construct , id : string , props : BasicAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.BasicAuthSecretProps ClusterRole \u00b6 Implements: cdk8s-plus-24.IClusterRole , cdk8s-plus-24.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import { ClusterRole } from 'cdk8s-plus-24' new ClusterRole ( scope : Construct , id : string , props? : ClusterRoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.ClusterRoleProps Methods \u00b6 aggregate \u00b6 public aggregate ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string allow \u00b6 public allow ( verbs : string [], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: string [] endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-24.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-24.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( namespace : string , subjects : ISubject ) namespace Required \u00b6 Type: string the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s-plus-24.ISubject a list of subjects to bind to. combine \u00b6 public combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s-plus-24.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import { ClusterRole } from 'cdk8s-plus-24' ClusterRole . fromClusterRoleName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-24.ClusterRolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import { ClusterRoleBinding } from 'cdk8s-plus-24' new ClusterRoleBinding ( scope : Construct , id : string , props : ClusterRoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.ClusterRoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-24.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-24.IClusterRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-24.ISubject [] ConfigMap \u00b6 Implements: cdk8s-plus-24.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-24' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-24.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-24' ConfigMap . fromConfigMapName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not this config map is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. CronJob \u00b6 A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner. Initializers \u00b6 import { CronJob } from 'cdk8s-plus-24' new CronJob ( scope : Construct , id : string , props : CronJobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.CronJobProps Properties \u00b6 concurrencyPolicy Required \u00b6 public readonly concurrencyPolicy : string ; Type: string The policy used by this cron job to determine the concurrency mode in which to schedule jobs. failedJobsRetained Required \u00b6 public readonly failedJobsRetained : number ; Type: number The number of failed jobs retained by this cron job. resourceType Required \u00b6 public readonly resourceType : string ; Type: string Represents the resource type. schedule Required \u00b6 public readonly schedule : Cron ; Type: cdk8s.Cron The schedule this cron job is scheduled to run in. startingDeadline Required \u00b6 public readonly startingDeadline : Duration ; Type: cdk8s.Duration The time by which the running cron job needs to schedule the next job execution. The job is considered as failed if it misses this deadline. successfulJobsRetained Required \u00b6 public readonly successfulJobsRetained : number ; Type: number The number of successful jobs retained by this cron job. suspend Required \u00b6 public readonly suspend : boolean ; Type: boolean Whether or not the cron job is currently suspended or not. timeZone Optional \u00b6 public readonly timeZone : string ; Type: string The timezone which this cron job would follow to schedule jobs. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import { DaemonSet } from 'cdk8s-plus-24' new DaemonSet ( scope : Construct , id : string , props? : DaemonSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.DaemonSetProps Properties \u00b6 minReadySeconds Required \u00b6 public readonly minReadySeconds : number ; Type: number resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-24' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.DeploymentProps Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-24.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : DeploymentExposeViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-24.DeploymentExposeViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-24.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import { DockerConfigSecret } from 'cdk8s-plus-24' new DockerConfigSecret ( scope : Construct , id : string , props : DockerConfigSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.DockerConfigSecretProps GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import { GCEPersistentDiskPersistentVolume } from 'cdk8s-plus-24' new GCEPersistentDiskPersistentVolume ( scope : Construct , id : string , props : GCEPersistentDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.GCEPersistentDiskPersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. pdName Required \u00b6 public readonly pdName : string ; Type: string PD resource in GCE of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. Group \u00b6 Implements: cdk8s-plus-24.ISubject Represents a group. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import { Group } from 'cdk8s-plus-24' Group . fromName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string name Required \u00b6 public readonly name : string ; Type: string apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { Ingress } from 'cdk8s-plus-24' new Ingress ( scope : Construct , id : string , props? : IngressProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.IngressProps Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s-plus-24.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressBackend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-24.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-24.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-24.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-24.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-24.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( rules : IngressRule ) rules Required \u00b6 Type: cdk8s-plus-24.IngressRule The rules to add. addTls \u00b6 public addTls ( tls : IngressTls []) tls Required \u00b6 Type: cdk8s-plus-24.IngressTls [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-24' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.JobProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Namespace \u00b6 Implements: cdk8s-plus-24.INamespaceSelector , cdk8s-plus-24.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc). Initializers \u00b6 import { Namespace } from 'cdk8s-plus-24' new Namespace ( scope : Construct , id : string , props? : NamespaceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.NamespaceProps Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Constants \u00b6 NAME_LABEL \u00b6 Type: string https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling Namespaces \u00b6 Implements: cdk8s-plus-24.INamespaceSelector , cdk8s-plus-24.INetworkPolicyPeer Represents a group of namespaces. Initializers \u00b6 import { Namespaces } from 'cdk8s-plus-24' new Namespaces ( scope : Construct , id : string , expressions? : LabelExpression [], names? : string [], labels ?: {[ key : string ] : string }) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string expressions Optional \u00b6 Type: cdk8s-plus-24.LabelExpression [] names Optional \u00b6 Type: string [] labels Optional \u00b6 Type: {[ key: string ]: string } Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 all \u00b6 import { Namespaces } from 'cdk8s-plus-24' Namespaces . all ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string select \u00b6 import { Namespaces } from 'cdk8s-plus-24' Namespaces . select ( scope : Construct , id : string , options : NamespacesSelectOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-24.NamespacesSelectOptions NetworkPolicy \u00b6 Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource Initializers \u00b6 import { NetworkPolicy } from 'cdk8s-plus-24' new NetworkPolicy ( scope : Construct , id : string , props? : NetworkPolicyProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.NetworkPolicyProps Methods \u00b6 addEgressRule \u00b6 public addEgressRule ( peer : INetworkPolicyPeer , ports? : NetworkPolicyPort []) peer Required \u00b6 Type: cdk8s-plus-24.INetworkPolicyPeer ports Optional \u00b6 Type: cdk8s-plus-24.NetworkPolicyPort [] addIngressRule \u00b6 public addIngressRule ( peer : INetworkPolicyPeer , ports? : NetworkPolicyPort []) peer Required \u00b6 Type: cdk8s-plus-24.INetworkPolicyPeer ports Optional \u00b6 Type: cdk8s-plus-24.NetworkPolicyPort [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. NetworkPolicyIpBlock \u00b6 Implements: cdk8s-plus-24.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Static Functions \u00b6 anyIpv4 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-24' NetworkPolicyIpBlock . anyIpv4 ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string anyIpv6 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-24' NetworkPolicyIpBlock . anyIpv6 ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string ipv4 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-24' NetworkPolicyIpBlock . ipv4 ( scope : Construct , id : string , cidrIp : string , except? : string []) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string cidrIp Required \u00b6 Type: string except Optional \u00b6 Type: string [] ipv6 \u00b6 import { NetworkPolicyIpBlock } from 'cdk8s-plus-24' NetworkPolicyIpBlock . ipv6 ( scope : Construct , id : string , cidrIp : string , except? : string []) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string cidrIp Required \u00b6 Type: string except Optional \u00b6 Type: string [] Properties \u00b6 cidr Required \u00b6 public readonly cidr : string ; Type: string A string representing the IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. except Optional \u00b6 public readonly except : string []; Type: string [] A slice of CIDRs that should not be included within an IP Block Valid examples are \u201c192.168.1.1/24\u201d or \u201c2001:db9::/64\u201d. Except values will be rejected if they are outside the CIDR range. PersistentVolume \u00b6 Implements: cdk8s-plus-24.IPersistentVolume , cdk8s-plus-24.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import { PersistentVolume } from 'cdk8s-plus-24' new PersistentVolume ( scope : Construct , id : string , props? : PersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.PersistentVolumeProps Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s-plus-24.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import { PersistentVolume } from 'cdk8s-plus-24' PersistentVolume . fromPersistentVolumeName ( scope : Construct , id : string , volumeName : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string volumeName Required \u00b6 Type: string Properties \u00b6 mode Required \u00b6 public readonly mode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-24.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Access modes requirement of this claim. claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-24.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Mount options of this volume. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s-plus-24.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-24' new PersistentVolumeClaim ( scope : Construct , id : string , props? : PersistentVolumeClaimProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.PersistentVolumeClaimProps Methods \u00b6 bind \u00b6 public bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s-plus-24.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-24' PersistentVolumeClaim . fromClaimName ( scope : Construct , id : string , claimName : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string claimName Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Access modes requirement of this claim. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class requirment of this claim. volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-24.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-24' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.PodProps Properties \u00b6 connections Required \u00b6 public readonly connections : PodConnections ; Type: cdk8s-plus-24.PodConnections podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. scheduling Required \u00b6 public readonly scheduling : PodScheduling ; Type: cdk8s-plus-24.PodScheduling Constants \u00b6 ADDRESS_LABEL \u00b6 Type: string This label is autoamtically added by cdk8s to any pod. It provides a unique and stable identifier for the pod. Pods \u00b6 Implements: cdk8s-plus-24.IPodSelector Represents a group of pods. Initializers \u00b6 import { Pods } from 'cdk8s-plus-24' new Pods ( scope : Construct , id : string , expressions? : LabelExpression [], labels ?: {[ key : string ] : string }, namespaces? : INamespaceSelector ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string expressions Optional \u00b6 Type: cdk8s-plus-24.LabelExpression [] labels Optional \u00b6 Type: {[ key: string ]: string } namespaces Optional \u00b6 Type: cdk8s-plus-24.INamespaceSelector Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () toPodSelectorConfig \u00b6 public toPodSelectorConfig () Static Functions \u00b6 all \u00b6 import { Pods } from 'cdk8s-plus-24' Pods . all ( scope : Construct , id : string , options? : PodsAllOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.PodsAllOptions select \u00b6 import { Pods } from 'cdk8s-plus-24' Pods . select ( scope : Construct , id : string , options : PodsSelectOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-24.PodsSelectOptions Resource \u00b6 Implements: cdk8s-plus-24.IResource , cdk8s-plus-24.IApiResource , cdk8s-plus-24.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-24' new Resource ( scope : Construct , id : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. permissions Required \u00b6 public readonly permissions : ResourcePermissions ; Type: cdk8s-plus-24.ResourcePermissions resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s-plus-24.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import { Role } from 'cdk8s-plus-24' new Role ( scope : Construct , id : string , props? : RoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.RoleProps Methods \u00b6 allow \u00b6 public allow ( verbs : string [], resources : IApiResource ) verbs Required \u00b6 Type: string [] resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-24.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-24.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import { Role } from 'cdk8s-plus-24' Role . fromRoleName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-24.RolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import { RoleBinding } from 'cdk8s-plus-24' new RoleBinding ( scope : Construct , id : string , props : RoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.RoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-24.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-24.IRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-24.ISubject [] Secret \u00b6 Implements: cdk8s-plus-24.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-24' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-24' Secret . fromSecretName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not the secret is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-24' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.ServiceProps Methods \u00b6 bind \u00b6 public bind ( port : number , options? : ServiceBindOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-24.ServiceBindOptions exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-24.ExposeServiceViaIngressOptions Additional options. select \u00b6 public select ( selector : IPodSelector ) selector Required \u00b6 Type: cdk8s-plus-24.IPodSelector selectLabel \u00b6 public selectLabel ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-24.ServicePort [] Ports for this service. Use bind() to bind additional service ports. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-24.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-24.IServiceAccount , cdk8s-plus-24.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-24' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-24.ISecret The secret. toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-24' ServiceAccount . fromServiceAccountName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public readonly automountToken : boolean ; Type: boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-24.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import { ServiceAccountTokenSecret } from 'cdk8s-plus-24' new ServiceAccountTokenSecret ( scope : Construct , id : string , props : ServiceAccountTokenSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.ServiceAccountTokenSecretProps SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import { SshAuthSecret } from 'cdk8s-plus-24' new SshAuthSecret ( scope : Construct , id : string , props : SshAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.SshAuthSecretProps StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-24' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.StatefulSetProps Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-24.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-24.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import { TlsSecret } from 'cdk8s-plus-24' new TlsSecret ( scope : Construct , id : string , props : TlsSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-24.TlsSecretProps User \u00b6 Implements: cdk8s-plus-24.ISubject Represents a user. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Static Functions \u00b6 fromName \u00b6 import { User } from 'cdk8s-plus-24' User . fromName ( scope : Construct , id : string , name : string ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string name Required \u00b6 public readonly name : string ; Type: string apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string Volume \u00b6 Implements: cdk8s-plus-24.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromAwsElasticBlockStore ( scope : Construct , id : string , volumeId : string , options? : AwsElasticBlockStoreVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string volumeId Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromAzureDisk ( scope : Construct , id : string , diskName : string , diskUri : string , options? : AzureDiskVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string diskName Required \u00b6 Type: string diskUri Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.AzureDiskVolumeOptions fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromConfigMap ( scope : Construct , id : string , configMap : IConfigMap , options? : ConfigMapVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string configMap Required \u00b6 Type: cdk8s-plus-24.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-24.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromEmptyDir ( scope : Construct , id : string , name : string , options? : EmptyDirVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromGcePersistentDisk ( scope : Construct , id : string , pdName : string , options? : GCEPersistentDiskVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string pdName Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.GCEPersistentDiskVolumeOptions fromHostPath \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromHostPath ( scope : Construct , id : string , name : string , options : HostPathVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string name Required \u00b6 Type: string options Required \u00b6 Type: cdk8s-plus-24.HostPathVolumeOptions fromPersistentVolumeClaim \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromPersistentVolumeClaim ( scope : Construct , id : string , claim : IPersistentVolumeClaim , options? : PersistentVolumeClaimVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string claim Required \u00b6 Type: cdk8s-plus-24.IPersistentVolumeClaim options Optional \u00b6 Type: cdk8s-plus-24.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import { Volume } from 'cdk8s-plus-24' Volume . fromSecret ( scope : Construct , id : string , secr : ISecret , options? : SecretVolumeOptions ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string secr Required \u00b6 Type: cdk8s-plus-24.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-24.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import { Workload } from 'cdk8s-plus-24' new Workload ( scope : Construct , id : string , props? : WorkloadProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-24.WorkloadProps Methods \u00b6 select \u00b6 public select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s-plus-24.LabelSelector Properties \u00b6 connections Required \u00b6 public readonly connections : PodConnections ; Type: cdk8s-plus-24.PodConnections matchExpressions Required \u00b6 public readonly matchExpressions : LabelSelectorRequirement []; Type: cdk8s-plus-24.LabelSelectorRequirement [] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public readonly matchLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. scheduling Required \u00b6 public readonly scheduling : WorkloadScheduling ; Type: cdk8s-plus-24.WorkloadScheduling Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import { AbstractPodProps } from 'cdk8s-plus-24' const abstractPodProps : AbstractPodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-24' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-24' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import { ApiResourceOptions } from 'cdk8s-plus-24' const apiResourceOptions : ApiResourceOptions = { ... } apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import { AwsElasticBlockStorePersistentVolumeProps } from 'cdk8s-plus-24' const awsElasticBlockStorePersistentVolumeProps : AwsElasticBlockStorePersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import { AwsElasticBlockStoreVolumeOptions } from 'cdk8s-plus-24' const awsElasticBlockStoreVolumeOptions : AwsElasticBlockStoreVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import { AzureDiskPersistentVolumeProps } from 'cdk8s-plus-24' const azureDiskPersistentVolumeProps : AzureDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public readonly diskName : string ; Type: string The Name of the data disk in the blob storage. diskUri Required \u00b6 public readonly diskUri : string ; Type: string The URI the data disk in the blob storage. cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import { AzureDiskVolumeOptions } from 'cdk8s-plus-24' const azureDiskVolumeOptions : AzureDiskVolumeOptions = { ... } cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-24.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-24.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import { BasicAuthSecretProps } from 'cdk8s-plus-24' const basicAuthSecretProps : BasicAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public readonly password : string ; Type: string The password or token for authentication. username Required \u00b6 public readonly username : string ; Type: string The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import { ClusterRoleBindingProps } from 'cdk8s-plus-24' const clusterRoleBindingProps : ClusterRoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-24.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import { ClusterRolePolicyRule } from 'cdk8s-plus-24' const clusterRolePolicyRule : ClusterRolePolicyRule = { ... } endpoints Required \u00b6 public readonly endpoints : IApiEndpoint []; Type: cdk8s-plus-24.IApiEndpoint [] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import { ClusterRoleProps } from 'cdk8s-plus-24' const clusterRoleProps : ClusterRoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public readonly aggregationLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-24.ClusterRolePolicyRule [] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-24' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import { CommonSecretProps } from 'cdk8s-plus-24' const commonSecretProps : CommonSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-24' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-24' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-24.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import { ContainerLifecycle } from 'cdk8s-plus-24' const containerLifecycle : ContainerLifecycle = { ... } postStart Optional \u00b6 public readonly postStart : Handler ; Type: cdk8s-plus-24.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public readonly preStop : Handler ; Type: cdk8s-plus-24.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerPort \u00b6 Represents a network port in a single container. Initializer \u00b6 import { ContainerPort } from 'cdk8s-plus-24' const containerPort : ContainerPort = { ... } number Required \u00b6 public readonly number : number ; Type: number Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. hostIp Optional \u00b6 public readonly hostIp : string ; Type: string Default: 127.0.0.1. What host IP to bind the external port to. hostPort Optional \u00b6 public readonly hostPort : number ; Type: number Default: auto generated by kubernetes and might change on restarts. Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. Most containers do not need this. name Optional \u00b6 public readonly name : string ; Type: string Default: port is not named. If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-24.Protocol Default: Protocol.TCP Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \u201cTCP\u201d. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-24' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell envFrom Optional \u00b6 public readonly envFrom : EnvFrom []; Type: cdk8s-plus-24.EnvFrom [] Default: No sources. List of sources to populate environment variables in the container. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by the envVariables property with a duplicate key will take precedence. envVariables Optional \u00b6 public readonly envVariables : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-24.EnvValue } Default: No environment variables. Environment variables to set in the container. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-24.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public readonly lifecycle : ContainerLifecycle ; Type: cdk8s-plus-24.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-24.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public readonly port : number ; Type: number portNumber Optional \u00b6 public readonly portNumber : number ; Type: number Default: Only the ports mentiond in the ports property are exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. This is a convinience property if all you need a single TCP numbered port. In case more advanced configuartion is required, use the ports property. This port is added to the list of ports mentioned in the ports property. ports Optional \u00b6 public readonly ports : ContainerPort []; Type: cdk8s-plus-24.ContainerPort [] Default: Only the port mentioned in the portNumber property is exposed. List of ports to expose from this container. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-24.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-24.ContainerResources Default: cpu: request: 1000 millis limit: 1500 millis memory: request: 512 mebibytes limit: 2048 mebibytes Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public readonly securityContext : ContainerSecurityContextProps ; Type: cdk8s-plus-24.ContainerSecurityContextProps Default: ensureNonRoot: true privileged: false readOnlyRootFilesystem: true allowPrivilegeEscalation: false user: 25000 group: 26000 SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-24.Probe Default: If a port is provided, then knocks on that port to determine when the container is ready for readiness and liveness probe checks. Otherwise, no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-24.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import { ContainerResources } from 'cdk8s-plus-24' const containerResources : ContainerResources = { ... } cpu Optional \u00b6 public readonly cpu : CpuResources ; Type: cdk8s-plus-24.CpuResources ephemeralStorage Optional \u00b6 public readonly ephemeralStorage : EphemeralStorageResources ; Type: cdk8s-plus-24.EphemeralStorageResources memory Optional \u00b6 public readonly memory : MemoryResources ; Type: cdk8s-plus-24.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import { ContainerSecurityContextProps } from 'cdk8s-plus-24' const containerSecurityContextProps : ContainerSecurityContextProps = { ... } allowPrivilegeEscalation Optional \u00b6 public readonly allowPrivilegeEscalation : boolean ; Type: boolean Default: false Whether a process can gain more privileges than its parent process. ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public readonly group : number ; Type: number Default: 26000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The GID to run the entrypoint of the container process. privileged Optional \u00b6 public readonly privileged : boolean ; Type: boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean Default: true Whether this container has a read-only root filesystem. user Optional \u00b6 public readonly user : number ; Type: number Default: 25000. An arbitrary number bigger than 9999 is selected here. This is so that the container is blocked to access host files even if somehow it manages to get access to host file system. The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import { CpuResources } from 'cdk8s-plus-24' const cpuResources : CpuResources = { ... } limit Optional \u00b6 public readonly limit : Cpu ; Type: cdk8s-plus-24.Cpu request Optional \u00b6 public readonly request : Cpu ; Type: cdk8s-plus-24.Cpu CronJobProps \u00b6 Properties for CronJob . Initializer \u00b6 import { CronJobProps } from 'cdk8s-plus-24' const cronJobProps : CronJobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. schedule Required \u00b6 public readonly schedule : Cron ; Type: cdk8s.Cron Specifies the time in which the job would run again. This is defined as a cron expression in the CronJob resource. concurrencyPolicy Optional \u00b6 public readonly concurrencyPolicy : ConcurrencyPolicy ; Type: cdk8s-plus-24.ConcurrencyPolicy Default: ConcurrencyPolicy.Forbid Specifies the concurrency policy for the job. failedJobsRetained Optional \u00b6 public readonly failedJobsRetained : number ; Type: number Default: 1 Specifies the number of failed jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. startingDeadline Optional \u00b6 public readonly startingDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Kubernetes attempts to start cron jobs at its schedule time, but this is not guaranteed. This deadline specifies how much time can pass after a schedule point, for which kubernetes can still start the job. For example, if this is set to 100 seconds, kubernetes is allowed to start the job at a maximum 100 seconds after the scheduled time. Note that the Kubernetes CronJobController checks for things every 10 seconds, for this reason, a deadline below 10 seconds is not allowed, as it may cause your job to never be scheduled. In addition, kubernetes will stop scheduling jobs if more than 100 schedules were missed (for any reason). This property also controls what time interval should kubernetes consider when counting for missed schedules. For example, suppose a CronJob is set to schedule a new Job every one minute beginning at 08:30:00, and its startingDeadline field is not set. If the CronJob controller happens to be down from 08:29:00 to 10:21:00, the job will not start as the number of missed jobs which missed their schedule is greater than 100. However, if startingDeadline is set to 200 seconds, kubernetes will only count 3 missed schedules, and thus start a new execution at 10:22:00. successfulJobsRetained Optional \u00b6 public readonly successfulJobsRetained : number ; Type: number Default: 3 Specifies the number of successful jobs history retained. This would retain the Job and the associated Pod resource and can be useful for debugging. suspend Optional \u00b6 public readonly suspend : boolean ; Type: boolean Default: false Specifies if the cron job should be suspended. Only applies to future executions, current ones are remained untouched. timeZone Optional \u00b6 public readonly timeZone : string ; Type: string Default: Timezone of kube-controller-manager process. Specifies the timezone for the job. This helps aligining the schedule to follow the specified timezone. {@link https://en.wikipedia.org/wiki/List_of_tz_database_time_zones} for list of valid timezone values. DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import { DaemonSetProps } from 'cdk8s-plus-24' const daemonSetProps : DaemonSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReadySeconds Optional \u00b6 public readonly minReadySeconds : number ; Type: number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentExposeViaServiceOptions \u00b6 Options for Deployment.exposeViaService . Initializer \u00b6 import { DeploymentExposeViaServiceOptions } from 'cdk8s-plus-24' const deploymentExposeViaServiceOptions : DeploymentExposeViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-24.ServicePort [] Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-24.ServiceType Default: ClusterIP. The type of the exposed service. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-24' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 2 Number of desired pods. strategy Optional \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-24.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import { DeploymentStrategyRollingUpdateOptions } from 'cdk8s-plus-24' const deploymentStrategyRollingUpdateOptions : DeploymentStrategyRollingUpdateOptions = { ... } maxSurge Optional \u00b6 public readonly maxSurge : PercentOrAbsolute ; Type: cdk8s-plus-24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public readonly maxUnavailable : PercentOrAbsolute ; Type: cdk8s-plus-24.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import { DnsOption } from 'cdk8s-plus-24' const dnsOption : DnsOption = { ... } name Required \u00b6 public readonly name : string ; Type: string Option name. value Optional \u00b6 public readonly value : string ; Type: string Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import { DockerConfigSecretProps } from 'cdk8s-plus-24' const dockerConfigSecretProps : DockerConfigSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public readonly data : {[ key : string ] : any }; Type: {[ key: string ]: any } JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-24' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-24.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-24' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import { EnvValueFromFieldRefOptions } from 'cdk8s-plus-24' const envValueFromFieldRefOptions : EnvValueFromFieldRefOptions = { ... } apiVersion Optional \u00b6 public readonly apiVersion : string ; Type: string Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public readonly key : string ; Type: string The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-24' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import { EnvValueFromResourceOptions } from 'cdk8s-plus-24' const envValueFromResourceOptions : EnvValueFromResourceOptions = { ... } container Optional \u00b6 public readonly container : Container ; Type: cdk8s-plus-24.Container The container to select the value from. divisor Optional \u00b6 public readonly divisor : string ; Type: string The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-24' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. EphemeralStorageResources \u00b6 Emphemeral storage request and limit. Initializer \u00b6 import { EphemeralStorageResources } from 'cdk8s-plus-24' const ephemeralStorageResources : EphemeralStorageResources = { ... } limit Optional \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Optional \u00b6 public readonly request : Size ; Type: cdk8s.Size ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-24' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: auto generated. The name of the service to expose. If you\u2019d like to expose the deployment multiple times, you must explicitly set a name starting from the second expose call. ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-24.ServicePort [] Default: extracted from the deployment. The ports that the service should bind to. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-24.ServiceType Default: ClusterIP. The type of the exposed service. ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-24' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-24.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-24.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import { GCEPersistentDiskPersistentVolumeProps } from 'cdk8s-plus-24' const gCEPersistentDiskPersistentVolumeProps : GCEPersistentDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public readonly pdName : string ; Type: string Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import { GCEPersistentDiskVolumeOptions } from 'cdk8s-plus-24' const gCEPersistentDiskVolumeOptions : GCEPersistentDiskVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import { HandlerFromHttpGetOptions } from 'cdk8s-plus-24' const handlerFromHttpGetOptions : HandlerFromHttpGetOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import { HandlerFromTcpSocketOptions } from 'cdk8s-plus-24' const handlerFromTcpSocketOptions : HandlerFromTcpSocketOptions = { ... } host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import { HostAlias } from 'cdk8s-plus-24' const hostAlias : HostAlias = { ... } hostnames Required \u00b6 public readonly hostnames : string []; Type: string [] Hostnames for the chosen IP address. ip Required \u00b6 public readonly ip : string ; Type: string IP address of the host file entry. HostPathVolumeOptions \u00b6 Options for a HostPathVolume-based volume. Initializer \u00b6 import { HostPathVolumeOptions } from 'cdk8s-plus-24' const hostPathVolumeOptions : HostPathVolumeOptions = { ... } path Required \u00b6 public readonly path : string ; Type: string The path of the directory on the host. type Optional \u00b6 public readonly type : HostPathVolumeType ; Type: cdk8s-plus-24.HostPathVolumeType Default: HostPathVolumeType.DEFAULT The expected type of the path found on the host. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-24' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. scheme Optional \u00b6 public readonly scheme : ConnectionScheme ; Type: cdk8s-plus-24.ConnectionScheme Default: ConnectionScheme.HTTP Scheme to use for connecting to the host (HTTP or HTTPS). IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressProps } from 'cdk8s-plus-24' const ingressProps : IngressProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressBackend ; Type: cdk8s-plus-24.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressRule []; Type: cdk8s-plus-24.IngressRule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressTls []; Type: cdk8s-plus-24.IngressTls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressRule } from 'cdk8s-plus-24' const ingressRule : IngressRule = { ... } backend Required \u00b6 public readonly backend : IngressBackend ; Type: cdk8s-plus-24.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-24.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressTls } from 'cdk8s-plus-24' const ingressTls : IngressTls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-24.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-24' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorOptions \u00b6 Options for LabelSelector.of . Initializer \u00b6 import { LabelSelectorOptions } from 'cdk8s-plus-24' const labelSelectorOptions : LabelSelectorOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-24.LabelExpression [] Expression based label matchers. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Strict label matchers. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import { LabelSelectorRequirement } from 'cdk8s-plus-24' const labelSelectorRequirement : LabelSelectorRequirement = { ... } key Required \u00b6 public readonly key : string ; Type: string The label key that the selector applies to. operator Required \u00b6 public readonly operator : string ; Type: string Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public readonly values : string []; Type: string [] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import { MemoryResources } from 'cdk8s-plus-24' const memoryResources : MemoryResources = { ... } limit Optional \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Optional \u00b6 public readonly request : Size ; Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-24' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. NamespaceProps \u00b6 Properties for Namespace . Initializer \u00b6 import { NamespaceProps } from 'cdk8s-plus-24' const namespaceProps : NamespaceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. NamespaceSelectorConfig \u00b6 Configuration for selecting namespaces. Initializer \u00b6 import { NamespaceSelectorConfig } from 'cdk8s-plus-24' const namespaceSelectorConfig : NamespaceSelectorConfig = { ... } labelSelector Optional \u00b6 public readonly labelSelector : LabelSelector ; Type: cdk8s-plus-24.LabelSelector A selector to select namespaces by labels. names Optional \u00b6 public readonly names : string []; Type: string [] A list of names to select namespaces by names. NamespacesSelectOptions \u00b6 Options for Namespaces.select . Initializer \u00b6 import { NamespacesSelectOptions } from 'cdk8s-plus-24' const namespacesSelectOptions : NamespacesSelectOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-24.LabelExpression [] Default: no selector requirements. Namespaces must satisfy these selectors. The selectors query labels, just like the labels property, but they provide a more advanced matching mechanism. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no strict labels requirements. Labels the namespaces must have. This is equivalent to using an \u2018Is\u2019 selector. names Optional \u00b6 public readonly names : string []; Type: string [] Default: no name requirements. Namespaces names must be one of these. NetworkPolicyAddEgressRuleOptions \u00b6 Options for NetworkPolicy.addEgressRule . Initializer \u00b6 import { NetworkPolicyAddEgressRuleOptions } from 'cdk8s-plus-24' const networkPolicyAddEgressRuleOptions : NetworkPolicyAddEgressRuleOptions = { ... } ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-24.NetworkPolicyPort [] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports the rule should allow outgoing traffic to. NetworkPolicyPeerConfig \u00b6 Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both. Initializer \u00b6 import { NetworkPolicyPeerConfig } from 'cdk8s-plus-24' const networkPolicyPeerConfig : NetworkPolicyPeerConfig = { ... } ipBlock Optional \u00b6 public readonly ipBlock : NetworkPolicyIpBlock ; Type: cdk8s-plus-24.NetworkPolicyIpBlock The ip block this peer represents. podSelector Optional \u00b6 public readonly podSelector : PodSelectorConfig ; Type: cdk8s-plus-24.PodSelectorConfig The pod selector this peer represents. NetworkPolicyPortProps \u00b6 Properties for NetworkPolicyPort . Initializer \u00b6 import { NetworkPolicyPortProps } from 'cdk8s-plus-24' const networkPolicyPortProps : NetworkPolicyPortProps = { ... } endPort Optional \u00b6 public readonly endPort : number ; Type: number Default: not a port range. End port (relative to port ). Only applies if port is defined. Use this to specify a port range, rather that a specific one. port Optional \u00b6 public readonly port : number ; Type: number Default: all ports are allowed. Specific port number. protocol Optional \u00b6 public readonly protocol : NetworkProtocol ; Type: cdk8s-plus-24.NetworkProtocol Default: NetworkProtocol.TCP Protocol. NetworkPolicyProps \u00b6 Properties for NetworkPolicy . Initializer \u00b6 import { NetworkPolicyProps } from 'cdk8s-plus-24' const networkPolicyProps : NetworkPolicyProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. egress Optional \u00b6 public readonly egress : NetworkPolicyTraffic ; Type: cdk8s-plus-24.NetworkPolicyTraffic Default: the policy doesn\u2019t change egress behavior of the pods it selects. Egress traffic configuration. ingress Optional \u00b6 public readonly ingress : NetworkPolicyTraffic ; Type: cdk8s-plus-24.NetworkPolicyTraffic Default: the policy doesn\u2019t change ingress behavior of the pods it selects. Ingress traffic configuration. selector Optional \u00b6 public readonly selector : IPodSelector ; Type: cdk8s-plus-24.IPodSelector Default: will select all pods in the namespace of the policy. Which pods does this policy object applies to. This can either be a single pod / workload, or a grouping of pods selected via the Pods.select function. Rules is applied to any pods selected by this property. Multiple network policies can select the same set of pods. In this case, the rules for each are combined additively. Note that NetworkPolicyRule \u00b6 Describes a rule allowing traffic from / to pods matched by a network policy selector. Initializer \u00b6 import { NetworkPolicyRule } from 'cdk8s-plus-24' const networkPolicyRule : NetworkPolicyRule = { ... } peer Required \u00b6 public readonly peer : INetworkPolicyPeer ; Type: cdk8s-plus-24.INetworkPolicyPeer Peer this rule interacts with. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-24.NetworkPolicyPort [] Default: traffic is allowed on all ports. The ports of the rule. NetworkPolicyTraffic \u00b6 Describes how the network policy should configure egress / ingress traffic. Initializer \u00b6 import { NetworkPolicyTraffic } from 'cdk8s-plus-24' const networkPolicyTraffic : NetworkPolicyTraffic = { ... } default Optional \u00b6 public readonly default : NetworkPolicyTrafficDefault ; Type: cdk8s-plus-24.NetworkPolicyTrafficDefault Default: unset, the policy does not change the behavior. Specifies the default behavior of the policy when no rules are defined. rules Optional \u00b6 public readonly rules : NetworkPolicyRule []; Type: cdk8s-plus-24.NetworkPolicyRule [] Default: no rules List of rules to be applied to the selected pods. If empty, the behavior of the policy is dictated by the default property. NodeTaintQueryOptions \u00b6 Options for NodeTaintQuery . Initializer \u00b6 import { NodeTaintQueryOptions } from 'cdk8s-plus-24' const nodeTaintQueryOptions : NodeTaintQueryOptions = { ... } effect Optional \u00b6 public readonly effect : TaintEffect ; Type: cdk8s-plus-24.TaintEffect Default: all effects are matched. The taint effect to match. evictAfter Optional \u00b6 public readonly evictAfter : Duration ; Type: cdk8s.Duration Default: bound forever. How much time should a pod that tolerates the NO_EXECUTE effect be bound to the node. Only applies for the NO_EXECUTE effect. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-24' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import { PersistentVolumeClaimProps } from 'cdk8s-plus-24' const persistentVolumeClaimProps : PersistentVolumeClaimProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. - If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-24.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import { PersistentVolumeClaimVolumeOptions } from 'cdk8s-plus-24' const persistentVolumeClaimVolumeOptions : PersistentVolumeClaimVolumeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import { PersistentVolumeProps } from 'cdk8s-plus-24' const persistentVolumeProps : PersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-24.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-24.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-24.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-24.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodConnectionsAllowFromOptions \u00b6 Options for PodConnections.allowFrom . Initializer \u00b6 import { PodConnectionsAllowFromOptions } from 'cdk8s-plus-24' const podConnectionsAllowFromOptions : PodConnectionsAllowFromOptions = { ... } isolation Optional \u00b6 public readonly isolation : PodConnectionsIsolation ; Type: cdk8s-plus-24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-24.NetworkPolicyPort [] Default: The pod ports. Ports to allow incoming traffic to. PodConnectionsAllowToOptions \u00b6 Options for PodConnections.allowTo . Initializer \u00b6 import { PodConnectionsAllowToOptions } from 'cdk8s-plus-24' const podConnectionsAllowToOptions : PodConnectionsAllowToOptions = { ... } isolation Optional \u00b6 public readonly isolation : PodConnectionsIsolation ; Type: cdk8s-plus-24.PodConnectionsIsolation Default: unset, isolates both the pod and the peer. Which isolation should be applied to establish the connection. ports Optional \u00b6 public readonly ports : NetworkPolicyPort []; Type: cdk8s-plus-24.NetworkPolicyPort [] Default: If the peer is a managed pod, take its ports. Otherwise, all ports are allowed. Ports to allow outgoing traffic to. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import { PodDnsProps } from 'cdk8s-plus-24' const podDnsProps : PodDnsProps = { ... } hostname Optional \u00b6 public readonly hostname : string ; Type: string Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public readonly nameservers : string []; Type: string [] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-24.DnsOption [] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-24.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public readonly searches : string []; Type: string [] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-24' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodsAllOptions \u00b6 Options for Pods.all . Initializer \u00b6 import { PodsAllOptions } from 'cdk8s-plus-24' const podsAllOptions : PodsAllOptions = { ... } namespaces Optional \u00b6 public readonly namespaces : Namespaces ; Type: cdk8s-plus-24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. PodSchedulingAttractOptions \u00b6 Options for PodScheduling.attract . Initializer \u00b6 import { PodSchedulingAttractOptions } from 'cdk8s-plus-24' const podSchedulingAttractOptions : PodSchedulingAttractOptions = { ... } weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. assignment is assumed to be required (hard). Indicates the attraction is optional (soft), with this weight score. PodSchedulingColocateOptions \u00b6 Options for PodScheduling.colocate . Initializer \u00b6 import { PodSchedulingColocateOptions } from 'cdk8s-plus-24' const podSchedulingColocateOptions : PodSchedulingColocateOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-24.Topology Default: Topology.HOSTNAME Which topology to coloate on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. co-location is assumed to be required (hard). Indicates the co-location is optional (soft), with this weight score. PodSchedulingSeparateOptions \u00b6 Options for PodScheduling.separate . Initializer \u00b6 import { PodSchedulingSeparateOptions } from 'cdk8s-plus-24' const podSchedulingSeparateOptions : PodSchedulingSeparateOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-24.Topology Default: Topology.HOSTNAME Which topology to separate on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. separation is assumed to be required (hard). Indicates the separation is optional (soft), with this weight score. PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import { PodSecurityContextProps } from 'cdk8s-plus-24' const podSecurityContextProps : PodSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: true Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-24.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-24.Sysctl [] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. PodSelectorConfig \u00b6 Configuration for selecting pods, optionally in particular namespaces. Initializer \u00b6 import { PodSelectorConfig } from 'cdk8s-plus-24' const podSelectorConfig : PodSelectorConfig = { ... } labelSelector Required \u00b6 public readonly labelSelector : LabelSelector ; Type: cdk8s-plus-24.LabelSelector A selector to select pods by labels. namespaces Optional \u00b6 public readonly namespaces : NamespaceSelectorConfig ; Type: cdk8s-plus-24.NamespaceSelectorConfig Configuration for selecting which namepsaces are the pods allowed to be in. PodsSelectOptions \u00b6 Options for Pods.select . Initializer \u00b6 import { PodsSelectOptions } from 'cdk8s-plus-24' const podsSelectOptions : PodsSelectOptions = { ... } expressions Optional \u00b6 public readonly expressions : LabelExpression []; Type: cdk8s-plus-24.LabelExpression [] Default: no expressions requirements. Expressions the pods must satisify. labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no strict labels requirements. Labels the pods must have. namespaces Optional \u00b6 public readonly namespaces : Namespaces ; Type: cdk8s-plus-24.Namespaces Default: unset, implies the namespace of the resource this selection is used in. Namespaces the pods are allowed to be in. Use Namespaces.all() to allow all namespaces. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-24' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-24' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import { RoleBindingProps } from 'cdk8s-plus-24' const roleBindingProps : RoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-24.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import { RolePolicyRule } from 'cdk8s-plus-24' const rolePolicyRule : RolePolicyRule = { ... } resources Required \u00b6 public readonly resources : IApiResource []; Type: cdk8s-plus-24.IApiResource [] Resources this rule applies to. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import { RoleProps } from 'cdk8s-plus-24' const roleProps : RoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-24.RolePolicyRule [] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-24' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-24' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-24.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import { SecretVolumeOptions } from 'cdk8s-plus-24' const secretVolumeOptions : SecretVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-24.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-24' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public readonly automountToken : boolean ; Type: boolean Default: false Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-24.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import { ServiceAccountTokenSecretProps } from 'cdk8s-plus-24' const serviceAccountTokenSecretProps : ServiceAccountTokenSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount The service account to store a secret for. ServiceBindOptions \u00b6 Options for Service.bind . Initializer \u00b6 import { ServiceBindOptions } from 'cdk8s-plus-24' const serviceBindOptions : ServiceBindOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressBackendOptions } from 'cdk8s-plus-24' const serviceIngressBackendOptions : ServiceIngressBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-24' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-24.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServiceProps \u00b6 Properties for Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-24' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-24.ServicePort [] Default: either the selector ports, or none. The ports this service binds to. If the selector of the service is a managed pod / workload, its ports will are automatically extracted and used as the default value. Otherwise, no ports are bound. selector Optional \u00b6 public readonly selector : IPodSelector ; Type: cdk8s-plus-24.IPodSelector Default: unset, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Which pods should the service select and route to. You can pass one of the following: An instance of Pod or any workload resource (e.g Deployment , StatefulSet , \u2026) Pods selected by the Pods.select function. Note that in this case only labels can be specified. type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-24.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import { SshAuthSecretProps } from 'cdk8s-plus-24' const sshAuthSecretProps : SshAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public readonly sshPrivateKey : string ; Type: string The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-24' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-24.Service Service to associate with the statefulset. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-24.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-24.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import { StatefulSetUpdateStrategyRollingUpdateOptions } from 'cdk8s-plus-24' const statefulSetUpdateStrategyRollingUpdateOptions : StatefulSetUpdateStrategyRollingUpdateOptions = { ... } partition Optional \u00b6 public readonly partition : number ; Type: number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions SubjectConfiguration \u00b6 Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Initializer \u00b6 import { SubjectConfiguration } from 'cdk8s-plus-24' const subjectConfiguration : SubjectConfiguration = { ... } kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public readonly namespace : string ; Type: string Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import { Sysctl } from 'cdk8s-plus-24' const sysctl : Sysctl = { ... } name Required \u00b6 public readonly name : string ; Type: string Name of a property to set. value Required \u00b6 public readonly value : string ; Type: string Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import { TcpSocketProbeOptions } from 'cdk8s-plus-24' const tcpSocketProbeOptions : TcpSocketProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import { TlsSecretProps } from 'cdk8s-plus-24' const tlsSecretProps : TlsSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public readonly tlsCert : string ; Type: string The TLS cert. tlsKey Required \u00b6 public readonly tlsKey : string ; Type: string The TLS key. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-24' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-24.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-24.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import { WorkloadProps } from 'cdk8s-plus-24' const workloadProps : WorkloadProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: false Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-24.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-24.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-24.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-24.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-24.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-24.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: true SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-24.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-24.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. spread Optional \u00b6 public readonly spread : boolean ; Type: boolean Default: false Automatically spread pods across hostname and zones. https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#internal-default-constraints WorkloadSchedulingSpreadOptions \u00b6 Options for WorkloadScheduling.spread . Initializer \u00b6 import { WorkloadSchedulingSpreadOptions } from 'cdk8s-plus-24' const workloadSchedulingSpreadOptions : WorkloadSchedulingSpreadOptions = { ... } topology Optional \u00b6 public readonly topology : Topology ; Type: cdk8s-plus-24.Topology Default: Topology.HOSTNAME Which topology to spread on. weight Optional \u00b6 public readonly weight : number ; Type: number Default: no weight. spread is assumed to be required. Indicates the spread is optional, with this weight score. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s-plus-24.IApiResource , cdk8s-plus-24.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import { ApiResource } from 'cdk8s-plus-24' ApiResource . custom ( options : ApiResourceOptions ) options Required \u00b6 Type: cdk8s-plus-24.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s-plus-24.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-24' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-24.ContainerProps Methods \u00b6 addPort \u00b6 public addPort ( port : ContainerPort ) port Required \u00b6 Type: cdk8s-plus-24.ContainerPort mount \u00b6 public mount ( path : string , storage : IStorage , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. storage Required \u00b6 Type: cdk8s-plus-24.IStorage The storage to mount. options Optional \u00b6 Type: cdk8s-plus-24.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : Env ; Type: cdk8s-plus-24.Env The environment of the container. image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-24.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-24.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. ports Required \u00b6 public readonly ports : ContainerPort []; Type: cdk8s-plus-24.ContainerPort [] Ports exposed by this containers. Returns a copy, use addPort to modify. securityContext Required \u00b6 public readonly securityContext : ContainerSecurityContext ; Type: cdk8s-plus-24.ContainerSecurityContext The security context of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). ~~ port ~~ Optional \u00b6 Deprecated: - use portNumber . public readonly port : number ; Type: number portNumber Optional \u00b6 public readonly portNumber : number ; Type: number The port number that was configured for this container. If undefined, either the container doesn\u2019t expose a port, or its port configuration is stored in the ports field. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-24.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import { ContainerSecurityContext } from 'cdk8s-plus-24' new ContainerSecurityContext ( props? : ContainerSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-24.ContainerSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean privileged Required \u00b6 public readonly privileged : boolean ; Type: boolean readOnlyRootFilesystem Required \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean allowPrivilegeEscalation Optional \u00b6 public readonly allowPrivilegeEscalation : boolean ; Type: boolean group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import { Cpu } from 'cdk8s-plus-24' Cpu . millis ( amount : number ) amount Required \u00b6 Type: number units \u00b6 import { Cpu } from 'cdk8s-plus-24' Cpu . units ( amount : number ) amount Required \u00b6 Type: number Properties \u00b6 amount Required \u00b6 public readonly amount : string ; Type: string DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-24' DeploymentStrategy . recreate () rollingUpdate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-24' DeploymentStrategy . rollingUpdate ( options? : DeploymentStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-24.DeploymentStrategyRollingUpdateOptions Env \u00b6 Container environment variables. Initializers \u00b6 import { Env } from 'cdk8s-plus-24' new Env ( sources : EnvFrom [], variables : {[ key : string ] : EnvValue }) sources Required \u00b6 Type: cdk8s-plus-24.EnvFrom [] variables Required \u00b6 Type: {[ key: string ]: cdk8s-plus-24.EnvValue } Methods \u00b6 addVariable \u00b6 public addVariable ( name : string , value : EnvValue ) name Required \u00b6 Type: string value Required \u00b6 Type: cdk8s-plus-24.EnvValue copyFrom \u00b6 public copyFrom ( from : EnvFrom ) from Required \u00b6 Type: cdk8s-plus-24.EnvFrom Static Functions \u00b6 fromConfigMap \u00b6 import { Env } from 'cdk8s-plus-24' Env . fromConfigMap ( configMap : IConfigMap , prefix? : string ) configMap Required \u00b6 Type: cdk8s-plus-24.IConfigMap prefix Optional \u00b6 Type: string fromSecret \u00b6 import { Env } from 'cdk8s-plus-24' Env . fromSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-24.ISecret Properties \u00b6 sources Required \u00b6 public readonly sources : EnvFrom []; Type: cdk8s-plus-24.EnvFrom [] The list of sources used to populate the container environment, in addition to the variables . Returns a copy. To add a source use container.env.copyFrom() . variables Required \u00b6 public readonly variables : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-24.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use container.env.addVariable() . EnvFrom \u00b6 A collection of env variables defined in other resources. Initializers \u00b6 import { EnvFrom } from 'cdk8s-plus-24' new EnvFrom ( configMap? : IConfigMap , prefix? : string , sec? : ISecret ) configMap Optional \u00b6 Type: cdk8s-plus-24.IConfigMap prefix Optional \u00b6 Type: string sec Optional \u00b6 Type: cdk8s-plus-24.ISecret EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-24' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-24.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-24.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import { EnvValue } from 'cdk8s-plus-24' EnvValue . fromFieldRef ( fieldPath : EnvFieldPaths , options? : EnvValueFromFieldRefOptions ) fieldPath Required \u00b6 Type: cdk8s-plus-24.EnvFieldPaths : The field reference. options Optional \u00b6 Type: cdk8s-plus-24.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-24' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-24.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import { EnvValue } from 'cdk8s-plus-24' EnvValue . fromResource ( resource : ResourceFieldPaths , options? : EnvValueFromResourceOptions ) resource Required \u00b6 Type: cdk8s-plus-24.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: cdk8s-plus-24.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-24' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-24.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-24.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-24' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import { Handler } from 'cdk8s-plus-24' Handler . fromCommand ( command : string []) command Required \u00b6 Type: string [] The command to execute. fromHttpGet \u00b6 import { Handler } from 'cdk8s-plus-24' Handler . fromHttpGet ( path : string , options? : HandlerFromHttpGetOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-24.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import { Handler } from 'cdk8s-plus-24' Handler . fromTcpSocket ( options? : HandlerFromTcpSocketOptions ) options Optional \u00b6 Type: cdk8s-plus-24.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromResource \u00b6 import { IngressBackend } from 'cdk8s-plus-24' IngressBackend . fromResource ( resource : IResource ) resource Required \u00b6 Type: cdk8s-plus-24.IResource fromService \u00b6 import { IngressBackend } from 'cdk8s-plus-24' IngressBackend . fromService ( serv : Service , options? : ServiceIngressBackendOptions ) serv Required \u00b6 Type: cdk8s-plus-24.Service The service object. options Optional \u00b6 Type: cdk8s-plus-24.ServiceIngressBackendOptions LabeledNode \u00b6 A node that is matched by label selectors. Initializers \u00b6 import { LabeledNode } from 'cdk8s-plus-24' new LabeledNode ( labelSelector : NodeLabelQuery []) labelSelector Required \u00b6 Type: cdk8s-plus-24.NodeLabelQuery [] Properties \u00b6 labelSelector Required \u00b6 public readonly labelSelector : NodeLabelQuery []; Type: cdk8s-plus-24.NodeLabelQuery [] LabelExpression \u00b6 Represents a query that can be performed against resources with labels. Static Functions \u00b6 doesNotExist \u00b6 import { LabelExpression } from 'cdk8s-plus-24' LabelExpression . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { LabelExpression } from 'cdk8s-plus-24' LabelExpression . exists ( key : string ) key Required \u00b6 Type: string in \u00b6 import { LabelExpression } from 'cdk8s-plus-24' LabelExpression . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] notIn \u00b6 import { LabelExpression } from 'cdk8s-plus-24' LabelExpression . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string operator Required \u00b6 public readonly operator : string ; Type: string values Optional \u00b6 public readonly values : string []; Type: string [] LabelSelector \u00b6 Match a resource by labels. Methods \u00b6 isEmpty \u00b6 public isEmpty () Static Functions \u00b6 of \u00b6 import { LabelSelector } from 'cdk8s-plus-24' LabelSelector . of ( options? : LabelSelectorOptions ) options Optional \u00b6 Type: cdk8s-plus-24.LabelSelectorOptions NamedNode \u00b6 A node that is matched by its name. Initializers \u00b6 import { NamedNode } from 'cdk8s-plus-24' new NamedNode ( name : string ) name Required \u00b6 Type: string Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string NetworkPolicyPort \u00b6 Describes a port to allow traffic on. Static Functions \u00b6 allTcp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . allTcp () allUdp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . allUdp () of \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . of ( props : NetworkPolicyPortProps ) props Required \u00b6 Type: cdk8s-plus-24.NetworkPolicyPortProps tcp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . tcp ( port : number ) port Required \u00b6 Type: number tcpRange \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . tcpRange ( startPort : number , endPort : number ) startPort Required \u00b6 Type: number endPort Required \u00b6 Type: number udp \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . udp ( port : number ) port Required \u00b6 Type: number udpRange \u00b6 import { NetworkPolicyPort } from 'cdk8s-plus-24' NetworkPolicyPort . udpRange ( startPort : number , endPort : number ) startPort Required \u00b6 Type: number endPort Required \u00b6 Type: number Node \u00b6 Represents a node in the cluster. Initializers \u00b6 import { Node } from 'cdk8s-plus-24' new Node () Static Functions \u00b6 labeled \u00b6 import { Node } from 'cdk8s-plus-24' Node . labeled ( labelSelector : NodeLabelQuery ) labelSelector Required \u00b6 Type: cdk8s-plus-24.NodeLabelQuery named \u00b6 import { Node } from 'cdk8s-plus-24' Node . named ( nodeName : string ) nodeName Required \u00b6 Type: string tainted \u00b6 import { Node } from 'cdk8s-plus-24' Node . tainted ( taintSelector : NodeTaintQuery ) taintSelector Required \u00b6 Type: cdk8s-plus-24.NodeTaintQuery NodeLabelQuery \u00b6 Represents a query that can be performed against nodes with labels. Static Functions \u00b6 doesNotExist \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . exists ( key : string ) key Required \u00b6 Type: string gt \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . gt ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] in \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] is \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . is ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string lt \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . lt ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] notIn \u00b6 import { NodeLabelQuery } from 'cdk8s-plus-24' NodeLabelQuery . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] NodeTaintQuery \u00b6 Taint queries that can be perfomed against nodes. Static Functions \u00b6 any \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-24' NodeTaintQuery . any () exists \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-24' NodeTaintQuery . exists ( key : string , options? : NodeTaintQueryOptions ) key Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.NodeTaintQueryOptions is \u00b6 import { NodeTaintQuery } from 'cdk8s-plus-24' NodeTaintQuery . is ( key : string , value : string , options? : NodeTaintQueryOptions ) key Required \u00b6 Type: string value Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-24.NodeTaintQueryOptions NonApiResource \u00b6 Implements: cdk8s-plus-24.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import { NonApiResource } from 'cdk8s-plus-24' NonApiResource . of ( url : string ) url Required \u00b6 Type: string PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-24' PercentOrAbsolute . absolute ( num : number ) num Required \u00b6 Type: number percent \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-24' PercentOrAbsolute . percent ( percent : number ) percent Required \u00b6 Type: number Properties \u00b6 value Required \u00b6 public readonly value : any ; Type: any PodConnections \u00b6 Controls network isolation rules for inter-pod communication. Initializers \u00b6 import { PodConnections } from 'cdk8s-plus-24' new PodConnections ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-24.AbstractPod Methods \u00b6 allowFrom \u00b6 public allowFrom ( peer : INetworkPolicyPeer , options? : PodConnectionsAllowFromOptions ) peer Required \u00b6 Type: cdk8s-plus-24.INetworkPolicyPeer options Optional \u00b6 Type: cdk8s-plus-24.PodConnectionsAllowFromOptions allowTo \u00b6 public allowTo ( peer : INetworkPolicyPeer , options? : PodConnectionsAllowToOptions ) peer Required \u00b6 Type: cdk8s-plus-24.INetworkPolicyPeer options Optional \u00b6 Type: cdk8s-plus-24.PodConnectionsAllowToOptions PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import { PodDns } from 'cdk8s-plus-24' new PodDns ( props? : PodDnsProps ) props Optional \u00b6 Type: cdk8s-plus-24.PodDnsProps Methods \u00b6 addNameserver \u00b6 public addNameserver ( nameservers : string ) nameservers Required \u00b6 Type: string addOption \u00b6 public addOption ( options : DnsOption ) options Required \u00b6 Type: cdk8s-plus-24.DnsOption addSearch \u00b6 public addSearch ( searches : string ) searches Required \u00b6 Type: string Properties \u00b6 hostnameAsFQDN Required \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public readonly nameservers : string []; Type: string [] Nameservers defined for this pod. options Required \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-24.DnsOption [] Custom dns options defined for this pod. policy Required \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-24.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public readonly searches : string []; Type: string [] Search domains defined for this pod. hostname Optional \u00b6 public readonly hostname : string ; Type: string The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string The configured subdomain of the pod. PodScheduling \u00b6 Controls the pod scheduling strategy. Initializers \u00b6 import { PodScheduling } from 'cdk8s-plus-24' new PodScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-24.AbstractPod Methods \u00b6 assign \u00b6 public assign ( node : NamedNode ) node Required \u00b6 Type: cdk8s-plus-24.NamedNode attract \u00b6 public attract ( node : LabeledNode , options? : PodSchedulingAttractOptions ) node Required \u00b6 Type: cdk8s-plus-24.LabeledNode options Optional \u00b6 Type: cdk8s-plus-24.PodSchedulingAttractOptions colocate \u00b6 public colocate ( selector : IPodSelector , options? : PodSchedulingColocateOptions ) selector Required \u00b6 Type: cdk8s-plus-24.IPodSelector options Optional \u00b6 Type: cdk8s-plus-24.PodSchedulingColocateOptions separate \u00b6 public separate ( selector : IPodSelector , options? : PodSchedulingSeparateOptions ) selector Required \u00b6 Type: cdk8s-plus-24.IPodSelector options Optional \u00b6 Type: cdk8s-plus-24.PodSchedulingSeparateOptions tolerate \u00b6 public tolerate ( node : TaintedNode ) node Required \u00b6 Type: cdk8s-plus-24.TaintedNode PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import { PodSecurityContext } from 'cdk8s-plus-24' new PodSecurityContext ( props? : PodSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-24.PodSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean fsGroupChangePolicy Required \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-24.FsGroupChangePolicy sysctls Required \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-24.Sysctl [] fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-24' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-24.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-24' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-24.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import { Probe } from 'cdk8s-plus-24' Probe . fromTcpSocket ( options? : TcpSocketProbeOptions ) options Optional \u00b6 Type: cdk8s-plus-24.TcpSocketProbeOptions Options. ResourcePermissions \u00b6 Controls permissions for operations on resources. Initializers \u00b6 import { ResourcePermissions } from 'cdk8s-plus-24' new ResourcePermissions ( instance : Resource ) instance Required \u00b6 Type: cdk8s-plus-24.Resource Methods \u00b6 grantRead \u00b6 public grantRead ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-24.ISubject grantReadWrite \u00b6 public grantReadWrite ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-24.ISubject StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-24' StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-24' StatefulSetUpdateStrategy . rollingUpdate ( options? : StatefulSetUpdateStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-24.StatefulSetUpdateStrategyRollingUpdateOptions TaintedNode \u00b6 A node that is matched by taint selectors. Initializers \u00b6 import { TaintedNode } from 'cdk8s-plus-24' new TaintedNode ( taintSelector : NodeTaintQuery []) taintSelector Required \u00b6 Type: cdk8s-plus-24.NodeTaintQuery [] Properties \u00b6 taintSelector Required \u00b6 public readonly taintSelector : NodeTaintQuery []; Type: cdk8s-plus-24.NodeTaintQuery [] Topology \u00b6 Available topology domains. Static Functions \u00b6 custom \u00b6 import { Topology } from 'cdk8s-plus-24' Topology . custom ( key : string ) key Required \u00b6 Type: string Properties \u00b6 key Required \u00b6 public readonly key : string ; Type: string Constants \u00b6 HOSTNAME \u00b6 Type: cdk8s-plus-24.Topology A hostname represents a single node in the cluster. https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostname REGION \u00b6 Type: cdk8s-plus-24.Topology A region represents a larger domain, made up of one or more zones. It is uncommon for Kubernetes clusters to span multiple regions. While the exact definition of a zone or region is left to infrastructure implementations, common properties of a region include higher network latency between them than within them, non-zero cost for network traffic between them, and failure independence from other zones or regions. For example, nodes within a region might share power infrastructure (e.g. a UPS or generator), but nodes in different regions typically would not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesioregion ZONE \u00b6 Type: cdk8s-plus-24.Topology A zone represents a logical failure domain. It is common for Kubernetes clusters to span multiple zones for increased availability. While the exact definition of a zone is left to infrastructure implementations, common properties of a zone include very low network latency within a zone, no-cost network traffic within a zone, and failure independence from other zones. For example, nodes within a zone might share a network switch, but nodes in different zones should not. https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone WorkloadScheduling \u00b6 Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling. Initializers \u00b6 import { WorkloadScheduling } from 'cdk8s-plus-24' new WorkloadScheduling ( instance : AbstractPod ) instance Required \u00b6 Type: cdk8s-plus-24.AbstractPod Methods \u00b6 spread \u00b6 public spread ( options? : WorkloadSchedulingSpreadOptions ) options Optional \u00b6 Type: cdk8s-plus-24.WorkloadSchedulingSpreadOptions Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.ApiResource , cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.ClusterRole , cdk8s-plus-24.ClusterRoleBinding , cdk8s-plus-24.ConfigMap , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.Ingress , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.NetworkPolicy , cdk8s-plus-24.NonApiResource , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.Pod , cdk8s-plus-24.Resource , cdk8s-plus-24.Role , cdk8s-plus-24.RoleBinding , cdk8s-plus-24.Secret , cdk8s-plus-24.Service , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.Workload , cdk8s-plus-24.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.ApiResource , cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.ClusterRole , cdk8s-plus-24.ClusterRoleBinding , cdk8s-plus-24.ConfigMap , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.Ingress , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.NetworkPolicy , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.Pod , cdk8s-plus-24.Resource , cdk8s-plus-24.Role , cdk8s-plus-24.RoleBinding , cdk8s-plus-24.Secret , cdk8s-plus-24.Service , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.Workload , cdk8s-plus-24.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ClusterRole , cdk8s-plus-24.IClusterRole Represents a cluster-level role. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ConfigMap , cdk8s-plus-24.IConfigMap Represents a config map. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. INamespaceSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.Namespace , cdk8s-plus-24.Namespaces , cdk8s-plus-24.INamespaceSelector Represents an object that can select namespaces. Methods \u00b6 toNamespaceSelectorConfig \u00b6 public toNamespaceSelectorConfig () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. INetworkPolicyPeer \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.Namespaces , cdk8s-plus-24.NetworkPolicyIpBlock , cdk8s-plus-24.Pod , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.Workload , cdk8s-plus-24.INetworkPolicyPeer Describes a peer to allow traffic to/from. Methods \u00b6 toNetworkPolicyPeerConfig \u00b6 public toNetworkPolicyPeerConfig () toPodSelector \u00b6 public toPodSelector () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. IPersistentVolume \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSelector \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.Job , cdk8s-plus-24.Pod , cdk8s-plus-24.Pods , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.Workload , cdk8s-plus-24.IPodSelector Represents an object that can select pods. Methods \u00b6 toPodSelectorConfig \u00b6 public toPodSelectorConfig () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. IResource \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.ClusterRole , cdk8s-plus-24.ClusterRoleBinding , cdk8s-plus-24.ConfigMap , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.Ingress , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.NetworkPolicy , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.Pod , cdk8s-plus-24.Resource , cdk8s-plus-24.Role , cdk8s-plus-24.RoleBinding , cdk8s-plus-24.Secret , cdk8s-plus-24.Service , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.Workload , cdk8s-plus-24.IClusterRole , cdk8s-plus-24.IConfigMap , cdk8s-plus-24.IPersistentVolume , cdk8s-plus-24.IPersistentVolumeClaim , cdk8s-plus-24.IResource , cdk8s-plus-24.IRole , cdk8s-plus-24.ISecret , cdk8s-plus-24.IServiceAccount Represents a resource. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ClusterRole , cdk8s-plus-24.Role , cdk8s-plus-24.IRole A reference to any Role or ClusterRole. Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.Secret , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.ISecret Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.IServiceAccount Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IStorage \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.Volume , cdk8s-plus-24.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. ISubject \u00b6 Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.Group , cdk8s-plus-24.Job , cdk8s-plus-24.Pod , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.User , cdk8s-plus-24.Workload , cdk8s-plus-24.ISubject Represents an object that can be used as a role binding subject. Methods \u00b6 toSubjectConfiguration \u00b6 public toSubjectConfiguration () Properties \u00b6 node Required \u00b6 public readonly node : Node ; Type: constructs.Node The tree node. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. ConcurrencyPolicy \u00b6 Concurrency policy for CronJobs. ALLOW \u00b6 This policy allows to run job concurrently. FORBID \u00b6 This policy does not allow to run job concurrently. It does not let a new job to be scheduled if the previous one is not finished yet. REPLACE \u00b6 This policy replaces the currently running job if a new job is being scheduled. ConnectionScheme \u00b6 HTTP \u00b6 Use HTTP request for connecting to host. HTTPS \u00b6 Use HTTPS request for connecting to host. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HostPathVolumeType \u00b6 Host path types. DEFAULT \u00b6 Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. DIRECTORY_OR_CREATE \u00b6 If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. DIRECTORY \u00b6 A directory must exist at the given path. FILE_OR_CREATE \u00b6 If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. FILE \u00b6 A file must exist at the given path. SOCKET \u00b6 A UNIX socket must exist at the given path. CHAR_DEVICE \u00b6 A character device must exist at the given path. BLOCK_DEVICE \u00b6 A block device must exist at the given path. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. NetworkPolicyTrafficDefault \u00b6 Default behaviors of network traffic in policies. DENY \u00b6 The policy denies all traffic. Since rules are additive, additional rules or policies can allow specific traffic. ALLOW \u00b6 The policy allows all traffic (either ingress or egress). Since rules are additive, no additional rule or policies can subsequently deny the traffic. NetworkProtocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodConnectionsIsolation \u00b6 Isolation determines which policies are created when allowing connections from a a pod / workload to peers. POD \u00b6 Only creates network policies that select the pod. PEER \u00b6 Only creates network policies that select the peer. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 Network protocols. TCP \u00b6 TCP. UDP \u00b6 UDP. SCTP \u00b6 SCTP. ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type. TaintEffect \u00b6 Taint effects. NO_SCHEDULE \u00b6 This means that no pod will be able to schedule onto the node unless it has a matching toleration. PREFER_NO_SCHEDULE \u00b6 This is a \u201cpreference\u201d or \u201csoft\u201d version of NO_SCHEDULE \u2013 the system will try to avoid placing a pod that does not tolerate the taint on the node, but it is not required. NO_EXECUTE \u00b6 This affects pods that are already running on the node as follows:. Pods that do not tolerate the taint are evicted immediately. - Pods that tolerate the taint without specifying duration remain bound forever. - Pods that tolerate the taint with a specified duration remain bound for the specified amount of time.","title":"TypeScript"},{"location":"reference/cdk8s-plus-24/typescript/#cdk8s-plus-24-typescript","text":"","title":"cdk8s-plus-24 (TypeScript) "},{"location":"reference/cdk8s-plus-24/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-24/typescript/#abstractpod","text":"Implements: cdk8s-plus-24.IPodSelector , cdk8s-plus-24.INetworkPolicyPeer , cdk8s-plus-24.ISubject","title":"AbstractPod "},{"location":"reference/cdk8s-plus-24/typescript/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-24/typescript/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-24/typescript/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-24/typescript/#clusterrole","text":"Implements: cdk8s-plus-24.IClusterRole , cdk8s-plus-24.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-24/typescript/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-24/typescript/#configmap","text":"Implements: cdk8s-plus-24.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-24/typescript/#cronjob","text":"A CronJob is responsible for creating a Job and scheduling it based on provided cron schedule. This helps running Jobs in a recurring manner.","title":"CronJob "},{"location":"reference/cdk8s-plus-24/typescript/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-24/typescript/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Deployment "},{"location":"reference/cdk8s-plus-24/typescript/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-24/typescript/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-24/typescript/#group","text":"Implements: cdk8s-plus-24.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-24/typescript/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-24/typescript/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-24/typescript/#namespace","text":"Implements: cdk8s-plus-24.INamespaceSelector , cdk8s-plus-24.INetworkPolicyPeer In Kubernetes, namespaces provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc).","title":"Namespace "},{"location":"reference/cdk8s-plus-24/typescript/#namespaces","text":"Implements: cdk8s-plus-24.INamespaceSelector , cdk8s-plus-24.INetworkPolicyPeer Represents a group of namespaces.","title":"Namespaces "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicy","text":"Control traffic flow at the IP address or port level (OSI layer 3 or 4), network policies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network peers. Outgoing traffic is allowed if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the network policies that select the pod. Incoming traffic is allowed to a pod if there are no network policies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod\u2019s local node, OR if the traffic matches at least one ingress rule across all of the network policies that select the pod. Network policies do not conflict; they are additive. If any policy or policies apply to a given pod for a given direction, the connections allowed in that direction from that pod is the union of what the applicable policies allow. Thus, order of evaluation does not affect the policy result. For a connection from a source pod to a destination pod to be allowed, both the egress policy on the source pod and the ingress policy on the destination pod need to allow the connection. If either side does not allow the connection, it will not happen. https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource","title":"NetworkPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicyipblock","text":"Implements: cdk8s-plus-24.INetworkPolicyPeer Describes a particular CIDR (Ex. \u201c192.168.1.1/24\u201d,\u201d2001:db9::/64\u201d) that is allowed to the pods matched by a network policy selector. The except entry describes CIDRs that should not be included within this rule.","title":"NetworkPolicyIpBlock "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolume","text":"Implements: cdk8s-plus-24.IPersistentVolume , cdk8s-plus-24.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumeclaim","text":"Implements: cdk8s-plus-24.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-24/typescript/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-24/typescript/#pods","text":"Implements: cdk8s-plus-24.IPodSelector Represents a group of pods.","title":"Pods "},{"location":"reference/cdk8s-plus-24/typescript/#resource","text":"Implements: cdk8s-plus-24.IResource , cdk8s-plus-24.IApiResource , cdk8s-plus-24.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-24/typescript/#role","text":"Implements: cdk8s-plus-24.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-24/typescript/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-24/typescript/#secret","text":"Implements: cdk8s-plus-24.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-24/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-24/typescript/#serviceaccount","text":"Implements: cdk8s-plus-24.IServiceAccount , cdk8s-plus-24.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-24/typescript/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-24/typescript/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-24/typescript/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-24/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-24/typescript/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-24/typescript/#user","text":"Implements: cdk8s-plus-24.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-24/typescript/#volume","text":"Implements: cdk8s-plus-24.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-24/typescript/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-24/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-24/typescript/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-24/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-24/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-24/typescript/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-24/typescript/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/typescript/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/typescript/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-24/typescript/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-24/typescript/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-24/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-24/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-24/typescript/#containerport","text":"Represents a network port in a single container.","title":"ContainerPort "},{"location":"reference/cdk8s-plus-24/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-24/typescript/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-24/typescript/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-24/typescript/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-24/typescript/#cronjobprops","text":"Properties for CronJob .","title":"CronJobProps "},{"location":"reference/cdk8s-plus-24/typescript/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-24/typescript/#deploymentexposeviaserviceoptions","text":"Options for Deployment.exposeViaService .","title":"DeploymentExposeViaServiceOptions "},{"location":"reference/cdk8s-plus-24/typescript/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-24/typescript/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-24/typescript/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-24/typescript/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-24/typescript/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-24/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-24/typescript/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-24/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-24/typescript/#ephemeralstorageresources","text":"Emphemeral storage request and limit.","title":"EphemeralStorageResources "},{"location":"reference/cdk8s-plus-24/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-24/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-24/typescript/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/typescript/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-24/typescript/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-24/typescript/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-24/typescript/#hostpathvolumeoptions","text":"Options for a HostPathVolume-based volume.","title":"HostPathVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-24/typescript/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-24/typescript/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-24/typescript/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-24/typescript/#labelselectoroptions","text":"Options for LabelSelector.of .","title":"LabelSelectorOptions "},{"location":"reference/cdk8s-plus-24/typescript/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-24/typescript/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-24/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-24/typescript/#namespaceprops","text":"Properties for Namespace .","title":"NamespaceProps "},{"location":"reference/cdk8s-plus-24/typescript/#namespaceselectorconfig","text":"Configuration for selecting namespaces.","title":"NamespaceSelectorConfig "},{"location":"reference/cdk8s-plus-24/typescript/#namespacesselectoptions","text":"Options for Namespaces.select .","title":"NamespacesSelectOptions "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicyaddegressruleoptions","text":"Options for NetworkPolicy.addEgressRule .","title":"NetworkPolicyAddEgressRuleOptions "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicypeerconfig","text":"Configuration for network peers. A peer can either by an ip block, or a selection of pods, not both.","title":"NetworkPolicyPeerConfig "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicyportprops","text":"Properties for NetworkPolicyPort .","title":"NetworkPolicyPortProps "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicyprops","text":"Properties for NetworkPolicy .","title":"NetworkPolicyProps "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicyrule","text":"Describes a rule allowing traffic from / to pods matched by a network policy selector.","title":"NetworkPolicyRule "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicytraffic","text":"Describes how the network policy should configure egress / ingress traffic.","title":"NetworkPolicyTraffic "},{"location":"reference/cdk8s-plus-24/typescript/#nodetaintqueryoptions","text":"Options for NodeTaintQuery .","title":"NodeTaintQueryOptions "},{"location":"reference/cdk8s-plus-24/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-24/typescript/#podconnectionsallowfromoptions","text":"Options for PodConnections.allowFrom .","title":"PodConnectionsAllowFromOptions "},{"location":"reference/cdk8s-plus-24/typescript/#podconnectionsallowtooptions","text":"Options for PodConnections.allowTo .","title":"PodConnectionsAllowToOptions "},{"location":"reference/cdk8s-plus-24/typescript/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-24/typescript/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-24/typescript/#podsalloptions","text":"Options for Pods.all .","title":"PodsAllOptions "},{"location":"reference/cdk8s-plus-24/typescript/#podschedulingattractoptions","text":"Options for PodScheduling.attract .","title":"PodSchedulingAttractOptions "},{"location":"reference/cdk8s-plus-24/typescript/#podschedulingcolocateoptions","text":"Options for PodScheduling.colocate .","title":"PodSchedulingColocateOptions "},{"location":"reference/cdk8s-plus-24/typescript/#podschedulingseparateoptions","text":"Options for PodScheduling.separate .","title":"PodSchedulingSeparateOptions "},{"location":"reference/cdk8s-plus-24/typescript/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-24/typescript/#podselectorconfig","text":"Configuration for selecting pods, optionally in particular namespaces.","title":"PodSelectorConfig "},{"location":"reference/cdk8s-plus-24/typescript/#podsselectoptions","text":"Options for Pods.select .","title":"PodsSelectOptions "},{"location":"reference/cdk8s-plus-24/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-24/typescript/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-24/typescript/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-24/typescript/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-24/typescript/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-24/typescript/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-24/typescript/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#servicebindoptions","text":"Options for Service.bind .","title":"ServiceBindOptions "},{"location":"reference/cdk8s-plus-24/typescript/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-24/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-24/typescript/#serviceprops","text":"Properties for Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-24/typescript/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-24/typescript/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-24/typescript/#subjectconfiguration","text":"Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"SubjectConfiguration "},{"location":"reference/cdk8s-plus-24/typescript/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-24/typescript/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-24/typescript/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-24/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-24/typescript/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-24/typescript/#workloadschedulingspreadoptions","text":"Options for WorkloadScheduling.spread .","title":"WorkloadSchedulingSpreadOptions "},{"location":"reference/cdk8s-plus-24/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-24/typescript/#apiresource","text":"Implements: cdk8s-plus-24.IApiResource , cdk8s-plus-24.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-24/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-24/typescript/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-24/typescript/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-24/typescript/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-24/typescript/#env","text":"Container environment variables.","title":"Env "},{"location":"reference/cdk8s-plus-24/typescript/#envfrom","text":"A collection of env variables defined in other resources.","title":"EnvFrom "},{"location":"reference/cdk8s-plus-24/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-24/typescript/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-24/typescript/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-24/typescript/#labelednode","text":"A node that is matched by label selectors.","title":"LabeledNode "},{"location":"reference/cdk8s-plus-24/typescript/#labelexpression","text":"Represents a query that can be performed against resources with labels.","title":"LabelExpression "},{"location":"reference/cdk8s-plus-24/typescript/#labelselector","text":"Match a resource by labels.","title":"LabelSelector "},{"location":"reference/cdk8s-plus-24/typescript/#namednode","text":"A node that is matched by its name.","title":"NamedNode "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicyport","text":"Describes a port to allow traffic on.","title":"NetworkPolicyPort "},{"location":"reference/cdk8s-plus-24/typescript/#node","text":"Represents a node in the cluster.","title":"Node "},{"location":"reference/cdk8s-plus-24/typescript/#nodelabelquery","text":"Represents a query that can be performed against nodes with labels.","title":"NodeLabelQuery "},{"location":"reference/cdk8s-plus-24/typescript/#nodetaintquery","text":"Taint queries that can be perfomed against nodes.","title":"NodeTaintQuery "},{"location":"reference/cdk8s-plus-24/typescript/#nonapiresource","text":"Implements: cdk8s-plus-24.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-24/typescript/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-24/typescript/#podconnections","text":"Controls network isolation rules for inter-pod communication.","title":"PodConnections "},{"location":"reference/cdk8s-plus-24/typescript/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-24/typescript/#podscheduling","text":"Controls the pod scheduling strategy.","title":"PodScheduling "},{"location":"reference/cdk8s-plus-24/typescript/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-24/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-24/typescript/#resourcepermissions","text":"Controls permissions for operations on resources.","title":"ResourcePermissions "},{"location":"reference/cdk8s-plus-24/typescript/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-24/typescript/#taintednode","text":"A node that is matched by taint selectors.","title":"TaintedNode "},{"location":"reference/cdk8s-plus-24/typescript/#topology","text":"Available topology domains.","title":"Topology "},{"location":"reference/cdk8s-plus-24/typescript/#workloadscheduling","text":"Controls the pod scheduling strategy of this workload. It offers some additional API\u2019s on top of the core pod scheduling.","title":"WorkloadScheduling "},{"location":"reference/cdk8s-plus-24/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-24/typescript/#iapiendpoint","text":"Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.ApiResource , cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.ClusterRole , cdk8s-plus-24.ClusterRoleBinding , cdk8s-plus-24.ConfigMap , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.Ingress , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.NetworkPolicy , cdk8s-plus-24.NonApiResource , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.Pod , cdk8s-plus-24.Resource , cdk8s-plus-24.Role , cdk8s-plus-24.RoleBinding , cdk8s-plus-24.Secret , cdk8s-plus-24.Service , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.Workload , cdk8s-plus-24.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-24/typescript/#iapiresource","text":"Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.ApiResource , cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.ClusterRole , cdk8s-plus-24.ClusterRoleBinding , cdk8s-plus-24.ConfigMap , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.Ingress , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.NetworkPolicy , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.Pod , cdk8s-plus-24.Resource , cdk8s-plus-24.Role , cdk8s-plus-24.RoleBinding , cdk8s-plus-24.Secret , cdk8s-plus-24.Service , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.Workload , cdk8s-plus-24.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-24/typescript/#iclusterrole","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ClusterRole , cdk8s-plus-24.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-24/typescript/#iconfigmap","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ConfigMap , cdk8s-plus-24.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-24/typescript/#inamespaceselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.Namespace , cdk8s-plus-24.Namespaces , cdk8s-plus-24.INamespaceSelector Represents an object that can select namespaces.","title":"INamespaceSelector "},{"location":"reference/cdk8s-plus-24/typescript/#inetworkpolicypeer","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.Namespaces , cdk8s-plus-24.NetworkPolicyIpBlock , cdk8s-plus-24.Pod , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.Workload , cdk8s-plus-24.INetworkPolicyPeer Describes a peer to allow traffic to/from.","title":"INetworkPolicyPeer "},{"location":"reference/cdk8s-plus-24/typescript/#ipersistentvolume","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-24/typescript/#ipersistentvolumeclaim","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-24/typescript/#ipodselector","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.Job , cdk8s-plus-24.Pod , cdk8s-plus-24.Pods , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.Workload , cdk8s-plus-24.IPodSelector Represents an object that can select pods.","title":"IPodSelector "},{"location":"reference/cdk8s-plus-24/typescript/#iresource","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.ClusterRole , cdk8s-plus-24.ClusterRoleBinding , cdk8s-plus-24.ConfigMap , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.Ingress , cdk8s-plus-24.Job , cdk8s-plus-24.Namespace , cdk8s-plus-24.NetworkPolicy , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.PersistentVolumeClaim , cdk8s-plus-24.Pod , cdk8s-plus-24.Resource , cdk8s-plus-24.Role , cdk8s-plus-24.RoleBinding , cdk8s-plus-24.Secret , cdk8s-plus-24.Service , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.Workload , cdk8s-plus-24.IClusterRole , cdk8s-plus-24.IConfigMap , cdk8s-plus-24.IPersistentVolume , cdk8s-plus-24.IPersistentVolumeClaim , cdk8s-plus-24.IResource , cdk8s-plus-24.IRole , cdk8s-plus-24.ISecret , cdk8s-plus-24.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-24/typescript/#irole","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ClusterRole , cdk8s-plus-24.Role , cdk8s-plus-24.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-24/typescript/#isecret","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.BasicAuthSecret , cdk8s-plus-24.DockerConfigSecret , cdk8s-plus-24.Secret , cdk8s-plus-24.ServiceAccountTokenSecret , cdk8s-plus-24.SshAuthSecret , cdk8s-plus-24.TlsSecret , cdk8s-plus-24.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-24/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-24.IResource Implemented By: cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-24/typescript/#istorage","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AwsElasticBlockStorePersistentVolume , cdk8s-plus-24.AzureDiskPersistentVolume , cdk8s-plus-24.GCEPersistentDiskPersistentVolume , cdk8s-plus-24.PersistentVolume , cdk8s-plus-24.Volume , cdk8s-plus-24.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-24/typescript/#isubject","text":"Extends: constructs.IConstruct Implemented By: cdk8s-plus-24.AbstractPod , cdk8s-plus-24.CronJob , cdk8s-plus-24.DaemonSet , cdk8s-plus-24.Deployment , cdk8s-plus-24.Group , cdk8s-plus-24.Job , cdk8s-plus-24.Pod , cdk8s-plus-24.ServiceAccount , cdk8s-plus-24.StatefulSet , cdk8s-plus-24.User , cdk8s-plus-24.Workload , cdk8s-plus-24.ISubject Represents an object that can be used as a role binding subject.","title":"ISubject "},{"location":"reference/cdk8s-plus-24/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-24/typescript/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-24/typescript/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-24/typescript/#concurrencypolicy","text":"Concurrency policy for CronJobs.","title":"ConcurrencyPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#connectionscheme","text":"","title":"ConnectionScheme "},{"location":"reference/cdk8s-plus-24/typescript/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-24/typescript/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-24/typescript/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-24/typescript/#hostpathvolumetype","text":"Host path types.","title":"HostPathVolumeType "},{"location":"reference/cdk8s-plus-24/typescript/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-24/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-24/typescript/#networkpolicytrafficdefault","text":"Default behaviors of network traffic in policies.","title":"NetworkPolicyTrafficDefault "},{"location":"reference/cdk8s-plus-24/typescript/#networkprotocol","text":"Network protocols.","title":"NetworkProtocol "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-24/typescript/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#podconnectionsisolation","text":"Isolation determines which policies are created when allowing connections from a a pod / workload to peers.","title":"PodConnectionsIsolation "},{"location":"reference/cdk8s-plus-24/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#protocol","text":"Network protocols.","title":"Protocol "},{"location":"reference/cdk8s-plus-24/typescript/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-24/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-24/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-24/typescript/#tainteffect","text":"Taint effects.","title":"TaintEffect "}]}